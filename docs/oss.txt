* OSS
Follows is a source code listing for all files that have been open sourced. This code can be found online at [[https://github.com/DragonRuby/dragonruby-game-toolkit-contrib/]].
** api.rb
#+begin_src ruby
  # ./dragon/api.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # api.rb has been released under MIT (*only this file*).
  
  # Contributors outside of DragonRuby who also hold Copyright:
  # - Kevin Fischer: https://github.com/kfischer-okarin
  
  module GTK
    class Api
      def initialize
      end
  
      def get_api_autocomplete args, req
        html = <<-S
  <html>
    <head>
      <meta charset="UTF-8"/>
      <title>DragonRuby Game Toolkit Documentation</title>
      <style>
      pre {
        border: solid 1px silver;
        padding: 10px;
        font-size: 14px;
        white-space: pre-wrap;
        white-space: -moz-pre-wrap;
        white-space: -pre-wrap;
        white-space: -o-pre-wrap;
        word-wrap: break-word;
      }
      </style>
    </head>
    <body>
        <script>
          async function submitForm() {
            const result = await fetch("/dragon/autocomplete/", {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ index: document.getElementById("index").value,
                                     text: document.getElementById("text").value }),
            });
            document.getElementById("autocomplete-results").innerHTML = await result.text();
          }
        </script>
        <form>
          <div>index</div>
          <input name="index" id="index" type="text" value="27" />
          <div>code</div>
          <textarea name="text" id="text" rows="30" cols="80">def tick args
    args.state.
  end</textarea>
          <br/>
          <input type="button" value="Get Suggestions" onclick="submitForm();" />
          <span id="success-notification"></span>
        </form>
        <pre id="autocomplete-results">
        </pre>
  
      #{links}
    </body>
  </html>
  S
  
        req.respond 200,
                    html,
                    { 'Content-Type' => 'text/html' }
      end
  
      def post_api_autocomplete args, req
        json  = ($gtk.parse_json req.body)
        index = json["index"].to_i
        text  = json["text"]
        suggestions = args.gtk.suggest_autocompletion index: index, text: text
        list_as_string = suggestions.join("\n")
        req.respond 200, list_as_string, { 'Content-Type' => 'text/plain' }
      end
  
      define_method :links do
        <<-S
      <ul>
        <li><a href="/">Home</a></li>
        <li><a href="/docs.html">Docs</a></li>
        <li><a href="/src_backup_changes.html">Source Code Backup</a>
        <li><a href="/dragon/control_panel/">Control Panel</a></li>
        <li><a href="/dragon/eval/">Console</a></li>
        <li><a href="/dragon/log/">Logs</a></li>
        <li><a href="/dragon/code/">Code</a></li>
      </ul>
  S
      end
  
      def get_index args, req
        req.respond 200, <<-S, { 'Content-Type' => 'text/html' }
  <html>
    <head>
      <meta charset="UTF-8"/>
      <title>DragonRuby Game Toolkit Documentation</title>
    </head>
    <body>
      #{links}
    </body>
  </html>
  S
      end
  
      def source_code_links args
        links = args.gtk.reload_list_history.keys.map do |f|
          "<li><a href=\"/dragon/code/edit/?file=#{f}\">#{f}</a></li>"
        end
        <<-S
  <ul>
    #{links.join("\n")}
  </ul>
  S
      end
  
      def get_api_code args, req
        view = <<-S
  <html>
    <head>
      <meta charset="UTF-8"/>
      <title>DragonRuby Game Toolkit Documentation</title>
    </head>
    <body>
      #{source_code_links args}
  
      #{links}
    </body>
  </html>
  S
        req.respond 200,
                    view,
                    { 'Content-Type' => 'text/html' }
      end
  
      def code_edit_view args, file
        view = <<-S
  <html>
    <head>
      <meta charset="UTF-8"/>
      <title>DragonRuby Game Toolkit Documentation</title>
    </head>
    <body>
        <script>
          async function submitForm() {
            const result = await fetch("/dragon/code/update/?file=#{file}", {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ code: document.getElementById("code").value }),
            });
            document.getElementById("success-notification").innerHTML = "update successful";
            setTimeout(function() { document.getElementById("success-notification").innerHTML = ""; }, 3000);
          }
        </script>
        <form>
          <div><code>#{file}:</code></div>
          <textarea name="code" id="code" rows="30" cols="80">#{args.gtk.read_file file}</textarea>
          <br/>
          <input type="button" value="Update" onclick="submitForm();" />
          <span id="success-notification"></span>
        </form>
      #{source_code_links args}
  
      #{links}
    </body>
  </html>
  S
      end
  
      def get_api_code_edit args, req
        query_params = get_query_params req
        file = query_params['file']
        view = code_edit_view args, file
        req.respond 200,
                    view,
                    { 'Content-Type' => 'text/html' }
      end
  
      def post_api_code_update args, req
        if json? req
          query_params = get_query_params req
          file = query_params['file']
          code = ($gtk.parse_json req.body)["code"]
          args.gtk.write_file file, code
        end
        view = code_edit_view args, file
        req.respond 200,
                    view,
                    { 'Content-Type' => 'text/html' }
      end
  
  
      def get_api_log args, req
        req.respond 200,
                    args.gtk.read_file("logs/log.txt"),
                    { 'Content-Type' => 'text/plain' }
      end
  
      def post_api_log args, req
        Log.log req.body
  
        req.respond 200,
                    "ok",
                    { 'Content-Type' => 'text/plain' }
      end
  
      def get_src_backup args, req
        file_name = req.uri.gsub("/dragon/", "")
        req.respond 200,
                    args.gtk.read_file("tmp/src_backup/#{file_name}"),
                    { 'Content-Type' => 'text/plain' }
      end
  
      def get_not_found args, req
        puts("METHOD: #{req.method}");
        puts("URI: #{req.uri}");
        puts("HEADERS:");
        req.headers.each { |k,v| puts("  #{k}: #{v}") }
        req.respond 404, "not found: #{req.uri}", { }
      end
  
      def get_api_eval args, req
        eval_view = <<-S
  <html lang="en">
    <head><title>Eval</title></head>
    <style>
    pre {
      border: solid 1px silver;
      padding: 10px;
      font-size: 14px;
      white-space: pre-wrap;
      white-space: -moz-pre-wrap;
      white-space: -pre-wrap;
      white-space: -o-pre-wrap;
      word-wrap: break-word;
    }
    </style>
    <body>
      <script>
        var escape = document.createElement('textarea');
        function escapeHTML(html) {
            escape.textContent = html;
            return escape.innerHTML;
        }
  
        async function submitForm() {
            const result = await fetch("/dragon/eval/", {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ code: document.getElementById("code").value }),
            });
            document.getElementById("eval-result").innerHTML = escapeHTML(await result.text());
        }
      </script>
      <form>
        <textarea name="code" id="code" rows="10" cols="80"># write your code here\n$gtk.args.state</textarea>
        <br/>
        <input type="button" onclick="submitForm();" value="submit" />
      </form>
      <pre>curl -H "Content-Type: application/json" --data '{ "code": "$args.state" }' -X POST http://localhost:9001/dragon/eval/</pre>
      <div>Eval Result:</div>
      <pre id="eval-result"></pre>
      #{links}
    </body>
  </html>
  S
        req.respond 200,
                    eval_view,
                    { 'Content-Type' => 'text/html' }
      end
  
      def post_api_eval args, req
        if json? req
          code = ($gtk.parse_json req.body)["code"]
          result = nil
          Object.new.instance_eval do
            begin
              result = Kernel.eval code
            rescue Exception => e
              result = e
            end
          end
  
          req.respond 200,
                      "#{result}",
                      { 'Content-Type' => 'text/plain' }
        else
          req.respond 200,
                      "",
                      { 'Content-Type' => 'text/plain' }
        end
      end
  
      def control_panel_view
        <<-S
  <html lang="en">
    <head><title>console</title></head>
    <body>
      <script>
        async function submitForm(url) {
          const result = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({}),
          });
          document.getElementById("success-notification").innerHTML = "successful";
          setTimeout(function() { document.getElementById("success-notification").innerHTML = ""; }, 3000);
        }
      </script>
      <form>
        <input type="button" value="Show Console" onclick="submitForm('/dragon/show_console/')" />
      </form>
      <form>
        <input type="button" value="Reset Game" onclick="submitForm('/dragon/reset/');" />
      </form>
      <form>
        <input type="button" value="Record Gameplay" onclick="submitForm('/dragon/record/');" />
      </form>
      <form>
        <input type="button" value="Stop Recording" onclick="submitForm('/dragon/record_stop/');" />
      </form>
      <form>
        <input type="button" value="Replay Recording" onclick="submitForm('/dragon/replay/');" />
      </form>
  
      <div id="success-notification"></div>
      #{links}
    </body>
  </html>
  S
      end
  
      def get_api_control_panel args, req
        req.respond 200,
                    control_panel_view,
                    { 'Content-Type' => 'text/html' }
      end
  
      def get_api_changes args, req
        req.respond 200,
                    args.gtk.read_file("tmp/src_backup/src_backup_changes.txt"),
                    { 'Content-Type' => 'text/plain' }
      end
  
      def json? req
        req.headers.find { |k, v| k == "Content-Type" && (v.strip == "application/json") }
      end
  
      def post_api_reset args, req
        $gtk.reset if json? req
        req.respond 200,
                    control_panel_view,
                    { 'Content-Type' => 'text/html' }
      end
  
      def post_api_record args, req
        $recording.start 100 if json? req
        req.respond 200,
                    control_panel_view,
                    { 'Content-Type' => 'text/html' }
      end
  
      def post_api_record_stop args, req
        $recording.stop 'replay.txt' if json? req
        req.respond 200,
                    control_panel_view,
                    { 'Content-Type' => 'text/html' }
      end
  
      def post_api_replay args, req
        $replay.start 'replay.txt' if json? req
        req.respond 200,
                    control_panel_view,
                    { 'Content-Type' => 'text/html' }
      end
  
      def post_api_show_console args, req
        $gtk.console.show if json? req
        req.respond 200,
                    control_panel_view,
                    { 'Content-Type' => 'text/html' }
      end
  
      def get_api_log args, req
        log_contents = $gtk.read_file "logs/#{$gtk.get_game_id}.log"
        req.respond 200,
                    log_contents,
                    { 'Content-Type' => 'text/plain' }
      end
  
      def tick args
        args.inputs.http_requests.each do |req|
          uri, query_string = get_uri_and_query_string req
          match_candidate = { method:                   req.method.downcase.to_sym,
                              uri:                      uri,
                              query_string:             query_string,
                              has_query_string:         !!query_string,
                              end_with_rb:              uri.end_with?('.rb'),
                              has_file_extension:       file_extensions.find { |f| uri.include? f },
                              has_trailing_slash:       uri.end_with?('/') }
  
          if !match_candidate[:has_file_extension] && !match_candidate[:has_trailing_slash]
            match_candidate[:uri] += '/'
          end
  
          context = { args: args, req: req, match_candidate: match_candidate }
  
          process! context: context, routes: routes
        end
      end
  
      def url_decode args, string
        args.fn.gsub string,
                     '+', " ",
                     '%27',    "'",
                     '%22',    '"',
                     '%0D%0A', "\n",
                     '%3D',    "=",
                     '%3B',    ";",
                     '%7C',    "|",
                     '%28',    "(",
                     '%29',    ")",
                     '%7B',    "{",
                     '%7D',    "}",
                     '%2C',    ",",
                     '%3A',    ":",
                     '%5B',    "[",
                     '%5D',    "]",
                     '%23',    "#",
                     '%21',    "!",
                     '%3C',    "<",
                     '%3E',    ">",
                     '%2B',    "+",
                     '%2F',    "/",
                     '%40',    "@",
                     '%3F',    "?",
                     '%26',    "&",
                     '%24',    "$",
                     '%5C',    "\\",
                     '%60',    "`",
                     '%7E',    "~",
                     '%C2%B2', "²",
                     '%5E',    "^",
                     '%C2%BA', "º",
                     '%C2%A7', "§",
                     '%20',    " ",
                     '%0A',    "\n",
                     '%25',    "%",
                     '%2A',    "*"
      end
  
      def file_extensions
        [".html", ".css", ".gif", ".txt", ".ico", ".rb"]
      end
  
      def routes
        [{ match_criteria: { method: :get, uri: "/" },
           handler:        :get_index },
         { match_criteria: { method: :get, uri: "/dragon/" },
           handler:        :get_index },
         { match_criteria: { method: :get, uri: "/dragon/log/" },
           handler:        :get_api_log },
         { match_criteria: { method: :post, uri: "/dragon/log/" },
           handler:        :post_api_log },
         { match_criteria: { method: :get, uri: "/dragon/eval/" },
           handler:        :get_api_eval },
         { match_criteria: { method: :post, uri: "/dragon/eval/" },
           handler:        :post_api_eval },
         { match_criteria: { method: :get, uri: "/dragon/control_panel/" },
           handler:        :get_api_control_panel },
         { match_criteria: { method: :post, uri: "/dragon/reset/" },
           handler:        :post_api_reset },
         { match_criteria: { method: :post, uri: "/dragon/record/" },
           handler:        :post_api_record },
         { match_criteria: { method: :post, uri: "/dragon/record_stop/" },
           handler:        :post_api_record_stop },
         { match_criteria: { method: :post, uri: "/dragon/replay/" },
           handler:        :post_api_replay },
         { match_criteria: { method: :post, uri: "/dragon/show_console/" },
           handler:        :post_api_show_console },
         { match_criteria: { method: :get, uri: "/dragon/code/" },
           handler:        :get_api_code },
         { match_criteria: { method: :get, uri: "/dragon/autocomplete/" },
           handler:        :get_api_autocomplete },
         { match_criteria: { method: :post, uri: "/dragon/autocomplete/" },
           handler:        :post_api_autocomplete },
         { match_criteria: { method: :get, uri: "/dragon/code/edit/", has_query_string: true },
           handler:        :get_api_code_edit },
         { match_criteria: { method: :post, uri: "/dragon/code/update/", has_query_string: true },
           handler:        :post_api_code_update },
         { match_criteria: { method: :get, end_with_rb: true },
           handler:        :get_src_backup },
         { match_criteria: { method: :get, uri: "/dragon/changes/" },
           handler:        :get_api_changes },
         *static_file_routes
        ]
      end
  
      def process! opts
        routes  = opts[:routes]
        context = opts[:context]
        routes.each do |route|
          match_found = (process_single! route: route, context: context)
          return if match_found
        end
        get_not_found context[:args], context[:req]
      end
  
      def process_single! opts
        match_criteria  = opts[:route][:match_criteria]
        m               = opts[:route][:handler]
        args            = opts[:context][:args]
        req             = opts[:context][:req]
        match_candidate = opts[:context][:match_candidate]
        match_criteria.each do |k, v|
          return false if match_candidate[k] != v
        end
  
        begin
          send m, args, req
        rescue Exception => e
          req.respond 200,
                      "#{e}\n#{e.__backtrace_to_org__}",
                      { 'Content-Type' => 'text/plain' }
        end
        return true
      end
  
      def static_file_routes
        STATIC_FILES.map { |uri, file_info|
          {
            match_criteria: { method: :get, uri: uri },
            handler: file_info[:cached] ? :get_cached_static_file : :get_static_file
          }
        }
      end
  
      def get_cached_static_file args, req
        uri = (req.uri.split '?').first
        file_info = STATIC_FILES[uri]
        @static_file_cache ||= {}
        @static_file_cache[uri] ||= args.gtk.read_file(file_info[:source])
        req.respond 200,
                    @static_file_cache[uri],
                    { 'Content-Type' => file_info[:content_type] }
      end
  
      def get_static_file args, req
        uri = (req.uri.split '?').first
        file_info = STATIC_FILES[uri]
        req.respond 200,
                    args.gtk.read_file(file_info[:source]),
                    { 'Content-Type' => file_info[:content_type] }
      end
  
      STATIC_FILES = {
        '/dragon/boot/' => {
          source: 'tmp/src_backup/boot.txt',
          content_type: 'text/plain'
        },
        '/docs.html' => {
          source: 'docs/docs.html',
          content_type: 'text/html'
        },
        '/docs.css' => {
          source: 'docs/docs.css',
          content_type: 'text/css',
          cached: true
        },
        '/docs_search.gif' => {
          source: 'docs/docs_search.gif',
          content_type: 'image/gif',
          cached: true
        },
        '/src_backup_index.html' => {
          source: 'tmp/src_backup/src_backup_index.html',
          content_type: 'text/html'
        },
        '/src_backup_index.txt' => {
          source: 'tmp/src_backup/src_backup_index.txt',
          content_type: 'text/plain'
        },
        '/src_backup_changes.html' => {
          source: 'tmp/src_backup/src_backup_changes.html',
          content_type: 'text/html'
        },
        '/src_backup_changes.txt' => {
          source: 'tmp/src_backup/src_backup_changes.txt',
          content_type: 'text/plain'
        },
        '/src_backup.css' => {
          source: 'tmp/src_backup/src_backup.css',
          content_type: 'text/css',
          cached: true
        },
        '/favicon.ico' => {
          source: 'docs/favicon.ico',
          content_type: 'image/x-icon',
          cached: true
        }
      }.freeze
  
      def get_query_params req
        _, query_string = get_uri_and_query_string req
        query_string.split('&').map { |pair|
          pair.split('=')
        }.to_h
      end
  
      def get_uri_and_query_string req
        req.uri.split('?', 2)
      end
    end
  end

#+end_src

** args.rb
#+begin_src ruby
  # ./dragon/args.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # args.rb has been released under MIT (*only this file*).
  
  module GTK
    class Args
      include ArgsDeprecated
      include Serialize
      attr_accessor :cvars
      attr_accessor :inputs
      attr_accessor :outputs
      attr_accessor :audio
      attr_accessor :grid
      attr_accessor :recording
      attr_accessor :geometry
      attr_accessor :fn
      attr_accessor :state
      attr_accessor :temp_state
      attr_accessor :runtime
      attr_accessor :events
      alias_method :gtk, :runtime
      attr_accessor :passes
      attr_accessor :wizards
      attr_accessor :layout
      attr_accessor :easing
      attr_accessor :string
  
      def initialize runtime, recording
        @inputs = Inputs.new
        @outputs = Outputs.new args: self
        @cvars = {}
        @audio = {}
        @passes = []
        @state = OpenEntity.new
        @temp_state = OpenEntity.new
        @state.tick_count = -1
        @runtime = runtime
        @recording = recording
        @grid = Grid.new runtime
        @render_targets = {}
        @pixel_arrays = {}
        @all_tests = []
        @geometry = GTK::Geometry
        @fn = GTK::Fn
        @render_targets_render_at = {}
        @wizards = Wizards.new
        ratio_w = 16
        ratio_h = 9
        if runtime.orientation == :portrait
          ratio_w = 9
          ratio_h = 16
        end
        @layout = GTK::Layout.new @grid.w, @grid.h, ratio_w, ratio_h, runtime.orientation
        @easing = GTK::Easing
        @string = String
        @events = {
          resize_occurred: false
        }
      end
  
      def tick_count
        @state.tick_count
      end
  
      def tick_count= value
        @state.tick_count = value
      end
  
      def serialize
        {
          state:      state.as_hash,
          temp_state: temp_state.as_hash,
          inputs:     inputs.serialize,
          passes:     passes.serialize,
          outputs:    outputs.serialize,
          grid:       grid.serialize
        }
      end
  
      def destructure
        [grid, inputs, state, outputs, runtime, passes]
      end
  
      def clear_pixel_arrays
        pixel_arrays_clear
      end
  
      def pixel_arrays_clear
        @pixel_arrays = {}
      end
  
      def pixel_arrays
        @pixel_arrays
      end
  
      def pixel_array name
        name = name.to_s
        if !@pixel_arrays[name]
          @pixel_arrays[name] = PixelArray.new
        end
        @pixel_arrays[name]
      end
  
      def clear_render_targets
        render_targets_clear
      end
  
      def render_targets_clear
        @render_targets = {}
      end
  
      def render_targets
        @render_targets
      end
  
      def render_target name
        name = name.to_s
        if !@render_targets[name]
          @render_targets[name] = Outputs.new(args: self, target: name, background_color_override: [255, 255, 255, 0])
          @passes << @render_targets[name]
        end
        @render_targets[name]
      end
  
      def render_targets_render_at
        @render_targets_render_at ||= {}
      end
  
      def solids
        @outputs.solids
      end
  
      def static_solids
        @outputs.static_solids
      end
  
      def sprites
        @outputs.sprites
      end
  
      def static_sprites
        @outputs.static_sprites
      end
  
      def labels
        @outputs.labels
      end
  
      def static_labels
        @outputs.static_labels
      end
  
      def lines
        @outputs.lines
      end
  
      def static_lines
        @outputs.static_lines
      end
  
      def borders
        @outputs.borders
      end
  
      def static_borders
        @outputs.static_borders
      end
  
      def primitives
        @outputs.primitives
      end
  
      def static_primitives
        @outputs.static_primitives
      end
  
      def keyboard
        @inputs.keyboard
      end
  
      def click
        return nil unless @inputs.mouse.click
  
        @inputs.mouse.click.point
      end
  
      def click_at
        return nil unless @inputs.mouse.click
  
        @inputs.mouse.click.created_at
      end
  
      def mouse
        @inputs.mouse
      end
  
      def controller_one
        @inputs.controller_one
      end
  
      def controller_two
        @inputs.controller_two
      end
  
      def controller_three
        @inputs.controller_three
      end
  
      def controller_four
        @inputs.controller_four
      end
  
      def autocomplete_methods
        [:inputs, :outputs, :gtk, :state, :geometry, :audio, :grid, :layout, :fn]
      end
  
      def reset
        @state.tick_count = Kernel.tick_count
        @outputs.clear
        @audio.clear
        # on reset of the game, we want to clear out render target's historical events
        # this hash is used to control whether a render target will be marked as transient or not
        @render_targets_render_at.clear
      end
  
      def method_missing name, *args, &block
        if (args.length <= 1) && (@state.as_hash.key? name)
          raise <<-S
  * ERROR - :#{name} method missing on ~#{self.class.name}~.
  The method
    :#{name}
  with args
    #{args}
  doesn't exist on #{inspect}.
  ** POSSIBLE SOLUTION - ~args.state.#{name}~ exists.
  Did you forget ~.state~ before ~.#{name}~?
  S
        end
  
        super
      end
    end
  end

#+end_src

** assert.rb
#+begin_src ruby
  # ./dragon/assert.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # assert.rb has been released under MIT (*only this file*).
  
  module GTK
  =begin
  This is a tiny assertion api for the unit testing portion of Game Toolkit.
  
  @example
  
  1. Create a file called tests.rb under mygame.
  2. Any method that begins with the word test_ will be considered a test.
  
  def test_this_works args, assert
    assert.equal! 1, 1
  end
  
  3. To run a test, save the file while the game is running.
  
  @example
  
  To add an assertion open up this class and write:
  
  class Assert
    def custom_assertion actual, expected, message = nil
      # this tells Game Toolkit that an assertion was performed (so that the test isn't marked inconclusive).
      @assertion_performed = true
  
      # perform your custom logic here and raise an exception to denote a failure.
  
      raise "Some Error. #{message}."
    end
  end
  =end
    class Assert
      attr :assertion_performed
  
  =begin
  Use this if you are throwing your own exceptions and you want to mark the tests as ran (so that it wont be marked as inconclusive).
  =end
      def ok!
        @assertion_performed = true
      end
  
  =begin
  Assert if a value is a truthy value. All assert methods take an optional final parameter that is the message to display to the user.
  
  @example
  
  def test_does_this_work args, assert
    some_result = Person.new
    assert.true! some_result
    # OR
    assert.true! some_result, "Person was not created."
  end
  =end
      def true! value, message = nil
        @assertion_performed = true
        if !value
          message = "#{value} was not truthy.\n#{message}"
          raise "#{message}"
        end
        nil
      end
  
  =begin
  Assert if a value is a falsey value.
  
  @example
  
  def test_does_this_work args, assert
    some_result = nil
    assert.false! some_result
  end
  =end
      def false! value, message = nil
        @assertion_performed = true
        if value
          message = "#{value} was not falsey.\n#{message}"
          raise message
        end
        nil
      end
  
  =begin
  Assert if two values are equal.
  
  @example
  
  def test_does_this_work args, assert
    a = 1
    b = 1
    assert.equal! a, b
  end
  =end
      def equal! actual, expected, message = nil
        @assertion_performed = true
        if actual != expected
          actual_string = "#{actual}#{actual.nil? ? " (nil) " : " " }".strip
          message = "actual:\n#{actual_string}\n\ndid not equal\n\nexpected:\n#{expected}\n#{message}"
          raise message
        end
        nil
      end
  
      def not_equal! actual, expected, message = nil
        @assertion_performed = true
        if actual == expected
          actual_string = "#{actual}#{actual.nil? ? " (nil) " : " " }".strip
          message = "actual:\n#{actual_string}\n\nequaled\n\nexpected:\n#{expected}\n#{message}"
          raise message
        end
        nil
      end
  
  =begin
  Assert if a value is explicitly nil (not false).
  
  @example
  
  def test_does_this_work args, assert
    a = nil
    b = false
    assert.nil! a # this will pass
    assert.nil! b # this will throw an exception.
  end
  =end
      def nil! value, message = nil
        @assertion_performed = true
        if !value.nil?
          message = "#{value} was supposed to be nil, but wasn't.\n#{message}"
          raise message
        end
        nil
      end
    end
  end

#+end_src

** attr_gtk.rb
#+begin_src ruby
  # ./dragon/attr_gtk.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # attr_gtk.rb has been released under MIT (*only this file*).
  
  module AttrGTK
    def args= value
      @args = value
    end
  
    def args
      @args
    end
  
    def keyboard
      @keyboard ||= @args.inputs.keyboard
    end
  
    def grid
      @grid ||= @args.grid
    end
  
    def state
      @state ||= @args.state
    end
  
    def temp_state
      @temp_state ||= @args.temp_state
    end
  
    def inputs
      @inputs ||= @args.inputs
    end
  
    def outputs
      @outputs ||= @args.outputs
    end
  
    def gtk
      @gtk ||= @args.gtk
    end
  
    def passes
      @passes ||= @args.passes
    end
  
    def pixel_arrays
      @pixel_arrays ||= @args.pixel_arrays
    end
  
    def geometry
      @geometry ||= @args.geometry
    end
  
    def layout
      @layout ||= @args.layout
    end
  
    def easing
      @easing ||= @args.easing
    end
  
    def audio
      @audio ||= @args.audio
    end
  
    def events
      @events ||= @args.events
    end
  
    def cvars
      @cvars ||= @args.cvars
    end
  
    def new_entity entity_type, init_hash = nil, &block
      self.state.new_entity entity_type, init_hash, &block
    end
  
    def new_entity_strict entity_type, init_hash = nil, &block
      self.state.new_entity_strict entity_type, init_hash, &block
    end
  end
  
  class Module
    def attr_gtk
      include AttrGTK
    end
  end
  
  class Object
    def self.attr_gtk
      include AttrGTK
    end
  
    def attr_gtk
      return if self.is_a? AttrGTK
      self.class.include AttrGTK
    end
  end

#+end_src

** attr_label.rb
#+begin_src ruby
  # ./dragon/attr_label.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # attr_line.rb has been released under MIT (*only this file*).
  
  module AttrLabel
    attr_accessor :x, :y, :z,
         :text,
         :size_enum, :alignment_enum,
         :vertical_alignment_enum,
         :r, :g, :b, :a,
         :font,
         :blendmode_enum,
         :anchor_x, :anchor_y, :size_px
  end
  
  
  class Object
    def self.attr_label
      include AttrLabel
    end
  
    def attr_label
      return if self.is_a? AttrLabel
      self.class.include AttrLabel
    end
  end

#+end_src

** attr_line.rb
#+begin_src ruby
  # ./dragon/attr_line.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # attr_line.rb has been released under MIT (*only this file*).
  
  module AttrLine
    attr_accessor :x, :y, :x2, :y2, :w, :h, :r, :g, :b, :a, :blendmode_enum
  
    def primitive_marker
      :line
    end
  
    def line
      self
    end
  
    def x1= value
      @x = value
    end
  
    def x1
      @x
    end
  
    def y1= value
      @y = value
    end
  
    def y1
      @y
    end
  end
  
  class Object
    def self.attr_line
      include AttrLine
    end
  
    def attr_line
      return if self.is_a? AttrLine
      self.class.include AttrLine
    end
  end

#+end_src

** attr_sprite.rb
#+begin_src ruby
  # ./dragon/attr_sprite.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # attr_sprite.rb has been released under MIT (*only this file*).
  
  # @private
  module AttrRect
    include GTK::Geometry
  
    def left
      (@x || self.x)
    end
  
    def right
      (@x || self.x) + (@w || self.w)
    end
  
    def bottom
      (@y || self.y)
    end
  
    def top
      (@y || self.y) + (@h || self.h)
    end
  
    def x1
      (@x || self.x)
    end
  
    def y1
      (@y || self.y)
    end
  end
  
  module AttrSprite
    include AttrRect
  
    attr_accessor :x, :y, :w, :h, :path, :angle, :a, :r, :g, :b, :tile_x,
                  :tile_y, :tile_w, :tile_h, :flip_horizontally,
                  :flip_vertically, :angle_anchor_x, :angle_anchor_y, :id,
                  :angle_x, :angle_y, :z,
                  :source_x, :source_y, :source_w, :source_h, :blendmode_enum,
                  :source_x2, :source_y2, :source_x3, :source_y3, :x2, :y2, :x3, :y3,
                  :anchor_x, :anchor_y
  
    def primitive_marker
      :sprite
    end
  
    def sprite
      self
    end
  
    def x1= value
      @x = value
    end
  
    def y1= value
      @y = value
    end
  end
  
  class Object
    def self.attr_sprite
      include AttrSprite
    end
  
    def attr_sprite
      return if self.is_a? AttrSprite
      self.class.include AttrSprite
    end
  
    def self.attr_rect
      include AttrRect
    end
  
    def attr_rect
      return if self.is_a? AttrRect
      self.class.include AttrRect
    end
  end

#+end_src

** console.rb
#+begin_src ruby
  # ./dragon/console.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # console.rb has been released under MIT (*only this file*).
  
  # Contributors outside of DragonRuby who also hold Copyright:
  # - Kevin Fischer: https://github.com/kfischer-okarin
  # - Eli Raybon: https://github.com/eliraybon
  # - mooff: https://github.com/awfulcooking
  
  module GTK
    class Console
      include ConsoleDeprecated
  
      attr_accessor :show_reason, :log, :logo,
                    :animation_duration,
                    :max_log_lines, :max_history,
                    :last_command_errored, :last_command, :shown_at,
                    :archived_log, :last_log_lines, :last_log_lines_count,
                    :suppress_left_arrow_behavior, :command_set_at,
                    :toast_ids, :bottom,
                    :font_style, :menu,
                    :background_color, :spam_color, :text_color, :warn_color,
                    :error_color, :header_color, :code_color, :comment_color,
                    :debug_color, :unfiltered_color
  
      def initialize
        @font_style = FontStyle.new(font: 'font.ttf', size_enum: -2, line_height: 1.1)
        @menu = Menu.new self
        @disabled = false
        @log_offset = 0
        @visible = false
        @toast_ids = []
        @archived_log = []
        @log = [ 'Console ready.' ]
        @max_log_lines = 1000  # I guess...?
        @max_history = 1000  # I guess...?
        @log_invocation_count = 0
        @command_history = []
        @command_history_index = -1
        @nonhistory_input = ''
        @logo = 'console-logo.png'
        @history_fname = 'logs/console_history.txt'
        @background_color = Color.new [0, 0, 0, 255]
        @header_color = Color.new [94, 170, 248]
        @header_2_color = Color.new [216, 95, 135]
        @header_3_color = Color.new [214, 134, 214]
        @code_color = Color.new [210, 168, 255]
        @comment_color = Color.new [0, 200, 100]
        @animation_duration = 1.seconds
        @shown_at = -1
  
        # these are the colors for text at various log levels.
        @spam_color = Color.new [160, 160, 160]
        @debug_color = Color.new [0, 255, 0]
        @text_color = Color.new [255, 255, 255]
        @warn_color = Color.new [255, 255, 0]
        @error_color = Color.new [255, 80, 80]
        @unfiltered_color = Color.new [0, 255, 255]
        @add_primitive_queue = []
        @clear_logs_request_queue = []
  
        load_history
      end
  
      def console_text_width
        @console_text_width ||= ($gtk.logical_width - 20).idiv(font_style.letter_size.x)
      end
  
      def save_history
        $gtk.ffi_file.write_root @history_fname, (@command_history.reverse.join "\n")
      end
  
      def load_history
        @command_history.clear
        str = $gtk.ffi_file.read @history_fname
        return if str.nil?  # no history to load.
  
        str.chomp!("\n")  # Don't let endlines at the end cause extra blank line.
        str.chomp!("\r")
        str.each_line { |s|
          s.chomp!("\n")
          s.chomp!("\r")
          if s.length > 0
            @command_history.unshift s
            break if @command_history.length >= @max_history
          end
        }
  
        @command_history.uniq!
      end
  
      def disable
        @disabled = true
        @visible = false
      end
  
      def enable
        @disabled = false
      end
  
      def add_sprite obj
        @log_invocation_count += 1
        obj[:id] ||= "id_#{obj[:path]}_#{Time.now.to_i}".to_sym
  
        if @last_line_log_index &&
           @last_sprite_line.is_a?(Hash) &&
           @last_sprite_line[:id] == obj[:id]
  
          @log[@last_line_log_index] = obj
          return
        end
  
        @log << obj
        @last_line_log_index = @log.length - 1
        @last_sprite_line = obj
        nil
      end
  
      def __add_primitive__ obj
        if obj.is_a? Hash
          add_sprite obj
        else
          add_text obj
        end
        nil
      end
  
      def add_primitive obj, global_at: nil
        @add_primitive_queue << {
          global_at: global_at || Kernel.global_tick_count,
          primitive: obj
        }
        nil
      end
  
      def add_text obj, loglevel=-1
        # loglevel is one of the values of LogLevel in logging.h, or -1 to say "we don't care, colorize it with your special string parsing magic"
        loglevel = -1 if loglevel < 0
        loglevel = 5 if loglevel > 5  # 5 == unfiltered (it's 0x7FFFFFFE in C, clamp it down)
        loglevel = 2 if (loglevel == -1) && obj.start_with?('!c!')  # oh well
        colorstr = (loglevel != -1) ? "!c!#{loglevel}" : nil
  
        @last_log_lines_count ||= 1
        @log_invocation_count += 1
  
        str = obj.to_s
  
        log_lines = []
  
        str.each_line do |s|
          if colorstr.nil?
            s.wrapped_lines(self.console_text_width).each do |l|
              log_lines << l
            end
          else
            s.wrapped_lines(self.console_text_width).each do |l|
              log_lines << "#{colorstr}#{l}"
            end
          end
        end
  
        if log_lines == @last_log_lines && log_lines.length != 0
          @last_log_lines_count += 1
          new_log_line_with_count = @last_log_lines.last + " (#{@last_log_lines_count})"
          if log_lines.length > 1
            @log = @log[0..-(@log.length - log_lines.length)] + log_lines[0..-2] + [new_log_line_with_count]
          else
            @log = @log[0..-2] + [new_log_line_with_count]
          end
          return
        end
  
        log_lines.each do |l|
          @log.shift if @log.length > @max_log_lines
          @log << l
        end
  
        @last_log_lines_count = 1
        @last_log_lines = log_lines
        nil
      end
  
      def ready?
        visible? && @toggled_at.elapsed?(@animation_duration, Kernel.global_tick_count)
      end
  
      def hidden?
        !@visible
      end
  
      def visible?
        !!@visible
      end
  
      def open reason = nil
        show reason
      end
  
      def show reason = nil
        @shown_at = Kernel.global_tick_count
        @show_reason = reason
        toggle if hidden?
      end
  
      def hide
        if visible?
          if @cursor_visibilty_before_show == false
            $gtk.hide_cursor
          end
          toggle
          @archived_log += @log
          if @archived_log.length > @max_log_lines
            @archived_log = @archived_log.drop(@archived_log.length - @max_log_lines)
          end
          @log.clear
          @show_reason = nil
          clear_toast
        end
      end
  
      def close
        hide
      end
  
      def clear_toast
        @toasted_at = nil
        @toast_duration = 0
      end
  
      def toggle
        if !@visible
          @cursor_visibilty_before_show = $gtk.cursor_shown?
          $gtk.show_cursor
        else
          if @cursor_visibilty_before_show == false
            $gtk.hide_cursor
          end
        end
        @visible = !@visible
        @toggled_at = Kernel.global_tick_count
      end
  
      def currently_toasting?
        return false if hidden?
        return false unless @show_reason == :toast
        return false unless @toasted_at
        return false if @toasted_at.elapsed?(5.seconds, Kernel.global_tick_count)
        return true
      end
  
      def toast_extended id = nil, duration = nil, *messages
        if !id.is_a?(Symbol)
          raise <<-S
  * ERROR:
  args.gtk.console.toast has the following signature:
  
    def toast id, *messages
    end
  
  The id property uniquely defines the message and must be
  a symbol.
  
  After that, you can provide all the objects you want to
  look at.
  
  Example:
  
    args.gtk.console.toast :say_hello,
                              \"Hello world.\",
                              args.state.tick_count
  
  Toast messages autohide after 5 seconds.
  
  If you need to look at something for longer, use
  args.gtk.console.perma_toast instead (which you can manually dismiss).
  
  S
        end
  
        return if currently_toasting?
        return if @toast_ids.include? id
        @toasted_at = Kernel.global_tick_count
        log_once_info :perma_toast_tip, "Use console.perma_toast to show the toast for longer."
        dwim_duration = 5.seconds
        add_text "* toast :#{id}"
        puts "* TOAST: :#{id}"
        messages.each do |message|
          lines = message.to_s.wrapped_lines(self.console_text_width)
          dwim_duration += lines.length.seconds
          add_text "** #{message}"
          puts "** #{message}"
        end
        show :toast
        @toast_duration += duration || dwim_duration
        @toast_ids << id
        set_command "$gtk.console.hide"
      end
  
      def perma_toast id = nil, messages
        toast_extended id, 600.seconds, *messages
      end
  
      def toast id = nil, *messages
        toast_extended id, nil, *messages
      end
  
      def console_toggle_keys
        [
          :backtick!,
          :tilde!,
          :superscript_two!,
          :section_sign!,
          :ordinal_indicator!,
          :circumflex!,
        ]
      end
  
      def console_toggle_key_down? args
        args.inputs.keyboard.key_down.any? console_toggle_keys
      end
  
      def try_search_docs exception
        string_e = "#{exception}"
        @last_command_errored = true
  
        if (string_e.include? "wrong number of arguments")
          method_name = ((string_e.split ":")[0].gsub "'", "")
          if !(method_name.include? " ")
            results = (Kernel.__docs_search_results__ method_name)
            if !results.include? "* No results found."
              puts (results.join "\n")
              puts <<-S
  * INFO: #{results.length} matches(s) found in DOCS for ~#{method_name}~ (see above).
  You can search the documentation yourself using the following command in the Console:
  #+begin_src ruby
    docs_search \"#{method_name}\"
  #+end_src
  S
              log_once_info :exported_search_results, "The search results above has been seen in logs/puts.txt and docs/search_results.txt."
            end
          end
        end
      rescue Exception => se
        puts <<-S
  * FATAL: ~GTK::Console#try_search_docs~
  There was an exception searching for docs (~GTK::Console#try_search_docs~). You might want to let DragonRuby know about this.
  ** INNER EXCEPTION
  #{se}
  S
      end
  
      def eval_the_set_command
        cmd = current_input_str.strip
        if cmd.length != 0
          @log_offset = 0
          prompt.clear
  
          @command_history.pop while @command_history.length >= @max_history
          @command_history.unshift cmd
          @command_history_index = -1
          @nonhistory_input = ''
  
          if cmd == 'quit' || cmd == ':wq' || cmd == ':q!' || cmd == ':q' || cmd == ':wqa'
            $gtk.request_quit
          elsif (cmd.start_with? "./dragonruby-publish") || (cmd.start_with? ".\\dragonruby-publish") || (cmd.start_with? "dragonruby-publish")
            # TODO: maybe kick off the itch wizard here ~$wizards.itch.start~
            puts "-> #{cmd}"
            puts <<-S
  * INFO:
  It looks like you are trying to publish your game. The dragonruby-publish
  command must be run from your terminal (not the DragonRuby Console).
  S
          elsif cmd.start_with? ':'
            send ((cmd.gsub '-', '_').gsub ':', '')
          else
            puts "-> #{cmd}"
  
            begin
              @last_command = cmd
  
              locals = (@locals ||= {})
  
              results = GTK::ConsoleEvaluator.evaluate cmd
             if results.nil?
                puts "=> nil"
              elsif results == :console_silent_eval
                # do nothing since the console is silent
              else
                if cmd.include?("docs") && (results.is_a? String) && (results.start_with? "* ")
                  puts "=>\n#{results}"
                else
                  puts "=> #{results}"
                end
              end
  
              @last_command_errored = false
            rescue Exception => e
              try_search_docs e
              # if an exception is thrown and the bactrace includes something helpful, then show it
              if (e.backtrace || []).first && (e.backtrace.first.include? "(eval)")
                puts  "* EXCEPTION: #{e}"
              else
                puts  "* EXCEPTION: #{e}\n#{e.__backtrace_to_org__}"
              end
            end
          end
        end
      end
  
      def inputs_scroll_up_full? args
        return false if @disabled
        args.inputs.keyboard.key_down.pageup ||
          (args.inputs.keyboard.key_up.b && args.inputs.keyboard.key_up.control)
      end
  
      def scroll_to_bottom
        @log_offset = 0
      end
  
      def scroll_up_full
        @log_offset += lines_on_one_page
        @log_offset = @log.size if @log_offset > @log.size
      end
  
      def inputs_scroll_up_half? args
        return false if @disabled
        args.inputs.keyboard.ctrl_u
      end
  
      def scroll_up_half
        @log_offset += lines_on_one_page.idiv(2)
        @log_offset = @log.size if @log_offset > @log.size
      end
  
      def inputs_scroll_down_full? args
        return false if @disabled
        args.inputs.keyboard.key_down.pagedown ||
          (args.inputs.keyboard.key_up.f && args.inputs.keyboard.key_up.control)
      end
  
      def scroll_down_full
        @log_offset -= lines_on_one_page
        @log_offset = 0 if @log_offset < 0
      end
  
      def inputs_scroll_down_half? args
        return false if @disabled
        args.inputs.keyboard.ctrl_d
      end
  
      def inputs_clear_command? args
        return false if @disabled
        args.inputs.keyboard.escape || args.inputs.keyboard.ctrl_g
      end
  
      def scroll_down_half
        @log_offset -= lines_on_one_page.idiv(2)
        @log_offset = 0 if @log_offset < 0
      end
  
      def mouse_wheel_scroll args
        @inertia ||= 0
  
        if args.inputs.mouse.wheel
          if args.inputs.mouse.wheel.y > 0
            @inertia = 1
          elsif args.inputs.mouse.wheel.y < 0
            @inertia = -1
          end
        end
  
        if args.inputs.mouse.click
          @inertia = 0
        end
  
        return if @inertia == 0
  
        @inertia = (@inertia * 0.7)
        if @inertia > 0
          @log_offset += 1
        elsif @inertia < 0
          @log_offset -= 1
        end
  
        if @inertia.abs < 0.01
          @inertia = 0
        end
  
        if @log_offset > @log.size
          @log_offset = @log.size
        elsif @log_offset < 0
          @log_offset = 0
        end
      end
  
      def process_inputs args
        if console_toggle_key_down? args
          args.inputs.text.clear
          toggle
          args.inputs.keyboard.clear if !@visible
        end
  
        return unless visible?
  
        args.inputs.text.each { |str| prompt << str }
        args.inputs.text.clear
        mouse_wheel_scroll args
  
        @log_offset = 0 if @log_offset < 0
  
        if args.inputs.keyboard.key_down.enter
          if slide_progress > 0.5
            # in the event of an exception, the console window pops up
            # and is pre-filled with $gtk.reset.
            # there is an annoying scenario where the exception could be thrown
            # by pressing enter (while playing the game). if you press enter again
            # quickly, then the game is reset which closes the console.
            # so enter in the console is only evaluated if the slide_progress
            # is atleast half way down the page.
            eval_the_set_command
          end
        elsif args.inputs.keyboard.key_down.v
          if args.inputs.keyboard.key_down.control || args.inputs.keyboard.key_down.meta
            prompt << $gtk.ffi_misc.getclipboard
          end
        elsif args.inputs.keyboard.key_down.home
          prompt.move_cursor_home
        elsif args.inputs.keyboard.key_down.end
          prompt.move_cursor_end
        elsif args.inputs.keyboard.key_down.up
          if @command_history_index == -1
            @nonhistory_input = current_input_str
          end
          if @command_history_index < (@command_history.length - 1)
            @command_history_index += 1
            self.current_input_str = @command_history[@command_history_index].dup
          end
        elsif args.inputs.keyboard.key_down.down
          if @command_history_index == 0
            @command_history_index = -1
            self.current_input_str = @nonhistory_input
            @nonhistory_input = ''
          elsif @command_history_index > 0
            @command_history_index -= 1
            self.current_input_str = @command_history[@command_history_index].dup
          end
        elsif args.inputs.keyboard.key_down.left
          if args.inputs.keyboard.key_down.control
            prompt.move_cursor_left_word
          else
            prompt.move_cursor_left
          end
        elsif args.inputs.keyboard.key_down.right
          if args.inputs.keyboard.key_down.control
            prompt.move_cursor_right_word
          else
            prompt.move_cursor_right
          end
        elsif inputs_scroll_up_full? args
          scroll_up_full
        elsif inputs_scroll_down_full? args
          scroll_down_full
        elsif inputs_scroll_up_half? args
          scroll_up_half
        elsif inputs_scroll_down_half? args
          scroll_down_half
        elsif inputs_clear_command? args
          prompt.clear
          @command_history_index = -1
          @nonhistory_input = ''
        elsif args.inputs.keyboard.key_down.backspace
          prompt.backspace
        elsif args.inputs.keyboard.key_down.delete
          prompt.delete
        elsif args.inputs.keyboard.key_down.tab
          prompt.autocomplete
        end
  
        args.inputs.keyboard.key_down.clear
        args.inputs.keyboard.key_up.clear
        args.inputs.keyboard.key_held.clear
      end
  
      def write_primitive_and_return_offset(args, left, y, str, archived: false)
        if str.is_a?(Hash)
          padding = 10
          args.outputs.reserved << [left + 10, y + 5, str[:w], str[:h], str[:path]].sprite
          return str[:h] + padding
        else
          write_line args, left, y, str, archived: archived
          return line_height_px
        end
      end
  
      def write_line(args, left, y, str, archived: false)
        color = color_for_log_entry(str)
        color = color.mult_alpha(0.5) if archived
        str = str[4..-1] if str.start_with?('!c!')  # chop off loglevel color
        args.outputs.reserved << font_style.label(x: left.shift_right(10), y: y, text: str, color: color)
      end
  
      def should_tick?
        return false if !@toggled_at
        return false if slide_progress == 0
        return false if @disabled
        return visible?
      end
  
      def logo_final_y
        @logo_final_y = $gtk.args.layout.rect(row: 0, h: 1).center_y
      end
  
      def render args
        return if !@toggled_at
        return if slide_progress == 0
  
        @bottom = top - (h * slide_progress)
        args.outputs.reserved << [left, @bottom, w, h, *@background_color.mult_alpha(slide_progress)].solid
        args.outputs.reserved << { x: 20,
                                   y: @bottom.shift_up(logo_final_y - 44),
                                   w: 100,
                                   h: 100,
                                   path: @logo,
                                   a: (80.0 * slide_progress).to_i }
  
        y = @bottom + 2  # just give us a little padding at the bottom.
        prompt.render args, x: left.shift_right(10), y: y
        y += line_height_px * 1.5
        args.outputs.reserved << line(y: y, color: @text_color.mult_alpha(slide_progress))
        y += line_height_px.to_f / 2.0
  
        ((@log.size - @log_offset) - 1).downto(0) do |idx|
          offset_after_write = write_primitive_and_return_offset args, left, y, @log[idx]
          y += offset_after_write
          break if y > top
        end
  
        # past log separator
        args.outputs.reserved << line(y: y + line_height_px.half, color: @text_color.mult_alpha(0.25 * slide_progress))
  
        y += line_height_px
  
        ((@archived_log.size - @log_offset) - 1).downto(0) do |idx|
          offset_after_write = write_primitive_and_return_offset args, left, y, @archived_log[idx], archived: true
          y += offset_after_write
          break if y > top
        end
  
        render_log_offset args
  
        if @prompt.str_len < 100
          args.outputs.reserved << { x: 10.from_right, y: @bottom + 5,
                                     text: "Press CTRL+g or ESCAPE to clear the prompt.",
                                     vertical_alignment_enum: 0,
                                     alignment_enum: 2, r: 80, g: 80, b: 80 }.label!
        end
      end
  
      def render_log_offset args
        return if @log_offset <= 0
        args.outputs.reserved << font_style.label(
          x: right.shift_left(5),
          y: top.shift_down(5 + line_height_px),
          text: "[#{@log_offset}/#{@log.size}]",
          color: @text_color,
          alignment_enum: 2
        )
      end
  
      def include_error_marker? text
        include_any_words?(text.gsub('OutputsDeprecated', ''), error_markers)
      end
  
      def error_markers
        ["exception:", "error:", "undefined method", "failed", "syntax error", "deprecated"]
      end
  
      def include_subdued_markers? text
        (text.start_with? "* INFO: ") && (include_any_words? text, subdued_markers)
      end
  
      def include_any_words? text, words
        words.any? { |w| text.downcase.include?(w) && !text.downcase.include?(":#{w}") }
      end
  
      def subdued_markers
        ["reloaded", "exported the", "~require~"]
      end
  
      def calc args
        if visible? &&
           @show_reason == :toast &&
           @toasted_at &&
           @toasted_at.elapsed?(@toast_duration, Kernel.global_tick_count)
          hide
        end
  
        if !$gtk.paused? && visible? && (show_reason == :exception || show_reason == :exception_on_load)
          hide
        end
  
        if $gtk.files_reloaded.length > 0
          clear_toast
          @toast_ids.clear
        end
      end
  
      def tick args
        begin
          if @disabled
            if console_toggle_key_down? args
              args.gtk.notify! "Console is currently disabled (this message will not show up in a production build)."
            end
            return
          end
          render args
          process_inputs args
          return unless should_tick?
          calc args
          prompt.tick
          menu.tick args
          process_add_primitive_queue
          process_clear_logs_request_queue
        rescue Exception => e
          begin
            puts "#{e}"
            puts "* FATAL: The GTK::Console console threw an unhandled exception and has been reset. You should report this exception (along with reproduction steps) to DragonRuby."
          rescue
          end
          @disabled = true
          $stdout.puts e
          $stdout.puts "* FATAL: The GTK::Console console threw an unhandled exception and has been reset. You should report this exception (along with reproduction steps) to DragonRuby."
        end
      end
  
      def process_clear_logs_request_queue
        if @clear_logs_request_queue.any? { |entry| entry.global_at <= Kernel.global_tick_count }
          @log.clear
          @archived_log.clear
          @clear_logs_request_queue.reject! { |entry| entry.global_at <= Kernel.global_tick_count }
        end
      end
  
      def process_add_primitive_queue
        @add_primitive_queue.find_all do |entry|
          entry.global_at <= Kernel.global_tick_count
        end.each do |entry|
          __add_primitive__ entry.primitive
        end
  
        @add_primitive_queue.reject! do |entry|
          entry.global_at <= Kernel.global_tick_count
        end
      end
  
      def set_command_with_history_silent command, histories, show_reason = nil
        set_command_extended command: command, histories: histories, show_reason: show_reason
      end
  
      def defaults_set_command_extended
        {
          command: "puts 'Hello World'",
          histories: [],
          show_reason: nil,
          force: false
        }
      end
  
      def set_command_extended opts
        opts = defaults_set_command_extended.merge opts
        @command_history.concat opts[:histories]
        @command_history << opts[:command]  if @command_history[-1] != opts[:command]
        self.current_input_str = opts[:command] if @command_set_at != Kernel.global_tick_count || opts[:force]
        @command_set_at = Kernel.global_tick_count
        @command_history_index = -1
        save_history
      end
  
      def set_command_with_history command, histories, show_reason = nil
        set_command_with_history_silent command, histories, show_reason
        show show_reason
      end
  
      def set_command command, show_reason = nil
        set_command_silent command, show_reason
        show show_reason
      end
  
      def set_command_silent command, show_reason = nil
        set_command_with_history_silent command, [], show_reason
      end
  
      def set_system_command command, show_reason = nil
        if $gtk.platform == "Mac OS X"
          set_command_silent "$gtk.system \"open #{command}\""
        else
          set_command_silent "$gtk.system \"start #{command}\""
        end
      end
  
      def system_command
        if $gtk.platform == "Mac OS X"
          "open"
        else
          "start"
        end
      end
  
      private
  
      def w
        $gtk.logical_width
      end
  
      def h
        $gtk.logical_height
      end
  
      # methods top; left; right
      # Forward to grid
      %i[top left right].each do |method|
        define_method method do
          $gtk.args.grid.send(method)
        end
      end
  
      def line_height_px
        font_style.line_height_px
      end
  
      def lines_on_one_page
        (h - 4).idiv(line_height_px)
      end
  
      def line(y:, color:)
        [left, y, right, y, *color].line
      end
  
      def include_row_marker? log_entry
        log_entry[0] == "|"
      end
  
      def include_header_marker? log_entry
        return false if (log_entry.strip.include? ".rb")
        (log_entry.start_with? "* ")    ||
        (log_entry.start_with? "** ")   ||
        (log_entry.start_with? "*** ")  ||
        (log_entry.start_with? "**** ")
      end
  
      def include_header_1_marker? log_entry
        return false if (log_entry.strip.include? ".rb")
        (log_entry.start_with? "* ")
      end
  
      def include_header_2_marker? log_entry
        return false if (log_entry.strip.include? ".rb")
        (log_entry.start_with? "** ")
      end
  
      def include_header_3_marker? log_entry
        return false if (log_entry.strip.include? ".rb")
        (log_entry.start_with? "*** ")
      end
  
      def code? log_entry
        (just_symbol? log_entry) || (codeblock_marker? log_entry)
      end
  
      def just_symbol? log_entry
        scrubbed = log_entry.gsub("*", "").strip
        (scrubbed.start_with? ":") && (!scrubbed.include? " ") && (!scrubbed.include? "=>")
      end
  
      def code_comment? log_entry
        return true  if log_entry.strip.start_with?("# ")
        return false
      end
  
      def codeblock_marker? log_entry
        return true if log_entry.strip.start_with?("#+begin_src")
        return true if log_entry.strip.start_with?("#+end_src")
        return false
      end
  
      def color_for_plain_text log_entry
        log_entry = log_entry[4..-1] if log_entry.start_with? "!c!"
  
        if code? log_entry
          @code_color
        elsif code_comment? log_entry
          @comment_color
        elsif include_row_marker? log_entry
          @text_color
        elsif include_error_marker? log_entry
          @error_color
        elsif include_subdued_markers? log_entry
          @text_color.mult_alpha(0.5)
        elsif include_header_1_marker? log_entry
          @header_color
        elsif include_header_2_marker? log_entry
          @header_2_color
        elsif include_header_3_marker? log_entry
          @header_3_color
        elsif log_entry.start_with?("====")
          @header_color
        else
          @text_color
        end
      end
  
      def color_for_log_entry(log_entry)
        if log_entry.start_with?('!c!')  # loglevel color specified.
          return case log_entry[3..3].to_i
                 when 0  # spam
                   @spam_color
                 when 1  # debug
                   @debug_color
                 #when 2  # info (caught by the `else` block.)
                 #  @text_color
                 when 3  # warn
                   @warn_color
                 when 4  # error
                   @error_color
                 when 5  # unfiltered
                   @unfiltered_color
                 else
                   color_for_plain_text log_entry
                 end
        end
  
        return color_for_plain_text log_entry
      end
  
      def prompt
        @prompt ||= Prompt.new(font_style: font_style, text_color: @text_color, console_text_width: console_text_width)
      end
  
      def current_input_str
        prompt.current_input_str
      end
  
      def current_input_str=(str)
        prompt.current_input_str = str
      end
  
      def clear
        @archived_log.clear
        @log.clear
        @prompt.clear
        :console_silent_eval
      end
  
      def slide_progress
        return 0 if !@toggled_at
        if visible?
          @slide_progress = @toggled_at.global_ease(@animation_duration, :flip, :quint, :flip)
        else
          @slide_progress = @toggled_at.global_ease(@animation_duration, :flip, :quint)
        end
        @slide_progress
      end
  
      def clear_logs global_at: Kernel.global_tick_count
        @clear_logs_request_queue << { global_at: global_at }
      end
    end
  end

#+end_src

** console_color.rb
#+begin_src ruby
  # ./dragon/console_color.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # console_color.rb has been released under MIT (*only this file*).
  
  # Contributors outside of DragonRuby who also hold Copyright:
  # - Kevin Fischer: https://github.com/kfischer-okarin
  
  module GTK
    class Console
      class Color
        def initialize(color)
          @color = color
          @color << 255 if @color.size == 3
        end
  
        def mult_alpha(alpha_modifier)
          Color.new [@color[0], @color[1], @color[2], (@color[3].to_f * alpha_modifier).to_i]
        end
  
        # Support splat operator
        def to_a
          @color
        end
  
        def to_s
          "GTK::Console::Color #{to_h}"
        end
  
        def to_h
          { r: @color[0], g: @color[1], b: @color[2], a: @color[3] }
        end
      end
    end
  end

#+end_src

** console_evaluator.rb
#+begin_src ruby
  # ./dragon/console_evaluator.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # console_evaluator.rb has been released under MIT (*only this file*).
  
  module GTK
    class ConsoleEvaluator
      class << self
        def search words = nil, &block
          Kernel.docs_search words, &block
        end
  
        def wizards
          $wizards
        end
  
        def locals
          @locals ||= {}
        end
  
        def args
          $args
        end
  
        def gtk
          $gtk
        end
  
        def state
          $state
        end
  
        def docs
          Kernel.docs
        end
  
        def docs_search words = nil, &block
          Kernel.docs_search words, &block
        end
  
        def export_docs!
          Kernel.export_docs!
        end
  
        def evaluate cmd
          code   = <<-S
  #{
    locals.keys.map do |name|
      "#{name} = locals[:#{name}]"
    end.join "\n"
  }
  
  locals[:args] ||= $args
  locals[:gtk]  ||= $gtk
  
  begin
    _ = begin
      #{cmd}
    end
  ensure
    local_variables.each do |name|
      locals[name] = eval(name.to_s)
    end
  end
  S
  
          GTK::ConsoleEvaluator.instance_eval code
        end
      end
    end
  end

#+end_src

** console_font_style.rb
#+begin_src ruby
  # ./dragon/console_font_style.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # console_font_style.rb has been released under MIT (*only this file*).
  
  # Contributors outside of DragonRuby who also hold Copyright:
  # - Kevin Fischer: https://github.com/kfischer-okarin
  
  module GTK
    class Console
      class FontStyle
        attr_reader :font, :size_enum, :line_height
  
        def initialize(font:, size_enum:, line_height:)
          @font = font
          @size_enum = size_enum
          @line_height = line_height
        end
  
        def letter_size
          @letter_size ||= $gtk.calcstringbox 'W', size_enum, font
        end
  
        def line_height_px
          @line_height_px ||= letter_size.y * line_height
        end
  
        def label(x:, y:, text:, color:, alignment_enum: 0)
          {
            x: x,
            y: y.shift_up(line_height_px),  # !!! FIXME: remove .shift_up(line_height_px) when we fix coordinate origin on labels.
            text: text,
            font: font,
            size_enum: size_enum,
            alignment_enum: alignment_enum,
            **color.to_h,
          }.label!
        end
      end
    end
  end

#+end_src

** console_menu.rb
#+begin_src ruby
  # ./dragon/console_menu.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # console_menu.rb has been released under MIT (*only this file*).
  
  module GTK
    class Console
      class Menu
        attr_accessor :buttons
  
        def initialize console
          @console = console
        end
  
        def record_clicked
          $recording.start 100
        end
  
        def replay_clicked
          $replay.start 'replay.txt', speed: 1
        end
  
        def reset_clicked
          $gtk.reset
        end
  
        def scroll_up_clicked
          @console.scroll_up_half
        end
  
        def scroll_down_clicked
          @console.scroll_down_half
        end
  
        def show_menu_clicked
          @menu_shown = :visible
        end
  
        def close_clicked
          @menu_shown = :hidden
          @console.hide
        end
  
        def hide_menu_clicked
          @menu_shown = :hidden
        end
  
        def framerate_diagnostics_clicked
          @console.scroll_to_bottom
          $gtk.framerate_diagnostics
        end
  
        def itch_wizard_clicked
          @console.scroll_to_bottom
          $wizards.itch.restart
        end
  
        def docs_clicked
          @console.scroll_to_bottom
          log Kernel.docs_classes
        end
  
        def scroll_end_clicked
          @console.scroll_to_bottom
        end
  
        def custom_buttons
          []
        end
  
        def tick args
          return unless @console.visible?
  
          @menu_shown ||= :hidden
  
          col_max_index = $gtk.args.layout.col_max_index
  
          if $gtk.production
            @buttons = [
              (button id: :replay,      row: 0, col: col_max_index - 1, text: "start replay",          method: :replay_clicked),
              (button id: :record,      row: 0, col: col_max_index - 3, text: "record gameplay",       method: :record_clicked),
              (button id: :close,       row: 0, col: col_max_index - 5, text: "close console",         method: :close_clicked),
              *custom_buttons
            ]
          elsif @menu_shown == :hidden
            @buttons = [
              (button id: :show_menu,       row: 0, col: col_max_index - 1, text: "show menu", method: :show_menu_clicked),
            ]
          else
            @buttons = [
              (button id: :scroll_up,   row: 0, col: col_max_index - 9, text: "scroll up",             method: :scroll_up_clicked),
              (button id: :scroll_down, row: 0, col: col_max_index - 7, text: "scroll down",           method: :scroll_down_clicked),
              (button id: :scroll_down, row: 0, col: col_max_index - 5, text: "scroll end",            method: :scroll_end_clicked),
              (button id: :close,       row: 0, col: col_max_index - 3, text: "close console",         method: :close_clicked),
              (button id: :hide,        row: 0, col: col_max_index - 1, text: "hide menu",             method: :hide_menu_clicked),
  
              (button id: :record,      row: 1, col: col_max_index - 7, text: "record gameplay",       method: :record_clicked),
              (button id: :replay,      row: 1, col: col_max_index - 5, text: "start replay",          method: :replay_clicked),
              (button id: :record,      row: 1, col: col_max_index - 3, text: "framerate diagnostics", method: :framerate_diagnostics_clicked),
              (button id: :reset,       row: 1, col: col_max_index - 1, text: "reset game",            method: :reset_clicked),
  
              (button id: :reset,       row: 2, col: col_max_index - 1, text: "docs",                  method: :docs_clicked),
              (button id: :reset,       row: 2, col: col_max_index - 3, text: "itch wizard",           method: :itch_wizard_clicked),
              *custom_buttons
            ]
          end
  
          # render
          args.outputs.reserved << @buttons.map { |b| b[:primitives] }
  
          # inputs
          if args.inputs.mouse.click
            clicked = @buttons.find { |b| args.inputs.mouse.inside_rect? b[:rect] }
            if clicked
              args.inputs.mouse.click = nil
              send clicked[:method]
            end
          end
        end
  
        def rect_for_layout row, col
          $gtk.args.layout.rect(row: row, col: col, w: 2, h: 1)
        end
  
        def button args
          id, row, col, text, method = args[:id], args[:row], args[:col], args[:text], args[:method]
  
          font_height = @console.font_style.line_height_px.half
          {
            id: id,
            rect: (rect_for_layout row, col),
            text: text,
            method: method
          }.let do |entity|
            primitives = []
            primitives << entity[:rect].solid!(a: 164)
            primitives << entity[:rect].border!(r: 255, g: 255, b: 255)
            primitives << text.wrapped_lines(5)
                              .map_with_index do |l, i|
                                [
                                  entity[:rect][:x] + entity[:rect][:w].half,
                                  entity[:rect][:y] + entity[:rect][:h].half + font_height - (i * (font_height + 2)),
                                  l, -3, 1, 255, 255, 255
                                ]
                              end.labels
  
            entity.merge(primitives: primitives)
          end
        end
  
        def serialize
          {
            not_supported: "#{self}"
          }
        end
      end
    end
  end

#+end_src

** console_prompt.rb
#+begin_src ruby
  # ./dragon/console_prompt.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # console_prompt.rb has been released under MIT (*only this file*).
  
  # Contributors outside of DragonRuby who also hold Copyright:
  # - Kevin Fischer: https://github.com/kfischer-okarin
  
  module GTK
    class Console
      class Prompt
        # ? Can be changed, it was just taken from my editor settings :>
        WORD_LIMITER_CHARS = "`~!@#$%^&*-=+()[]{}\|;:'\",.<>/?_ \t\n\0".chars
  
        attr_accessor :current_input_str, :font_style, :console_text_width, :last_input_str, :last_input_str_changed
  
        def initialize(font_style:, text_color:, console_text_width:)
          @prompt = '-> '
          @current_input_str = ''
          @font_style = font_style
          @text_color = text_color
          @cursor_color = Color.new [187, 21, 6]
          @console_text_width = console_text_width
  
          @cursor_position = 0
          update_cursor_position_px
  
          @last_autocomplete_prefix = nil
          @next_candidate_index = 0
        end
  
        def update_cursor_position_px
          @cursor_position_px = ($gtk.calcstringbox (@prompt + @current_input_str[0...@cursor_position]), @font_style.size_enum, @font_style.font).x
        end
  
        def current_input_str=(str)
          @current_input_str = str
          @cursor_position = str.length
          update_cursor_position_px
        end
  
        def <<(str)
          @current_input_str = @current_input_str[0...@cursor_position] + str + @current_input_str[@cursor_position..-1]
          @cursor_position += str.length
          update_cursor_position_px
          @current_input_changed_at = Kernel.global_tick_count
          reset_autocomplete
        end
  
        def backspace
          return if current_input_str.length.zero? || @cursor_position.zero?
  
          @current_input_str = @current_input_str[0...(@cursor_position - 1)] + @current_input_str[@cursor_position..-1]
          @cursor_position -= 1
          update_cursor_position_px
          reset_autocomplete
        end
  
        def delete
          return if current_input_str.length.zero? || @cursor_position == current_input_str.length
  
          @cursor_position += 1
          backspace
        end
  
        def move_cursor_left
          @cursor_position -= 1 if @cursor_position > 0
          update_cursor_position_px
        end
  
        def move_cursor_left_word
          return if @cursor_position.zero?
  
          new_pos = @cursor_position - 1
          (is_word_boundary? @current_input_str[new_pos]) ?
              (new_pos -= 1 until !(is_word_boundary? @current_input_str[new_pos - 1]) || new_pos.zero?):
              (new_pos -= 1 until (is_word_boundary? @current_input_str[new_pos - 1]) || new_pos.zero?)
  
          @cursor_position = new_pos
          update_cursor_position_px
        end
  
        def move_cursor_right
          @cursor_position += 1 if @cursor_position < current_input_str.length
          update_cursor_position_px
        end
  
        def move_cursor_right_word
          return if @cursor_position.equal? str_len
  
          new_pos = @cursor_position + 1
          (is_word_boundary? @current_input_str[new_pos]) ?
              (new_pos += 1 until !(is_word_boundary? @current_input_str[new_pos]) || (new_pos.equal? str_len)):
              (new_pos += 1 until (is_word_boundary? @current_input_str[new_pos]) || (new_pos.equal? str_len))
  
          @cursor_position = new_pos
          update_cursor_position_px
        end
  
        def move_cursor_home
          @cursor_position = 0
          update_cursor_position_px
        end
  
        def move_cursor_end
          @cursor_position = str_len
          update_cursor_position_px
        end
  
        def clear
          @current_input_str = ''
          @cursor_position = 0
          update_cursor_position_px
          reset_autocomplete
        end
  
        def autocomplete
          if !@last_autocomplete_prefix
            @last_autocomplete_prefix = calc_autocomplete_prefix
  
            puts "* AUTOCOMPLETE CANDIDATES: #{current_input_str}.."
            pretty_print_strings_as_table method_candidates(@last_autocomplete_prefix)
          else
            candidates = method_candidates(@last_autocomplete_prefix)
            return if candidates.empty?
  
            candidate = candidates[@next_candidate_index]
            candidate = candidate[0..-2] + " = " if candidate.end_with? '='
            @next_candidate_index += 1
            @next_candidate_index = 0 if @next_candidate_index >= candidates.length
            self.current_input_str = display_autocomplete_candidate(candidate)
            update_cursor_position_px
          end
        rescue Exception => e
          puts "* BUG: Tab autocompletion failed. Let us know about this.\n#{e}"
        end
  
        def pretty_print_strings_as_table items
          if items.length == 0
            puts <<-S.strip
  +--------+
  | (none) |
  +--------+
  S
          else
            # figure out the largest string
            string_width = items.sort_by { |c| -c.to_s.length }.first
  
            # add spacing to each side of the string which represents the cell width
            cell_width = string_width.length + 2
  
            # add spacing to each side of the cell to represent the column width
            column_width = cell_width + 2
  
            # determine the max number of columns that can fit on the screen
            columns = @console_text_width.idiv column_width
            columns = items.length if items.length < columns
  
            # partition the original list of items into a string to be printed
            items.each_slice(columns).each_with_index do |cells, i|
              pretty_print_row_separator string_width, cell_width, column_width, columns
              pretty_print_row cells, string_width, cell_width, column_width, columns
            end
  
            pretty_print_row_separator string_width, cell_width, column_width, columns
          end
        end
  
        def pretty_print_row cells, string_width, cell_width, column_width, columns
          # if the number of cells doesn't match the number of columns, then pad the array with empty values
          cells += (columns - cells.length).map { "" }
  
          # right align each cell value
          formated_row = "|" + cells.map do |c|
            "#{" " * (string_width.length - c.length) } #{c} |"
          end.join
  
          # remove separators between empty values
          formated_row = formated_row.gsub("  |  ", "     ")
  
          puts formated_row
        end
  
        def pretty_print_row_separator string_width, cell_width, column_width, columns
          # this is a joint: +--------
          column_joint = "+#{"-" * cell_width}"
  
          # multiple joints create a row separator: +----+----+
          puts (column_joint * columns) + "+"
        end
  
        def render(args, x:, y:)
          args.outputs.reserved << font_style.label(x: x, y: y, text: "#{@prompt}#{current_input_str}", color: @text_color)
          args.outputs.reserved << (@cursor_color.to_h.merge x: x + @cursor_position_px + 0.5,
                                                             y: y + 5,
                                                             x2: x + @cursor_position_px + 0.5,
                                                             y2: y + @font_style.letter_size.y + 4)
  
          args.outputs.reserved << (@cursor_color.to_h.merge x: x + @cursor_position_px + 1,
                                                             y: y + 5,
                                                             x2: x + @cursor_position_px + 1,
                                                             y2: y + @font_style.letter_size.y + 4)
  
          # debugging rectangle for string
          # args.outputs.reserved << (@cursor_color.to_h.merge x: x,
          #                                                    y: y + 5,
          #                                                    w: @cursor_position_px,
          #                                                    h: @font_style.letter_size.y).border
        end
  
        def tick
          if (@current_input_changed_at) &&
             (@current_input_changed_at < Kernel.global_tick_count) &&
             (@last_input_str != @current_input_str)
            @last_input_str_changed = true
            @last_input_str = "#{@current_input_str}"
            @current_input_changed_at = nil
          else
            @last_input_str_changed = false
          end
        end
  
        private
  
        def last_period_index
          current_input_str.rindex('.')
        end
  
        def calc_autocomplete_prefix
          if last_period_index
            current_input_str[(last_period_index + 1)..-1]
          else
            current_input_str
          end
        end
  
        def current_object
          return ConsoleEvaluator unless last_period_index
  
          ConsoleEvaluator.eval(current_input_str[0...last_period_index])
        rescue NameError
          nil
        end
  
        def method_candidates(prefix)
          current_object.autocomplete_methods.map(&:to_s).select { |m| m.start_with? prefix }
        end
  
        def display_autocomplete_candidate(candidate)
          if last_period_index
            @current_input_str[0..last_period_index] + candidate.to_s
          else
            candidate.to_s
          end
        end
  
        def reset_autocomplete
          @last_autocomplete_prefix = nil
          @next_candidate_index = 0
        end
  
        def is_word_boundary? char
          # Alternative method
          # (WORD_LIMITER_CHARS - [char]).length != WORD_LIMITER_CHARS.length
          # Production code
          WORD_LIMITER_CHARS.include? char
        end
  
        def str_len
          @current_input_str.length
        end
      end
    end
  end

#+end_src

** controller.rb
#+begin_src ruby
  # ./dragon/controller.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # controller.rb has been released under MIT (*only this file*).
  
  module GTK
    class Controller
      attr :key_down
      attr :key_up
      attr :key_held
  
      attr :left_analog_x_raw,
           :left_analog_y_raw,
           :left_analog_x_perc,
           :left_analog_y_perc,
           :right_analog_x_raw,
           :right_analog_y_raw,
           :right_analog_x_perc,
           :right_analog_y_perc,
           :active
  
      attr :connected
  
      def initialize
        @key_down = Controller::Keys.new
        @key_up   = Controller::Keys.new
        @key_held = Controller::Keys.new
        @left_analog_x_raw = 0
        @left_analog_y_raw = 0
        @left_analog_x_perc = 0
        @left_analog_y_perc = 0
        @right_analog_x_raw = 0
        @right_analog_y_raw = 0
        @right_analog_x_perc = 0
        @right_analog_y_perc = 0
        @connected = false
      end
  
      def serialize
        {
          key_down: @key_down.serialize,
          key_held: @key_held.serialize,
          key_up:   @key_up.serialize
        }
      end
  
      # Clear all current key presses.
      #
      # @return [void]
      def clear
        @key_down.clear
        @key_up.clear
        @key_held.clear
        @active = nil
      end
  
      def up
        @key_up.up || @key_held.up
      end
  
      def down
        @key_up.down || @key_held.down
      end
  
      def left
        @key_up.left || @key_held.left
      end
  
      def right
        @key_up.right || @key_held.right
      end
  
      # Activates a key into the down position.
      #
      # @param key [Symbol] The key to press down.
      #
      # @return [void]
      def activate_down(key)
        key_down.activate(key)
        key_held.deactivate(key)
        key_up.deactivate(key)
      end
  
      # Activates a key into the held down position.
      #
      # @param key [Symbol] The key to hold down.
      #
      # @return [void]
      def activate_held(key)
        key_down.deactivate(key)
        key_held.activate(key) unless key_held.send(key)
        key_up.deactivate(key)
      end
  
  
      # Activates a key release into the up position.
      #
      # @param key [Symbol] The key release up.
      #
      # @return [void]
      def activate_up(key)
        key_down.deactivate(key)
        key_held.deactivate(key)
        key_up.activate(key)
      end
  
      include DirectionalInputHelperMethods
    end
  end

#+end_src

** controller/config.rb
#+begin_src ruby
  # ./dragon/controller/config.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # controller/config.rb has been released under MIT (*only this file*).
  
  # !!! FIXME: add console command to forget custom binding(s)
  # !!! FIXME: add console command to forget replace existing binding(s)
  # !!! FIXME: add console command go into play_around mode to make sure controller isn't wonky.
  
  module GTK
    class Controller
      class Config
        attr :disabled
  
        def initialize runtime
          @runtime = runtime
          @raw_joysticks = {}   # things that aren't game controllers to try to configure.
          @target = nil
          @animation_duration = (1.5).seconds
          @toggled_at = 0
          @fading = 0
          @current_part = 0
          @part_alpha = 0
          @part_alpha_increment = 10
          @joystick_state = {}
          @playing_around = false
          @used_bindings = {}
          @bindings = []
          @disabled = false
          @parts = [
            [ 919, 282, 'A button', 'a' ],
            [ 960, 323, 'B button', 'b' ],
            [ 878, 323, 'X button', 'x' ],
            [ 919, 365, 'Y button', 'y' ],
            [ 433, 246, 'left stick left', '-leftx' ],
            [ 497, 246, 'left stick right', '+leftx' ],
            [ 466, 283, 'left stick up', '-lefty' ],
            [ 466, 218, 'left stick down', '+lefty' ],
            [ 466, 246, 'left stick button', 'leftstick' ],
            [ 741, 246, 'right stick left', '-rightx' ],
            [ 802, 246, 'right stick right', '+rightx' ],
            [ 773, 283, 'right stick up', '-righty' ],
            [ 773, 218, 'right stick down', '+righty' ],
            [ 772, 246, 'right stick button', 'rightstick' ],
            [ 263, 465, 'left shoulder button', 'leftshoulder' ],
            [ 263, 503, 'left trigger', 'lefttrigger' ],
            [ 977, 465, 'right shoulder button', 'rightshoulder' ],
            [ 977, 503, 'right trigger', 'righttrigger' ],
            [ 318, 365, 'D-pad up', 'dpup' ],
            [ 360, 322, 'D-pad right', 'dpright' ],
            [ 318, 280, 'D-pad down', 'dpdown' ],
            [ 275, 322, 'D-pad left', 'dpleft' ],
            [ 570, 402, 'select/back button', 'back'],
            [ 619, 448, 'guide/home button', 'guide' ],
            [ 669, 402, 'start button', 'start' ],
          ]
        end
  
        def rawjoystick_connected jid, joystickname, guid
          return if jid < 0
          @raw_joysticks[jid] = { name: joystickname, guid: guid }
        end
  
        def rawjoystick_disconnected jid
          return if jid < 0
          if @raw_joysticks[jid] != nil
            @raw_joysticks.delete(jid)
            @runtime.ffi_misc.close_raw_joystick(jid)
            # Fade out the config screen if we were literally configuring this controller right now.
            if !@target.nil? && @target[0] == jid
              @target[0] = nil
              @toggled_at = Kernel.global_tick_count
              @fading = -1
            end
          end
        end
  
        def build_binding_string
          bindingstr = ''
          skip = false
  
          for i in 0..@parts.length-1
            if skip ; skip = false ; next ; end
  
            binding = @bindings[i]
            next if binding.nil?
  
            part = @parts[i][3]
  
            # clean up string:
            #  if axis uses -a0 for negative and +a0 for positive, just make it "leftx:a0" instead of "-leftx:-a0,+leftx:+a0"
            #  if axis uses +a0 for negative and -a0 for positive, just make it "leftx:a0~" instead of "-leftx:+a0,+leftx:-a0"
            if part == '-leftx' || part == '-lefty' || part == '-rightx' || part == '-righty'
              nextbinding = @bindings[i+1]
              if binding.start_with?('-a') && nextbinding.start_with?('+a') && binding[2..-1] == nextbinding[2..-1]
                skip = true
                part = part[1..-1]
                binding = binding[1..-1]
              elsif binding.start_with?('+a') && nextbinding.start_with?('-a') && binding[2..-1] == nextbinding[2..-1]
                skip = true
                part = part[1..-1]
                binding = "#{binding[1..-1]}~"
              end
            end
  
            bindingstr += "#{!bindingstr.empty? ? ',' : ''}#{part}:#{binding}"
          end
  
          details = @target[1]
  
          # !!! FIXME: no String.delete in mRuby?!?! Maybe so when upgrading.
          #name = details[:name].delete(',')
          # !!! FIXME: ...no regexp either...  :/
          #name = details[:name].gsub(/,/, ' ')  # !!! FIXME: will SDL let you escape these instead?
          unescaped = details[:name]
          name = ''
          for i in 0..unescaped.length-1
            ch = unescaped[i]
            name += (ch == ',') ? ' ' : ch
          end
          return "#{details[:guid]},#{name},platform:#{@runtime.platform},#{bindingstr}"
        end
  
        def move_to_different_part part
          if !@joystick_state[:axes].nil?
            @joystick_state[:axes].each { |i| i[:farthestval] = i[:startingval] if !i.nil? }
          end
          @current_part = part
        end
  
        def previous_part
          if @current_part > 0
            # remove the binding that we previous had here so it can be reused.
            bindstr = @bindings[@current_part - 1]
            @bindings[@current_part - 1] = nil
            @used_bindings[bindstr] = nil
            move_to_different_part @current_part - 1
          end
        end
  
        def next_part
          if @current_part < (@parts.length - 1)
            move_to_different_part @current_part + 1
          else
            @playing_around = true
          end
        end
  
        def set_binding bindstr
          return false if !@used_bindings[bindstr].nil?
          @used_bindings[bindstr] = @current_part
          @bindings[@current_part] = bindstr
          return true
        end
  
        # Called when a lowlevel joystick moves an axis.
        def rawjoystick_axis jid, axis, value
          return if @target.nil? || jid != @target[0] || @fading != 0 # skip if not currently considering this joystick.
  
          @joystick_state[:axes] ||= []
          @joystick_state[:axes][axis] ||= {
            moving: false,
            startingval: 0,
            currentval: 0,
            farthestval: 0
          }
  
          # this is the logic from SDL's controllermap.c, more or less, since this is hard to get right from scratch.
          state = @joystick_state[:axes][axis]
          state[:currentval] = value
          if !state[:moving]
            state[:moving] = true
            state[:startingval] = value
            state[:farthestval] = value
          end
  
          current_distance = (value - state[:startingval]).abs
          farthest_distance = (state[:farthestval] - state[:startingval]).abs
          if current_distance > farthest_distance
            state[:farthestval] = value
            farthest_distance = (state[:farthestval] - state[:startingval]).abs
          end
  
          # If we've gone out far enough and started to come back, let's bind this axis
          if (farthest_distance >= 16000) && (current_distance <= 10000)
            next_part if set_binding("#{(state[:farthestval] < 0) ? '-' : '+'}a#{axis}")
          end
        end
  
        # Called when a lowlevel joystick moves a hat.
        def rawjoystick_hat jid, hat, value
          return if @target.nil? || jid != @target[0] || @fading != 0 # skip if not currently considering this joystick.
  
          @joystick_state[:hats] ||= []
          @joystick_state[:hats][hat] = value
  
          return if value == 0   # 0 == centered, skip it
          next_part if set_binding("h#{hat}.#{value}")
        end
  
        # Called when a lowlevel joystick moves a button.
        def rawjoystick_button jid, button, pressed
          return if @target.nil? || jid != @target[0] || @fading != 0 # skip if not currently considering this joystick.
  
          @joystick_state[:buttons] ||= []
          @joystick_state[:buttons][button] = pressed
  
          return if !pressed
          next_part if set_binding("b#{button}")
        end
  
        def calc_fading
          if @fading == 0
            return 255
          elsif @fading > 0   # fading in
            percent = @toggled_at.global_ease(@animation_duration, :flip, :quint, :flip)
            if percent >= 1.0
              percent = 1.0
              @fading = 0
            end
          else  # fading out
            percent = @toggled_at.global_ease(@animation_duration, :flip, :quint)
            if percent <= 0.0
              percent = 0.0
              @fading = 0
            end
          end
  
          return (percent * 255.0).to_i
        end
  
        def render_basics args, msg, fade=255
          joystickname = @target[1][:name]
          args.outputs.primitives << [0, 0, $gtk.logical_width, $gtk.logical_height, 255, 255, 255, fade].solid
          args.outputs.primitives << [0, 0, $gtk.logical_width, $gtk.logical_height, 'dragonruby-controller.png', 0, fade, 255, 255, 255].sprite
          args.outputs.primitives << [$gtk.logical_width / 2, 700, joystickname, 2, 1, 0, 0, 0, fade].label
          args.outputs.primitives << [$gtk.logical_height / 2, 650, msg, 0, 1, 0, 0, 0, 255].label if !msg.empty?
        end
  
        def render_part_highlight args, part, alpha=255
          partsize = 41
          args.outputs.primitives << [part[0], part[1], partsize, partsize, 255, 0, 0, alpha].border
          args.outputs.primitives << [part[0]-1, part[1]-1, partsize+2, partsize+2, 255, 0, 0, alpha].border
          args.outputs.primitives << [part[0]-2, part[1]-2, partsize+4, partsize+4, 255, 0, 0, alpha].border
        end
  
        def choose_target
          if @target.nil?
            while !@raw_joysticks.empty?
              t = @raw_joysticks.shift  # see if there's a joystick waiting on us.
              next if t[0] < 0  # just in case.
              next if t[1][:guid].nil?  # did we already handle this guid? Dump it.
              @target = t
              break
            end
            return false if @target.nil?   # nothing to configure at the moment.
            @toggled_at = Kernel.global_tick_count
            @fading = 1
            @current_part = 0
            @part_alpha = 0
            @part_alpha_increment = 10
            @joystick_state = {}
            @used_bindings = {}
            @playing_around = false
            @bindings = []
          end
          return true
        end
  
        def render_part_highlight_from_bindstr args, bindstr, alpha=255
          partidx = @used_bindings[bindstr]
          return if partidx.nil?
          render_part_highlight args, @parts[partidx], alpha
        end
  
        def play_around args
          return false if !@playing_around
  
          if args.inputs.keyboard.key_down.escape
            @current_part = 0
            @part_alpha = 0
            @part_alpha_increment = 10
            @used_bindings = {}
            @playing_around = false
            @bindings = []
          elsif args.inputs.keyboard.key_down.space
            jid = @target[0]
            bindingstr = build_binding_string
            #puts("new controller binding: '#{bindingstr}'")
            @runtime.ffi_misc.add_controller_config bindingstr
            @runtime.ffi_misc.convert_rawjoystick_to_controller jid
            @target[0] = -1  # Conversion closes the raw joystick.
  
            # Handle any other pending joysticks that have the same GUID (so if you plug in four of the same model, we're already done!)
            guid = @target[1][:guid]
            @raw_joysticks.each { |jid, details|
              if details[:guid] == guid
                @runtime.ffi_misc.convert_rawjoystick_to_controller jid
                details[:guid] = nil
              end
            }
  
            # Done with this guy.
            @playing_around = false
            @toggled_at = Kernel.global_tick_count
            @fading = -1
            return false
          end
  
          render_basics args, 'Now play around with the controller, and make sure it feels right!'
          args.outputs.primitives << [$gtk.logical_width / 2, 90, '[ESCAPE]: Reconfigure, [SPACE]: Save this configuration', 0, 1, 0, 0, 0, 255].label
  
          axes = @joystick_state[:axes]
          if !axes.nil?
            for i in 0..axes.length-1
              next if axes[i].nil?
              value = axes[i][:currentval]
              next if value.nil? || (value.abs < 16000)
              render_part_highlight_from_bindstr args, "#{value < 0 ? '-' : '+'}a#{i}"
            end
          end
  
          hats = @joystick_state[:hats]
          if !hats.nil?
            for i in 0..hats.length-1
              value = hats[i]
              next if value.nil? || (value == 0)
              render_part_highlight_from_bindstr args, "h#{i}.#{value}"
            end
          end
  
          buttons = @joystick_state[:buttons]
          if !buttons.nil?
            for i in 0..buttons.length-1
              value = buttons[i]
              next if value.nil? || !value
              render_part_highlight_from_bindstr args, "b#{i}"
            end
          end
  
          return true
        end
  
        def should_tick?
          return true if @play_around
          return true if @target
          return false
        end
  
        def tick args
          return false if @disabled
          return true if play_around args
          return false if !choose_target
  
          jid = @target[0]
  
          if @fading == 0
            # Cancel config?
            if args.inputs.keyboard.key_down.escape
              # !!! FIXME: prompt to ignore this joystick forever or just this run
              @toggled_at = Kernel.global_tick_count
              @fading = -1
            end
          end
  
          if @fading == 0
            if args.inputs.keyboard.key_down.backspace
              previous_part
            elsif args.inputs.keyboard.key_down.space
              next_part
            end
          end
  
          fade = calc_fading
          if (@fading < 0) && (fade == 0)
            @runtime.ffi_misc.close_raw_joystick(jid) if jid >= 0
            @target = nil   # done with this controller
            return false
          end
  
          render_basics args, (@fading >= 0) ? "We don't recognize this controller, so tell us about it!" : '', fade
  
          return true if fade < 255  # all done for now
  
          part = @parts[@current_part]
          args.outputs.primitives << [$gtk.logical_width / 2, 575, "Please press the #{part[2]}.", 0, 1, 0, 0, 0, 255].label
          render_part_highlight args, part, @part_alpha
          args.outputs.primitives << [$gtk.logical_width / 2, 90, '[ESCAPE]: Ignore controller, [BACKSPACE]: Go back one button, [SPACE]: Skip this button', 0, 1, 0, 0, 0, 255].label
  
          @part_alpha += @part_alpha_increment
          if (@part_alpha_increment > 0) && (@part_alpha >= 255)
            @part_alpha = 255
            @part_alpha_increment = -10
          elsif (@part_alpha_increment < 0) && (@part_alpha <= 0)
            @part_alpha = 0
            @part_alpha_increment = 10
          end
  
          return true
        end
      end
    end
  end

#+end_src

** controller/keys.rb
#+begin_src ruby
  # ./dragon/controller/keys.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # controller/keys.rb has been released under MIT (*only this file*).
  
  module GTK
    class Controller
      def left_hand
        @left_hand  ||= {
          position: { x: 0, y: 0, z: 0 },
          orientation: { x: 0, y: 0, z: 0 }
        }
      end
  
      def right_hand
        @right_hand ||= {
          position: { x: 0, y: 0, z: 0 },
          orientation: { x: 0, y: 0, z: 0 }
        }
      end
  
      class Keys
        include Serialize
  
        LABELS = [
          :up, :down, :left, :right,
          :a, :b, :x, :y,
          :l1, :r1,
          :l2, :r2,
          :l3, :r3,
          :start, :select, :home,
          :directional_up, :directional_down, :directional_left, :directional_right
        ].freeze
  
        LABELS.each do |label|
          attr label
        end
  
        def back
          @select
        end
  
        def back= value
          @select = value
        end
  
        def guide
          @home
        end
  
        def guide= value
          @home = value
        end
  
        # Activate a key.
        #
        # @return [void]
        def activate key
          instance_variable_set("@#{key}", Kernel.tick_count + 1)
        end
  
        # Deactivate a key.
        #
        # @return [void]
        def deactivate key
          instance_variable_set("@#{key}", nil)
        end
  
        # Clear all key inputs.
        #
        # @return [void]
        def clear
          LABELS.each { |label| deactivate(label) }
        end
  
        def truthy_keys
          LABELS.select { |label| send(label) }
        end
      end
    end
  end

#+end_src

** directional_input_helper_methods.rb
#+begin_src ruby
  # ./dragon/directional_input_helper_methods.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # directional_input_helper_methods.rb has been released under MIT (*only this file*).
  
  module GTK
    # This is a module that contains normalization of behavior related to `up`|`down`|`left`|`right` on keyboards and controllers.
    module DirectionalInputHelperMethods
      def self.included klass
        key_state_methods = [:key_held, :key_down]
        directional_methods = [:up, :down, :left, :right]
        method_results = (directional_methods + key_state_methods).map {|m| [m, klass.instance_methods.include?(m)] }
  
        error_message = <<-S
  * ERROR
  The GTK::DirectionalKeys module should only be included in objects that respond to the following api hierarchy:
  
  - (#{ directional_methods.join("|") })
  - key_held.(#{ directional_methods.join("|") })
  - key_down.(#{ directional_methods.join("|") })
  
  #{klass} does not respond to all of these methods (here is the diagnostics):
  #{method_results.map {|m, r| "- #{m}: #{r}"}.join("\n")}
  
  Please implement the methods that returned false inthe list above.
  S
        unless method_results.map {|m, result| result}.all?
          raise error_message
        end
      end
  
      # Returns a signal indicating left (`-1`), right (`1`), or neither ('0').
      #
      # @return [Integer]
      def left_right
        return -1 if self.left
        return  1 if self.right
        return  0
      end
  
      # Returns a signal indicating up (`1`), down (`-1`), or neither ('0').
      #
      # @return [Integer]
      def up_down
        return  1 if self.up
        return -1 if self.down
        return  0
      end
  
      # Returns a normal vector (in the form of a Hash with x, y keys). If no directionals are held/down, the function returns nil.
      #
      # The possible results are:
      #
      # - ~nil~ which denotes that no directional input exists.
      # - ~[   0,    1]~ which denotes that only up is being held/pressed.
      # - ~[   0,   -1]~ which denotes that only down is being held/pressed.
      # - ~[-0.707,  0.707]~ which denotes that right and up are being pressed/held.
      # - ~[-0.707, -0.707]~ which denotes that left and down are being pressed/held.
      def directional_vector
        lr, ud = self.left_right, self.up_down
  
        if lr == 0 && ud == 0
          return nil
        elsif lr.abs == ud.abs
          return { x: 45.vector_x * lr.sign, y: 45.vector_y * ud.sign }
        else
          return { x: lr, y: ud }
        end
      end
  
      def directional_angle
        return nil unless directional_vector
  
        Math.atan2(up_down, left_right).to_degrees
      end
  
      def method_missing m, *args
        # combine the key with ctrl_
        if m.to_s.start_with?("ctrl_")
          other_key = m.to_s.split("_").last
          define_singleton_method(m) do
            return self.key_down.send(other_key.to_sym) && self.control
          end
  
          return send(m)
        else
        # see if the key is either held or down
          define_singleton_method(m) do
            self.key_down.send(m) || self.key_held.send(m)
          end
  
          return send(m)
        end
      end
    end
  end

#+end_src

** easing.rb
#+begin_src ruby
  # ./dragon/easing.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # easing.rb has been released under MIT (*only this file*).
  
  module GTK
    module Easing
      def self.ease start_tick, current_tick, duration, *definitions
        ease_extended start_tick,
                      current_tick,
                      start_tick + duration,
                      initial_value(*definitions),
                      final_value(*definitions),
                      *definitions
      end
  
      def self.ease_extended start_tick, current_tick, end_tick, default_before, default_after, *definitions
        definitions.flatten!
        definitions = [:identity] if definitions.length == 0
        duration = end_tick - start_tick
        elapsed  = current_tick - start_tick
        y = elapsed.percentage_of(duration).cap_min_max(0, 1)
  
        definitions.map do |definition|
          y = Easing.exec_definition(definition, start_tick, duration, y)
        end
  
        y
      end
  
      def self.ease_spline start_tick, current_tick, duration, spline
        ease_spline_extended start_tick, current_tick, start_tick + duration, spline
      end
  
      def self.ease_spline_extended start_tick, current_tick, end_tick, spline
        return spline[-1][-1] if current_tick >= end_tick
        duration = end_tick - start_tick
        t = (current_tick - start_tick).fdiv duration
        time_allocation_per_curve = 1.fdiv(spline.length)
        spline_t = t.fdiv(time_allocation_per_curve)
        curve_index = spline_t.to_i
        curve_t = spline_t - spline_t.to_i
        Geometry.cubic_bezier curve_t, *spline[curve_index]
      end
  
      def self.initial_value *definitions
        definitions.flatten!
        return Easing.exec_definition (definitions.at(-1) || :identity), 0, 10, 0
      end
  
      def self.final_value *definitions
        definitions.flatten!
        return Easing.exec_definition (definitions.at(-1) || :identity), 0, 10, 1.0
      end
  
      def self.exec_definition definition, start_tick, duration, x
        if definition.is_a? Symbol
          return Easing.send(definition, x).cap_min_max(0, 1)
        elsif definition.is_a? Proc
          return definition.call(x, start_tick, duration).cap_min_max(0, 1)
        end
  
        raise <<-S
  * ERROR:
  I don't know how to execute easing function with definition #{definition}.
  
  S
      end
  
      def self.identity x
        x
      end
  
      def self.flip x
        1 - x
      end
  
      def self.quad x
        x * x
      end
  
      def self.cube x
        x * x * x
      end
  
      def self.quart x
        x * x * x * x * x
      end
  
      def self.quint x
        x * x * x * x * x * x
      end
  
      def self.smooth_start_quad x
        quad x
      end
  
      def self.smooth_stop_quad x
        flip(quad(flip(x)))
      end
  
      def self.smooth_start_cube x
        cube x
      end
  
      def self.smooth_stop_cube x
        flip(cube(flip(x)))
      end
  
      def self.smooth_start_quart x
        quart x
      end
  
      def self.smooth_stop_quart x
        flip(quart(flip(x)))
      end
  
      def self.smooth_start_quint x
        quint x
      end
  
      def self.smooth_stop_quint x
        flip(quint(flip(x)))
      end
    end
  end
  
  Easing = GTK::Easing

#+end_src

** entity.rb
#+begin_src ruby
  # ./dragon/entity.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # entity.rb has been released under MIT (*only this file*).
  
  module GTK
    class Entity
      def self.id!
        @id ||= 0
        @id += 1
        @id
      end
  
      def self.__reset_id__!
        @id = 0
      end
  
      def self.strict_entities
        @strict_entities ||= {}
        @strict_entities
      end
  
      def self.parse_serialization_data value
        if value.is_a?(Hash) && value[:entity_id] && value[:entity_strict]
          o = new_entity_strict value[:entity_name], value
          o.load_entity_data! value
          return o
        elsif value.is_a?(Hash) && value[:entity_id]
          o = OpenEntity.new
          o.load_entity_data! value
          return o
        elsif value.is_a? Array
          return value.map { |entry| Entity.parse_serialization_data entry }
        else
          return value
        end
      end
  
      def self.new_entity entity_type, init_hash = nil, block = nil
        n = OpenEntity.new(entity_type)
        n.entity_type = entity_type
        n.created_at = Kernel.tick_count
        n.global_created_at = Kernel.global_tick_count
  
        if init_hash
          init_hash.each do |k, v|
            n.as_hash[k] = v
          end
        end
  
        block.call(n) if block
  
        n
      end
  
      def self.new_entity_strict entity_type, init_hash = nil, block = nil
        if !Entity.strict_entities[entity_type]
          init_hash ||= { }
  
          n = new_entity entity_type, init_hash, block
          klass = Class.new(StrictEntity)
  
          klass.class_eval do
            init_hash.each do |k, v|
              attr_accessor k
            end
  
            n.as_hash.each do |k, v|
              attr_accessor k if !init_hash[k]
            end
          end
  
          Entity.strict_entities[entity_type] = klass
        end
  
        klass = Entity.strict_entities[entity_type]
        (klass.new entity_type, init_hash, block)
      end
    end
  end

#+end_src

** geometry.rb
#+begin_src ruby
  # ./dragon/geometry.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # geometry.rb has been released under MIT (*only this file*).
  
  module GTK
    module Geometry
      def self.rotate_point point, angle, around = nil
        s = Math.sin angle.to_radians
        c = Math.cos angle.to_radians
        px = point.x
        py = point.y
        cx = 0
        cy = 0
        if around
          cx = around.x
          cy = around.y
        end
  
        point.merge(x: ((px - cx) * c - (py - cy) * s) + cx,
                    y: ((px - cx) * s + (py - cy) * c) + cy)
      end
  
      # Returns f(t) for a cubic Bezier curve.
      def self.cubic_bezier t, a, b, c, d
        s  = 1 - t
        s0 = 1
        s1 = s
        s2 = s * s
        s3 = s * s * s
  
        t0 = 1
        t1 = t
        t2 = t * t
        t3 = t * t * t
  
        1 * s3 * t0 * a +
        3 * s2 * t1 * b +
        3 * s1 * t2 * c +
        1 * s0 * t3 * d
      end
  
      # Returns true if a primitive's rectangle is entirely inside another primitive's rectangle.
      def inside_rect? outer, tolerance = 0.0
        Geometry.inside_rect? self, outer, tolerance
      end
  
      def intersects_rect? *args
        Geometry.intersects_rect?(*args)
      end
  
      def scale_rect_extended percentage_x: percentage_x,
                              percentage_y: percentage_y,
                              anchor_x: anchor_x,
                              anchor_y: anchor_y
  
        Geometry.scale_rect_extended self,
                                     percentage_x: percentage_x,
                                     percentage_y: percentage_y,
                                     anchor_x: anchor_x,
                                     anchor_y: anchor_y
      end
  
      # Scales a primitive rect by a percentage.
      def scale_rect percentage, *anchors
        Geometry.scale_rect self, percentage, *anchors
      end
  
      # Returns the angle from one primitive to another primitive.
      def angle_to other_point
        Geometry.angle_to self, other_point
      end
  
      # Returns the angle to one primitive from another primitive.
      def angle_from other_point
        Geometry.angle_from self, other_point
      end
  
      # Returns true if a primitive is within a circle specified by the circle's center and radius.
      def point_inside_circle? circle_center_point, radius
        Geometry.point_inside_circle? self, circle_center_point, radius
      end
  
      def self.center_inside_rect rect, other_rect
        offset_x = (other_rect.w - rect.w).half
        offset_y = (other_rect.h - rect.h).half
        new_rect = rect.shift_rect(0, 0)
        new_rect.x = other_rect.x + offset_x
        new_rect.y = other_rect.y + offset_y
        new_rect
      rescue Exception => e
        raise e, <<-S
  * ERROR:
  center_inside_rect for self #{self} and other_rect #{other_rect}.\n#{e}.
  S
      end
  
      def center_inside_rect other_rect
        Geometry.center_inside_rect self, other_rect
      end
  
      def self.center_inside_rect_x rect, other_rect
        offset_x   = (other_rect.w - rect.w).half
        new_rect   = rect.shift_rect(0, 0)
        new_rect.x = other_rect.x + offset_x
        new_rect.y = other_rect.y
        new_rect
      rescue Exception => e
        raise e, <<-S
  * ERROR:
  center_inside_rect_x for self #{self} and other_rect #{other_rect}.\n#{e}.
  S
      end
  
      def center_inside_rect_x other_rect
        Geometry.center_inside_rect_x self, other_rect
      end
  
      def self.center_inside_rect_y rect, other_rect
        offset_y = (other_rect.h - rect.h).half
        new_rect = rect.shift_rect(0, 0)
        new_rect.x = other_rect.x
        new_rect.y = other_rect.y + offset_y
        new_rect
      rescue Exception => e
        raise e, <<-S
  * ERROR:
  center_inside_rect_y for self #{self} and other_rect #{other_rect}.\n#{e}.
  S
      end
  
      def center_inside_rect_y other_rect
        Geometry.center_inside_rect_y self, other_rect
      end
  
      # Returns a primitive that is anchored/repositioned based off its rectangle.
      def anchor_rect anchor_x, anchor_y
        current_w = self.w
        current_h = self.h
        delta_x = -1 * (anchor_x * current_w)
        delta_y = -1 * (anchor_y * current_h)
        self.shift_rect(delta_x, delta_y)
      end
  
      def angle_given_point other_point
        raise ":angle_given_point has been deprecated use :angle_from instead."
      end
  
      def self.shift_line line, x, y
        if line.is_a?(Array) || line.is_a?(Hash)
          new_line = line.dup
          new_line.x  += x
          new_line.x2 += x
          new_line.y  += y
          new_line.y2 += y
          new_line
        else
          raise "shift_line for #{line} is not supported."
        end
      end
  
      def self.intersects_rect? *args
        raise <<-S
  intersects_rect? (with an \"s\") has been deprecated.
  Use intersect_rect? instead (remove the \"s\").
  
  * NOTE:
  Ruby's naming convention is to *never* include the \"s\" for
  interrogative method names (methods that end with a ?). It
  doesn't sound grammatically correct, but that has been the
  rule for a long time (and why intersects_rect? has been deprecated).
  
  S
      end
  
      def self.line_y_intercept line, replace_infinity: nil
        line.y - line_slope(line, replace_infinity: replace_infinity) * line.x
      rescue Exception => e
  raise <<-S
  * ERROR: ~Geometry::line_y_intercept~
  The following exception was thrown for line: #{line}
  #{e}
  
  Consider passing in ~replace_infinity: VALUE~ to handle for vertical lines.
  S
      end
  
      def self.angle_between_lines line_one, line_two, replace_infinity: nil
        m_line_one = line_slope line_one, replace_infinity: replace_infinity
        m_line_two = line_slope line_two, replace_infinity: replace_infinity
        Math.atan((m_line_one - m_line_two) / (1 + m_line_two * m_line_one)).to_degrees
      end
  
      def self.line_slope line, replace_infinity: nil
        if line.is_a? Hash
          # check to see if replace_inifinity exists on the hash
          # handles for if the dev does:
          #   line_slope(x: 10, y: 10, x2: 100, y2: 100, replace_infinity: 10)
          # instead of
          #   line_slope({ x: 10, y: 10, x2: 100, y2: 100 }, replace_infinity: 10)
          replace_infinity ||= line[:replace_infinity]
        end
  
        if line.y == line.y2 && line.x == line.x2
          raise <<-S
  * ERROR: ~Geometry::line_slope~
    I was given a line with zero length and can't compute its slope:
    #{line}
  S
        elsif line.y == line.y2
          return 0
        elsif line.x == line.x2
          return nil if !replace_infinity
          if line.y2 < line.y
            return replace_infinity * -1
          else
            return replace_infinity
          end
        end
  
        (line.y2 - line.y).fdiv(line.x2 - line.x)
                          .replace_infinity(replace_infinity)
      end
  
      def self.line_rise_run line
        rise_run = { x: line.x2 - line.x, y: line.y2 - line.y }
        l = Math.sqrt(rise_run.x**2 + rise_run.y**2)
  
        normaized_rise_run_x = 0
        normaized_rise_run_y = 0
  
        if l > 0
          n_l = 1.fdiv(l)
          normaized_rise_run_x = rise_run.x * n_l
          normaized_rise_run_y = rise_run.y * n_l
        end
  
        { x: normaized_rise_run_x, y: normaized_rise_run_y }
      end
  
      def self.ray_test point, line
        slope = (line.y2 - line.y).fdiv(line.x2 - line.x)
  
        x  = line.x
        y  = line.y
        x2 = line.x2
        y2 = line.y2
  
        if x2 < x
          x, x2 = x2, x
          y, y2 = y2, y
        end
  
        r = ((x2 - x) * (point.y - y) - (point.x -  x) * (y2 - y))
  
        if r == 0
          return :on
        elsif r < 0
          return :right if slope >= 0
          return :left
        elsif r > 0
          return :left if slope >= 0
          return :right
        end
      end
  
      def self.line_to_rect line, min_w: 0, min_h: 0
        line_rect line, min_w: 0, min_h: 0
      end
  
      def line_to_rect min_w: 0, min_h: 0
        Geometry.line_to_rect self, min_w: 0, min_h: 0
      end
  
      def self.line_rect line, min_w: 0, min_h: 0
        if min_w < 0 || min_h < 0
        raise <<-S
  * ERROR: ~Geometry::line_rect~
    ~min_w~ and ~min_h~ must be greater than min
    line:  #{line}
    min_w: #{min_w}
    min_h: #{min_h}
  S
        end
  
        if line.x > line.x2
          x  = line.x2
          x2 = line.x
        else
          x  = line.x
          x2 = line.x2
        end
  
        if line.y > line.y2
          y  = line.y2
          y2 = line.y
        else
          y  = line.y
          y2 = line.y2
        end
  
        w = x2 - x
        h = y2 - y
  
        if w < min_w
          w  = min_w
          x -= min_w / 2
        end
  
        if h < min_h
          h  = min_h
          y -= min_h / 2
        end
  
        { x: x, y: y, w: w, h: h }
      end
  
      def self.line_intersect line_one, line_two, replace_infinity: nil
        x1 = line_one.x
        y1 = line_one.y
        x2 = line_one.x2
        y2 = line_one.y2
  
        x3 = line_two.x
        y3 = line_two.y
        x4 = line_two.x2
        y4 = line_two.y2
  
        x1x2 = x1 - x2
        y1y2 = y1 - y2
        x1x3 = x1 - x3
        y1y3 = y1 - y3
        x3x4 = x3 - x4
        y3y4 = y3 - y4
  
        d =  x1x2 * y3y4 - y1y2 * x3x4;
  
        return nil if d == 0
  
        t = (x1x3 * y3y4 - y1y3 * x3x4) / d
        u = -(x1x2 * y1y3 - y1y2 * x1x3) / d
  
        {
          x: x1 + t * (x2 - x1),
          y: y1 + t * (y2 - y1)
        }
      end
  
      def self.to_square size, x, y, anchor_x = 0.5, anchor_y = nil
        log_once :to_square, <<-S
  * WARNING: Numeric#to_square and Geometry::to_square are deprecated and will not be replaced by another function.
  S
        anchor_y ||= anchor_x
        x = x.shift_left(size * anchor_x)
        y = y.shift_down(size * anchor_y)
        [x, y, size, size]
      rescue Exception => e
        raise e, ":to_square failed for size: #{size} x: #{x} y: #{y} anchor_x: #{anchor_x} anchor_y: #{anchor_y}.\n#{e}"
      end
  
      def self.distance point_one, point_two
        Math.sqrt((point_two.x - point_one.x)**2 + (point_two.y - point_one.y)**2)
      rescue Exception => e
        raise e, ":distance failed for point_one: #{point_one} point_two #{point_two}.\n#{e}"
      end
  
      def self.angle_from start_point, end_point
        d_y = end_point.y - start_point.y
        d_x = end_point.x - start_point.x
        Math::PI.+(Math.atan2(d_y, d_x)).to_degrees % 360
      rescue Exception => e
        raise e, ":angle_from failed for start_point: #{start_point} end_point: #{end_point}.\n#{e}"
      end
  
      def self.angle_to start_point, end_point
        angle_from end_point, start_point
      rescue Exception => e
        raise e, ":angle_to failed for start_point: #{start_point} end_point: #{end_point}.\n#{e}"
      end
  
      def self.point_inside_circle? point, circle_center_point, radius
        (point.x - circle_center_point.x) ** 2 + (point.y - circle_center_point.y) ** 2 < radius ** 2
      rescue Exception => e
        raise e, ":point_inside_circle? failed for point: #{point} circle_center_point: #{circle_center_point} radius: #{radius}.\n#{e}"
      end
  
      def self.inside_rect? inner_rect, outer_rect, tolerance = 0.0
        return nil if !inner_rect
        return nil if !outer_rect
  
        inner_rect_anchor_x = 0
        inner_rect_anchor_x = inner_rect.anchor_x || 0 if inner_rect.respond_to?(:anchor_x)
  
        inner_rect_anchor_y = 0
        inner_rect_anchor_y = inner_rect.anchor_y || 0 if inner_rect.respond_to?(:anchor_y)
  
        outer_rect_anchor_x = 0
        outer_rect_anchor_x = outer_rect.anchor_x || 0 if outer_rect.respond_to?(:anchor_x)
  
        outer_rect_anchor_y = 0
        outer_rect_anchor_y = outer_rect.anchor_y || 0 if outer_rect.respond_to?(:anchor_y)
  
        inner_rect_x = inner_rect.x - inner_rect_anchor_x * inner_rect.w
        inner_rect_y = inner_rect.y - inner_rect_anchor_y * inner_rect.h
  
        outer_rect_x = outer_rect.x - outer_rect_anchor_x * outer_rect.w
        outer_rect_y = outer_rect.y - outer_rect_anchor_y * outer_rect.h
  
        inner_rect_x     + tolerance >= outer_rect_x     - tolerance &&
        (inner_rect_x + inner_rect.w) - tolerance <= (outer_rect_x + outer_rect.w) + tolerance &&
        inner_rect.y     + tolerance >= outer_rect_y     - tolerance &&
        (inner_rect.y + inner_rect.h) - tolerance <= (outer_rect_y + outer_rect.h) + tolerance
      rescue Exception => e
        raise e, ":inside_rect? failed for inner_rect: #{inner_rect} outer_rect: #{outer_rect}.\n#{e}"
      end
  
      def self.scale_rect_extended rect,
                                   percentage_x: percentage_x,
                                   percentage_y: percentage_y,
                                   anchor_x: anchor_x,
                                   anchor_y: anchor_y
        anchor_x ||= 0.0
        anchor_y ||= 0.0
        percentage_x ||= 1.0
        percentage_y ||= 1.0
        new_w = rect.w * percentage_x
        new_h = rect.h * percentage_y
        new_x = rect.x + (rect.w - new_w) * anchor_x
        new_y = rect.y + (rect.h - new_h) * anchor_y
        if rect.is_a? Array
          return [
            new_x,
            new_y,
            new_w,
            new_h,
            *rect[4..-1]
          ]
        elsif rect.is_a? Hash
          return rect.merge(x: new_x, y: new_y, w: new_w, h: new_h)
        else
          rect.x = new_x
          rect.y = new_y
          rect.w = new_w
          rect.h = new_h
          return rect
        end
      rescue Exception => e
        raise e, ":scale_rect_extended failed for rect: #{rect} percentage_x: #{percentage_x} percentage_y: #{percentage_y} anchors_x: #{anchor_x} anchor_y: #{anchor_y}.\n#{e}"
      end
  
      def self.scale_rect rect, percentage, *anchors
        anchor_x, anchor_y = *anchors.flatten
        anchor_x ||= 0
        anchor_y ||= anchor_x
        Geometry.scale_rect_extended rect,
                                     percentage_x: percentage,
                                     percentage_y: percentage,
                                     anchor_x: anchor_x,
                                     anchor_y: anchor_y
      rescue Exception => e
        raise e, ":scale_rect failed for rect: #{rect} percentage: #{percentage} anchors [#{anchor_x} (x), #{anchor_y} (y)].\n#{e}"
      end
  
      def self.rect_to_line rect
        {
          x: rect.x,
          y: rect.y,
          x2: rect.x + rect.w - 1,
          y2: rect.y + rect.h
        }
      end
  
      def rect_to_line
        Geometry.rect_to_line self
      end
  
      def self.rect_center_point rect
        { x: rect.x + rect.w.half, y: rect.y + rect.h.half }
      end
  
      def self.center rect
        { x: rect.x + rect.w.half, y: rect.y + rect.h.half }
      end
  
      def rect_center_point
        Geometry.rect_center_point self
      end
    end # module Geometry
  end # module GTK
  
  Geometry = GTK::Geometry

#+end_src

** grid.rb
#+begin_src ruby
  # ./dragon/grid.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # grid.rb has been released under MIT (*only this file*).
  
  module GTK
    class Grid
      include Serialize
      include GridDeprecated
      SCREEN_Y_DIRECTION = -1.0
  
      attr_accessor :name
      attr_accessor :bottom
      attr_accessor :top
      attr_accessor :left
      attr_accessor :right
      attr_accessor :center_x
      attr_accessor :center_y
      attr_accessor :rect
      attr_accessor :origin_x
      attr_accessor :origin_y
  
      attr_accessor :left_margin, :bottom_margin
  
      attr :allscreen_left,
           :allscreen_right,
           :allscreen_top,
           :allscreen_bottom,
           :allscreen_width,
           :allscreen_height,
           :allscreen_offset_x,
           :allscreen_offset_y,
           :native_width,
           :native_height,
           :native_scale,
           :native_scale_enum,
           :window_width,
           :window_height
  
      def initialize runtime
        @runtime = runtime
        @ffi_draw = runtime.ffi_draw
        origin_bottom_left!
      end
  
      def orientation
        @runtime.orientation
      end
  
      def transform_x x
        @origin_x + x
      end
  
      def untransform_x x
        x - @origin_x
      end
  
      def transform_y y
        @origin_y + y * SCREEN_Y_DIRECTION
      end
  
      def untransform_y y
        @origin_y + y * SCREEN_Y_DIRECTION
      end
  
      def ffi_draw
        @ffi_draw
      end
  
      def ffi_draw= value
        @ffi_draw = value
      end
  
      def origin_bottom_left!
        return if @name == :bottom_left
        @name = :bottom_left
        @origin_x = 0.0
        @origin_y = @runtime.logical_height
        @left   = 0.0
        @right  = @runtime.logical_width
        @top    = @runtime.logical_height
        @bottom = 0.0
        @left_margin = 0.0
        @bottom_margin = 0.0
        @center_x = @runtime.logical_width.half
        @center_y = @runtime.logical_height.half
        @rect   = [@left, @bottom, @runtime.logical_width, @runtime.logical_height].rect
        @center = [@center_x, @center_y].point
        @ffi_draw.set_grid @origin_x, @origin_y, SCREEN_Y_DIRECTION
        @device_left       ||= @left
        @device_right      ||= @right
        @device_top        ||= @top
        @device_bottom     ||= @bottom
        @device_width      ||= @runtime.logical_width
        @device_height     ||= @runtime.logical_height
        @native_width      ||= @runtime.logical_width
        @native_height     ||= @runtime.logical_height
        @native_scale      ||= 1.0
        @native_scale_enum ||= 1.0
      end
  
      def origin_center!
        return if @name == :center
        @name = :center
        @origin_x = @runtime.logical_width.half
        @origin_y = @runtime.logical_height.half
        @left   =  -@runtime.logical_width.half
        @right  =   @runtime.logical_width.half
        @top    =   @runtime.logical_height.half
        @bottom =  -@runtime.logical_height.half
        @center_x = 0.0
        @center_y = 0.0
        @rect   = [@left, @bottom, @runtime.logical_width, @runtime.logical_height].rect
        @center = [@center_x, @center_y].point
        @ffi_draw.set_grid @origin_x, @origin_y, SCREEN_Y_DIRECTION
        @device_left     ||= @left
        @device_right    ||= @right
        @device_top      ||= @top
        @device_bottom   ||= @bottom
        @device_width    ||= @runtime.logical_width
        @device_height   ||= @runtime.logical_height
        @render_width    ||= @runtime.logical_width
        @render_height   ||= @runtime.logical_height
        @render_scale    ||= 1.0
        @render_offset_x ||= 0
        @render_offset_y ||= 0
      end
  
      def w
        @runtime.logical_width
      end
  
      def w_half
        w.half
      end
  
      def h
        @runtime.logical_height
      end
  
      def h_half
        h.half
      end
  
      def center
        @center
      end
  
      def bottom_right
        [@right, @bottom].point
      end
  
      def x
        0
      end
  
      def y
        0
      end
  
      def hd_left
        @allscreen_left
      end
  
      def hd_left= value
        @allscreen_left = value
      end
  
      def hd_right
        @allscreen_right
      end
  
      def hd_right= value
        @allscreen_right = value
      end
  
      def hd_top
        @allscreen_top
      end
  
      def hd_top= value
        @allscreen_top = value
      end
  
      def hd_bottom
        @allscreen_bottom
      end
  
      def hd_bottom= value
        @allscreen_bottom = value
      end
  
      def hd_width
        @allscreen_width
      end
  
      def hd_width= value
        @allscreen_width = value
      end
  
      def hd_height
        @allscreen_height
      end
  
      def hd_height= value
        @allscreen_height = value
      end
  
      def hd_offset_x
        @allscreen_offset_x
      end
  
      def hd_offset_x= value
        @allscreen_offset_x = value
      end
  
      def hd_offset_y
        @allscreen_offset_y
      end
  
      def hd_offset_y= value
        @allscreen_offset_y = value
      end
    end
  end

#+end_src

** inputs.rb
#+begin_src ruby
  # ./dragon/inputs.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # inputs.rb has been released under MIT (*only this file*).
  
  module GTK
    class KeyboardKeys
      include Serialize
  
      attr_accessor :exclamation_point,
                    :zero, :one, :two, :three, :four,
                    :five, :six, :seven, :eight, :nine,
                    :backspace, :delete, :escape, :enter, :tab,
                    :open_round_brace, :close_round_brace,
                    :open_curly_brace, :close_curly_brace,
                    :open_square_brace, :close_square_brace,
                    :colon, :semicolon, :equal_sign,
                    :hyphen, :space, :dollar_sign,
                    :double_quotation_mark,
                    :single_quotation_mark,
                    :backtick,
                    :tilde, :period, :comma, :pipe,
                    :underscore,
                    :a, :b, :c, :d, :e, :f, :g, :h,
                    :i, :j, :k, :l, :m, :n, :o, :p,
                    :q, :r, :s, :t, :u, :v, :w, :x,
                    :y, :z,
                    :shift, :control, :alt, :meta,
                    :shift_left, :shift_right,
                    :control_left, :control_right,
                    :alt_left, :alt_right,
                    :meta_left, :meta_right,
                    :home, :end,
                    :left, :right, :up, :down, :pageup, :pagedown,
                    :char, :plus, :at, :forward_slash, :back_slash, :asterisk,
                    :less_than, :greater_than, :carat, :ampersand, :superscript_two,
                    :circumflex,
                    :question_mark, :section_sign, :ordinal_indicator,
                    :raw_key
  
      def self.sdl_to_key raw_key, modifier
        return nil unless (raw_key >= 0 && raw_key <= 255) ||
                          raw_key == 1073741903 ||
                          raw_key == 1073741904 ||
                          raw_key == 1073741905 ||
                          raw_key == 1073741906 ||
                          raw_key == 1073741899 ||
                          raw_key == 1073741902 ||
                          raw_key == 1073741898 ||
                          raw_key == 1073741901 ||
                          (raw_key >= 1073742048 && raw_key <= 1073742055) # Modifier Keys
  
        char = KeyboardKeys.char_with_shift raw_key, modifier
        names = KeyboardKeys.char_to_method char, raw_key
        names << :alt if (modifier & (256|512)) != 0    # alt key
        names << :meta if (modifier & (1024|2048)) != 0 # meta key (command/apple/windows key)
        names << :control if (modifier & (64|128)) != 0 # ctrl key
        names << :shift if (modifier & (1|2)) != 0      # shift key
        names
      end
  
      def self.utf_8_char raw_key
        return "²" if raw_key == 178
        return "§" if raw_key == 167
        return "º" if raw_key == 186
        return raw_key.chr
      end
  
      def self.char_with_shift raw_key, modifier
        return nil unless raw_key >= 0 && raw_key <= 255
        if modifier != 1 && modifier != 2 && modifier != 3
          return utf_8_char raw_key
        else
          @shift_keys ||= {
            '`' => '~', '-' => '_', "'" => '"', "1" => '!',
            "2" => '@', "3" => '#', "4" => '$', "5" => '%',
            "6" => '^', "7" => '&', "8" => '*', "9" => '(',
            "0" => ')', ";" => ":", "=" => "+", "[" => "{",
            "]" => "}", '\\'=> "|", '/' => "?", '.' => ">",
            ',' => "<", 'a' => 'A', 'b' => 'B', 'c' => 'C',
            'd' => 'D', 'e' => 'E', 'f' => 'F', 'g' => 'G',
            'h' => 'H', 'i' => 'I', 'j' => 'J', 'k' => 'K',
            'l' => 'L', 'm' => 'M', 'n' => 'N', 'o' => 'O',
            'p' => 'P', 'q' => 'Q', 'r' => 'R', 's' => 'S',
            't' => 'T', 'u' => 'U', 'v' => 'V', 'w' => 'W',
            'x' => 'X', 'y' => 'Y', 'z' => 'Z'
          }
  
          @shift_keys[raw_key.chr.to_s] || raw_key.chr.to_s
        end
      end
  
      def self.char_to_method_hash
        @char_to_method ||= {
          'A'  => [:a],
          'B'  => [:b],
          'C'  => [:c],
          'D'  => [:d],
          'E'  => [:e],
          'F'  => [:f],
          'G'  => [:g],
          'H'  => [:h],
          'I'  => [:i],
          'J'  => [:j],
          'K'  => [:k],
          'L'  => [:l],
          'M'  => [:m],
          'N'  => [:n],
          'O'  => [:o],
          'P'  => [:p],
          'Q'  => [:q],
          'R'  => [:r],
          'S'  => [:s],
          'T'  => [:t],
          'U'  => [:u],
          'V'  => [:v],
          'W'  => [:w],
          'X'  => [:x],
          'Y'  => [:y],
          'Z'  => [:z],
          "!"  => [:exclamation_point],
          "0"  => [:zero],
          "1"  => [:one],
          "2"  => [:two],
          "3"  => [:three],
          "4"  => [:four],
          "5"  => [:five],
          "6"  => [:six],
          "7"  => [:seven],
          "8"  => [:eight],
          "9"  => [:nine],
          "\b" => [:backspace],
          "\e" => [:escape],
          "\r" => [:enter],
          "\t" => [:tab],
          "("  => [:open_round_brace],
          ")"  => [:close_round_brace],
          "{"  => [:open_curly_brace],
          "}"  => [:close_curly_brace],
          "["  => [:open_square_brace],
          "]"  => [:close_square_brace],
          ":"  => [:colon],
          ";"  => [:semicolon],
          "="  => [:equal_sign],
          "-"  => [:hyphen, :minus],
          " "  => [:space],
          "$"  => [:dollar_sign],
          "\"" => [:double_quotation_mark],
          "'"  => [:single_quotation_mark],
          "`"  => [:backtick],
          "~"  => [:tilde],
          "."  => [:period],
          ","  => [:comma],
          "|"  => [:pipe],
          "_"  => [:underscore],
          "#"  => [:hash],
          "+"  => [:plus],
          "@"  => [:at],
          "/"  => [:forward_slash],
          "\\" => [:back_slash],
          "*"  => [:asterisk],
          "<"  => [:less_than],
          ">"  => [:greater_than],
          "^"  => [:circumflex],
          "&"  => [:ampersand],
          "²"  => [:superscript_two],
          "§"  => [:section_sign],
          "?"  => [:question_mark],
          '%'  => [:percent_sign],
          "º"  => [:ordinal_indicator],
          1073741898 => [:home],
          1073741901 => [:end],
          1073741903 => [:right],
          1073741904 => [:left],
          1073741905 => [:down],
          1073741906 => [:up],
          1073741899 => [:pageup],
          1073741902 => [:pagedown],
          127 => [:delete],
          1073742049 => [:shift_left, :shift],
          1073742053 => [:shift_right, :shift],
          1073742048 => [:control_left, :control],
          1073742052 => [:control_right, :control],
          1073742050 => [:alt_left, :alt],
          1073742054 => [:alt_right, :alt],
          1073742051 => [:meta_left, :meta],
          1073742055 => [:meta_right, :meta]
        }
      end
  
      def self.method_to_key_hash
        return @method_to_key_hash if @method_to_key_hash
        @method_to_key_hash = {}
        string_representation_overrides ||= {
          backspace: '\b'
        }
        char_to_method_hash.each do |k, v|
          v.each do |vi|
            t = { char_or_raw_key: k }
  
            if k.is_a? Numeric
              t[:raw_key] = k
              t[:string_representation] = "raw_key == #{k}"
            else
              t[:char] = k
              t[:string_representation] = "\"#{k.strip}\""
            end
  
            @method_to_key_hash[vi] = t
          end
        end
        @method_to_key_hash
      end
  
      def self.char_to_method char, int = nil
        methods = char_to_method_hash[char] || char_to_method_hash[int]
        methods ? methods.dup : [char.to_sym || int]
      end
  
      def clear
        set truthy_keys, false
        @scrubbed_ivars = nil
      end
  
      def left_right
        return -1 if self.left
        return  1 if self.right
        return  0
      end
  
      def up_down
        return  1 if self.up
        return -1 if self.down
        return  0
      end
  
      def truthy_keys
        get(all).find_all { |_, v| v }
                .map { |k, _| k.to_sym }
      end
  
      def all? keys
        values = get(keys.map { |k| k.without_ending_bang })
        all_true = values.all? do |k, v|
          v
        end
  
        if all_true
          keys.each do |k|
            clear_key k if k.end_with_bang?
          end
        end
  
        all_true
      end
  
      def any? keys
        values = get(keys.map { |k| k.without_ending_bang })
        any_true = values.any? do |k, v|
          v
        end
  
        if any_true
          keys.each do |k|
            clear_key k if k.end_with_bang?
          end
        end
  
        any_true
      end
  
      def clear_key key
        @scrubbed_ivars = nil
        self.instance_variable_set("@#{key.without_ending_bang}", false)
      end
  
      def all
        @scrubbed_ivars ||= self.instance_variables
                                .reject { |i| i == :@all || i == :@scrubbed_ivars }
                                .map { |i| i.to_s.gsub("@", "") }
  
        get(@scrubbed_ivars).map { |k, _| k }
      end
  
      def get collection
        return [] if collection.length == 0
        collection.map do |m|
          if m.end_with_bang?
            clear_after_return = true
          end
  
          value = self.instance_variable_get("@#{m.without_ending_bang}".to_sym)
          clear_key m if clear_after_return
          [m.without_ending_bang, value]
        end
      end
  
      def set collection, value
        return if collection.length == 0
        @scrubbed_ivars = nil
  
        collection.each do |m|
          m_to_s = m.to_s
          self.instance_variable_set("@#{m_to_s}".to_sym, value) if m_to_s.strip.length > 0
        rescue Exception => e
          raise e, <<-S
  * ERROR:
  Attempted to set the a key on the DragonRuby GTK's Keyboard data
  structure, but the property isn't available for raw_key #{raw_key} #{m}.
  
  You should contact DragonRuby and tell them to associate the raw_key #{raw_key}
  with a friendly property name (we are open to suggestions if you have any).
  [GTK::KeyboardKeys#set, GTK::KeyboardKeys#char_to_method]
  
  S
        end
      end
  
      def method_missing m, *args
        if KeyboardKeys.method_to_key_hash[m.without_ending_bang]
          begin
            define_singleton_method(m) do
              r = self.instance_variable_get("@#{m.without_ending_bang}".to_sym)
              clear_key m
              return r
            end
  
            return self.send m
          rescue Exception => e
            log_important "#{e}"
          end
        end
  
        did_you_mean = KeyboardKeys.method_to_key_hash.find_all do |k, v|
          k.to_s[0..1] == m.to_s[0..1]
        end.map {|k, v| ":#{k} (#{v[:string_representation]})" }
        did_you_mean_string = ""
        did_you_mean_string = ". Did you mean #{did_you_mean.join ", "}?"
  
        raise <<-S
  * ERROR:
  #{KeyboardKeys.method_to_key_hash.map { |k, v| "** :#{k} #{v.string_representation}" }.join("\n")}
  
  There is no key on the keyboard called :#{m}#{did_you_mean_string}.
  Full list of available keys =:points_up:=.
  S
      end
  
      def serialize
        hash = super
        hash.delete(:scrubbed_ivars)
        hash[:truthy_keys] = self.truthy_keys
        hash
      end
    end
  end
  
  module GTK
    class Keyboard
  
      attr_accessor :key_up
      attr_accessor :key_held
      attr_accessor :key_down
      attr_accessor :has_focus
  
      attr :active
  
      def initialize
        @key_up      = KeyboardKeys.new
        @key_held    = KeyboardKeys.new
        @key_down    = KeyboardKeys.new
        @has_focus   = false
      end
  
      def p
        @key_down.p || @key_held.p
      end
  
      # The left arrow or "a" was pressed.
      #
      # @return [Boolean]
      def left
        @key_up.left || @key_held.left || a
      end
  
      def left_arrow
        @key_up.left || @key_held.left
      end
  
      # The right arrow or "d" was pressed.
      #
      # @return [Boolean]
      def right
        @key_up.right || @key_held.right || d
      end
  
      def right_arrow
        @key_up.right || @key_held.right
      end
  
      # The up arrow or "w" was pressed.
      #
      # @return [Boolean]
      def up
        @key_up.up || @key_held.up || w
      end
  
      def up_arrow
        @key_up.up || @key_held.up
      end
  
      # The down arrow or "s" was pressed.
      #
      # @return [Boolean]
      def down
        @key_up.down || @key_held.down || s
      end
  
      def down_arrow
        @key_up.down || @key_held.down
      end
  
      # Clear all current key presses.
      #
      # @return [void]
      def clear
        @key_up.clear
        @key_held.clear
        @key_down.clear
        @active = nil
      end
  
      def serialize
        {
          key_up: @key_up.serialize,
          key_held: @key_held.serialize,
          key_down: @key_down.serialize,
          has_focus: @has_focus
        }
      end
      alias_method :inspect, :serialize
  
      # @return [String]
      def to_s
        serialize.to_s
      end
  
      def key
        {
          down: @key_down.truthy_keys,
          held: @key_held.truthy_keys,
          down_or_held: (@key_down.truthy_keys + @key_held.truthy_keys).uniq,
          up: @key_up.truthy_keys,
        }
      end
      alias_method :keys, :key
  
      include DirectionalInputHelperMethods
    end
  end
  
  module GTK
    class MousePoint
      include GTK::Geometry
  
      attr_accessor :x, :y, :point, :created_at, :global_created_at
  
      def initialize x, y
        @x = x
        @y = y
        @point = { x: @x, y: @y, w: 0, h: 0 }
        @created_at = Kernel.tick_count
        @global_created_at = Kernel.global_tick_count
      end
  
      def w; 0; end
      def h; 0; end
      def left; x; end
      def right; x; end
      def top; y; end
      def bottom; y; end
  
      def created_at_elapsed
        @created_at.elapsed_time
      end
  
      def to_hash
        serialize
      end
  
      def serialize
        {
          x: @x,
          y: @y,
          created_at: @created_at,
          global_created_at: @global_created_at
        }
      end
  
      def inspect
        serialize.to_s
      end
  
      def to_s
        serialize.to_s
      end
    end
  
    class Mouse
      attr_accessor :moved,
                    :moved_at,
                    :global_moved_at,
                    :up, :has_focus,
                    :button_bits, :button_left,
                    :button_middle, :button_right,
                    :button_x1, :button_x2,
                    :wheel, :relative_x, :relative_y,
                    :active
  
      attr_accessor :click
      attr_accessor :click_at
      attr_accessor :global_click_at
      attr_accessor :up_at
      attr_accessor :global_up_at
      attr_accessor :previous_click
      attr_accessor :x
      attr_accessor :y
      attr_accessor :previous_x
      attr_accessor :previous_y
  
      def initialize
        @x = 0
        @y = 0
        @has_focus = false
        @button_bits = 0
        @button_left = false
        @button_middle = false
        @button_right = false
        @button_x1 = false
        @button_x2 = false
        @relative_x = 0
        @relative_y = 0
        clear
      end
  
      def held
        return false if !global_click_at
        return true if global_click_at && !global_up_at
        return global_up_at < global_click_at
      end
  
      def held_at
        return nil if !held
        return click_at + 1
      end
  
      def global_held_at
        return nil if !held
        return global_click_at + 1
      end
  
      def point
        { x: @x, y: @y, w: 0, h: 0 }
      end
  
      def inside_rect? rect
        point.inside_rect? rect
      end
  
      def inside_circle? center, radius
        point.point_inside_circle? center, radius
      end
  
      def intersect_rect? other_rect
        rect.intersect_rect? other_rect
      end
  
      def rect
        { x: point.x, y: point.y, w: 0, h: 0 }
      end
  
      def merge o
        rect.merge o
      end
  
      def w
        0
      end
  
      def h
        0
      end
  
      alias_method :position, :point
  
      def clear
        if @click
          @previous_click = MousePoint.new @click.point.x, @click.point.y
          @previous_click.created_at = @click.created_at
          @previous_click.global_created_at = @click.global_created_at
        end
  
        @active = nil
        @click = nil
        @up    = nil
        @moved = nil
        @wheel = nil
        @relative_x = 0
        @relative_y = 0
      end
  
      def up
        @up
      end
  
      def down
        @click
      end
  
      def serialize
        result = {}
  
        if @click
          result[:click] = @click.to_hash
          result[:down] = @click.to_hash
        end
  
        result[:up] = @up.to_hash if @up
        result[:x] = @x
        result[:y] = @y
        result[:moved] = @moved
        result[:moved_at] = @moved_at
        result[:has_focus] = @has_focus
  
        result
      end
  
      def to_s
        serialize.to_s
      end
  
      alias_method :inspect, :to_s
    end
  
    class FingerTouch
      attr_accessor :moved,
                    :moved_at,
                    :global_moved_at,
                    :down_at,
                    :global_down_at,
                    :touch_order,
                    :first_tick_down,
                    :x, :y
  
      def initialize
        @moved = false
        @moved_at = 0
        @global_moved_at = 0
        @down_at = 0
        @global_down_at = 0
        @touch_order = 0
        @first_tick_down = true
        @x = 0
        @y = 0
      end
  
      def point
        [@x, @y].point
      end
  
      def inside_rect? rect
        point.inside_rect? rect
      end
  
      def inside_circle? center, radius
        point.point_inside_circle? center, radius
      end
  
      alias_method :position, :point
  
      def serialize
        result = {}
        result[:x] = @x
        result[:y] = @y
        result[:touch_order] = @touch_order
        result[:moved] = @moved
        result[:moved_at] = @moved_at
        result[:global_moved_at] = @global_moved_at
        result[:down_at] = @down_at
        result[:global_down_at] = @global_down_at
  
        result
      end
  
      def to_s
        serialize.to_s
      end
  
      alias_method :inspect, :to_s
    end
  end
  
  module GTK
    class Inputs
      attr_reader :controllers
      attr_reader :keyboard
      attr_reader :mouse
      attr_accessor :http_requests
      attr_reader :touch
      attr_accessor :finger_one, :finger_two
      attr_accessor :finger_left, :finger_right
      attr_accessor :text, :history
      attr_accessor :headset
      attr :last_active
      attr :touch_enabled
      attr :locale, :locale_raw
  
      def initialize
        @controllers = [Controller.new, Controller.new, Controller.new, Controller.new]
        @keyboard = Keyboard.new
        @mouse = Mouse.new
        @touch = {}
        @finger_one = nil
        @finger_two = nil
        @text = []
        @http_requests = []
        @headset = {
          position: { x: 0, y: 0, z: 0 },
          orientation: { x: 0, y: 0, z: 0 }
        }
      end
  
      def up
        keyboard.up || (controller_one && controller_one.up)
      end
  
      def down
        keyboard.down || (controller_one && controller_one.down)
      end
  
      def left
        keyboard.left || (controller_one && controller_one.left)
      end
  
      def right
        keyboard.right || (controller_one && controller_one.right)
      end
  
      def directional_vector
        keyboard.directional_vector ||
          (controller_one && controller_one.directional_vector)
      end
  
      def directional_angle
        keyboard.directional_angle || (controller_one && controller_one.directional_angle)
      end
  
      def left_right
        return -1 if self.left
        return  1 if self.right
        return  0
      end
  
      def left_right_arrow
        return -1 if keyboard.left_arrow || (controller_one && controller_one.directional_left)
        return  1 if keyboard.right_arrow || (controller_one && controller_one.directional_right)
        return  0
      end
  
      alias_method :left_right_directional, :left_right_arrow
  
      def up_down
        return  1 if self.up
        return -1 if self.down
        return  0
      end
  
      def up_down_arrow
        return  1 if keyboard.up_arrow || (controller_one && controller_one.directional_up)
        return -1 if keyboard.down_arrow || (controller_one && controller_one.directional_down)
        return  0
      end
  
      alias_method :up_down_directional, :up_down_arrow
  
      def click
        return nil unless @mouse.click
        return @mouse.click.point
      end
  
      def controller_one
        @controllers[0]
      end
  
      def controller_two
        @controllers[1]
      end
  
      def controller_three
        @controllers[2]
      end
  
      def controller_four
        @controllers[3]
      end
  
      def clear
        @mouse.clear
        @keyboard.clear
        @controllers.each(&:clear)
        @touch.clear
        @http_requests.clear
        @finger_one = nil
        @finger_two = nil
      end
  
      def serialize
        {
          controller_one: controller_one.serialize,
          controller_two: controller_two.serialize,
          controller_three: controller_three.serialize,
          controller_four: controller_four.serialize,
          keyboard: keyboard.serialize,
          mouse: mouse.serialize,
          text: text.serialize
        }
      end
  
      def touch_enabled?
        @touch_enabled
      end
    end
  end

#+end_src

** ios_wizard.rb
#+begin_src ruby
  # ./dragon/ios_wizard.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # ios_wizard.rb has been released under MIT (*only this file*).
  
  # Contributors outside of DragonRuby who also hold Copyright: Michał Dudziński
  
  class IOSWizard < Wizard
    def help
      puts <<~S
           * INFO: Help for #{self.class.name}
             Here are the available options for this wizard (these options can be invoked through the DragonRuby Console):
           ** Device
           *** Deploy app to device connected via USB:
               #+begin_src
                 $wizards.ios.start env: :dev
               #+end_src
           ** Simulator
           *** Deploy app to simulator
               The default simulator is iPhone 13 Pro Max and will be automatically installed if it doesn't exist.
               #+begin_src
                 $wizards.ios.start env: :sim
               #+end_src
           *** Deploy app to simulator and specify a device (partial device name allowed):
               #+begin_src
                 $wizards.ios.start env: :sim, sim_name: "iPad Pro"
               #+end_src
           *** Reset simulators
               Delete all content from simulators and reset them
               #+begin_src
                 $wizards.ios.reset_simulators
               #+end_src
           ** Distribution
           *** Package app for production release:
               #+begin_src
                 $wizards.ios.start env: :prod
               #+end_src
           S
    end
  
    def initialize
      @doctor_executed_at = 0
    end
  
    def relative_path
      (File.dirname $gtk.binary_path)
    end
  
    def prerequisite_steps
      [
        :check_for_xcode,
        :check_for_brew,
        :check_for_certs,
      ]
    end
  
    def app_metadata_retrieval_steps
      [
        :determine_team_identifier,
        :determine_app_name,
        :determine_app_id,
      ]
    end
  
    def steps_dev_build
      [
        *prerequisite_steps,
  
        :check_for_device,
        :check_for_dev_profile,
  
        *app_metadata_retrieval_steps,
        :determine_devcert,
  
        :clear_tmp_directory,
        :stage_ios_app,
  
        :development_write_info_plist,
  
        :write_entitlements_plist,
        :compile_icons,
        :clear_payload_directory,
  
        :create_dev_payload_directory,
  
        :create_payload,
        :code_sign_binary,
        :create_ipa,
        :deploy_to_device
      ]
    end
  
    def steps_sim_build
      [
        *prerequisite_steps,
        :install_simulator_if_needed,
  
        :check_for_dev_profile,
  
        *app_metadata_retrieval_steps,
        :determine_devcert,
  
        :clear_tmp_directory,
        :stage_sim_app,
  
        :development_write_info_plist,
  
        :write_entitlements_plist,
        :compile_icons,
        :clear_payload_directory,
  
        :create_sim_payload_directory,
  
        :create_payload,
        :code_sign_binary,
        :create_ipa,
        :deploy_to_sim
      ]
    end
  
    def steps_prod_build
      [
        *prerequisite_steps,
  
        :check_for_distribution_profile,
        :determine_app_version,
  
        *app_metadata_retrieval_steps,
        :determine_prodcert,
  
        :clear_tmp_directory,
        :stage_ios_app,
  
        :production_write_info_plist,
  
        :write_entitlements_plist,
        :compile_icons,
        :clear_payload_directory,
  
        :create_prod_payload_directory,
  
        :create_payload,
        :code_sign_binary,
        :create_ipa,
        :print_publish_help
      ]
    end
  
    def get_reserved_sprite png
      sprite_path = ".dragonruby/sprites/wizards/ios/#{png}"
  
      if !$gtk.ivar :rcb_release_mode
        sprite_path = "deploy_template/#{sprite_path}"
        $gtk.reset_sprite sprite_path
      end
  
      if !$gtk.read_file sprite_path
        log_error "png #{png} not found."
      end
  
      sprite_path
    end
  
    def production_build?
      @build_type == :prod
    end
  
    def dev_build?
      @build_type == :dev || hotload_build?
    end
  
    def sim_build?
      @build_type == :sim
    end
  
    def hotload_build?
      @build_type == :hotload || sim_build?
    end
  
    def start opts = nil
      @opts = opts || {}
  
      if !(@opts.is_a? Hash) || !($gtk.args.fn.eq_any? @opts[:env], :dev, :prod, :hotload, :sim)
        process_wizard_exception WizardException.new(
                                   "* $wizards.ios.start needs to be provided an ~env:~ option.",
                                   "** To deploy your app to an iOS device connected to your computer:\n   $wizards.ios.start env: :dev",
                                   "** To deploy your app with hotloading to an iOS device connected to your computer:\n   $wizards.ios.start env: :hotload",
                                   "** To deploy your app to the iOS Simulator:\n   $wizards.ios.start env: :sim",
                                   "** To deploy your app for sale on the AppStore:\n   $wizards.ios.start env: :prod",
                                   "** For more help type:\n   $wizards.ios.help",
                                 )
      end
  
      @build_type = @opts[:env]
      @certificate_name = nil
      @app_version = opts[:version]
      @app_version = "1.0" if @opts[:env] == :dev && !@app_version
      init_wizard_status
      result = execute_steps get_steps_to_execute
      nil
    end
  
    def always_fail
      return false if $gtk.ivar :rcb_release_mode
      return true
    end
  
    def check_for_xcode
      result = sh "xcrun simctl list devices"
  
      simctl_missing = result.include? "unable to find utility"
  
      if !cli_app_exist?(xcodebuild_cli_app) || simctl_missing
        raise WizardException.new(
          "* You need Xcode to use $wizards.ios.start.",
          { w: 75, h: 75, path: get_reserved_sprite("xcode.png") },
          "** 1. Go to http://developer.apple.com and register.",
          "** 2. Download Xcode 11.3+ from http://developer.apple.com/downloads.",
          "   NOTE: DO NOT install Xcode from the App Store. Use the link above.",
          { w: 700, h: 359, path: get_reserved_sprite("xcode-downloads.png") },
          "** 3. After installing. Open up Xcode to accept the EULA."
        )
      end
  
      :success
    end
  
    def check_for_brew
      if !cli_app_exist?('brew')
        raise WizardException.new(
          "* You need to install Brew.",
          { w: 700, h: 388, path: get_reserved_sprite("brew.png") },
          "** 1. Go to http://brew.sh.",
          "** 2. Copy the command that starts with `/bin/bash -c` on the site.",
          "** 3. Open Terminal and run the command you copied from the website.",
          { w: 700, h: 99, path: get_reserved_sprite("terminal.png") },
        )
      end
  
      :success
    end
  
    def init_wizard_status
      @wizard_status = {}
      get_steps_to_execute.each do |m|
        @wizard_status[m] = { result: :not_started }
      end
  
      previous_step = nil
      next_step = nil
      get_steps_to_execute.each_cons(2) do |current_step, next_step|
        @wizard_status[current_step][:next_step] = next_step
      end
  
      get_steps_to_execute.reverse.each_cons(2) do |current_step, previous_step|
        @wizard_status[current_step][:previous_step] = previous_step
      end
    end
  
    def restart
      init_wizard_status
      start
    end
  
    def reset
      init_wizard_status
    end
  
    def check_for_distribution_profile
      @provisioning_profile_path = "profiles/distribution.mobileprovision"
      if !($gtk.read_file @provisioning_profile_path)
        $gtk.system "mkdir -p #{relative_path}/profiles"
        $gtk.system "open #{relative_path}/profiles"
        $gtk.system "echo Download the mobile provisioning profile and place it here with the name distribution.mobileprovision > #{relative_path}/profiles/README.txt"
        raise WizardException.new(
          "* I didn't find a mobile provision.",
          "** 1. Go to http://developer.apple.com and click \"Certificates, IDs & Profiles\".",
          "** 2. Add an App Identifier.",
          "** 3. Select the App IDs option from the list.",
          { w: 700, h: 75, path: get_reserved_sprite("identifiers.png") },
          "** 4. Add your Device next. You can use idevice_id -l to get the UUID of your device.",
          { w: 365, h: 69, path: get_reserved_sprite("device-link.png") },
          "** 5. Create a Profile. Associate your certs, id, and device.",
          { w: 300, h: 122, path: get_reserved_sprite("profiles.png") },
          "** 6. Download the mobile provision and save it to 'profiles/development.mobileprovision'.",
          { w: 200, h: 124, path: get_reserved_sprite("profiles-folder.png") },
        )
      end
  
      :success
    end
  
    def check_for_dev_profile
      @provisioning_profile_path = "profiles/development.mobileprovision"
      if !($gtk.read_file @provisioning_profile_path)
        $gtk.system "mkdir -p #{relative_path}/profiles"
        $gtk.system "open #{relative_path}/profiles"
        $gtk.system "echo Download the mobile provisioning profile and place it here with the name development.mobileprovision > #{relative_path}/profiles/README.txt"
        raise WizardException.new(
          "* I didn't find a mobile provision.",
          "** 1. Go to http://developer.apple.com and click \"Certificates, IDs & Profiles\".",
          "** 2. Add an App Identifier.",
          "** 3. Select the App IDs option from the list.",
          { w: 700, h: 75, path: get_reserved_sprite("identifiers.png") },
          "** 4. Add your Device next. You can use idevice_id -l to get the UUID of your device.",
          { w: 365, h: 69, path: get_reserved_sprite("device-link.png") },
          "** 5. Create a Profile. Associate your certs, id, and device.",
          { w: 300, h: 122, path: get_reserved_sprite("profiles.png") },
          "** 6. Download the mobile provision and save it to 'profiles/development.mobileprovision'.",
          { w: 200, h: 124, path: get_reserved_sprite("profiles-folder.png") },
        )
      end
  
      :success
    end
  
    def provisioning_profile_path environment
      return "profiles/distribution.mobileprovision" if environment == :prod
      return "profiles/development.mobileprovision"
    end
  
    def ios_metadata_template
      <<-S
  # ios_metadata.txt is used by the Pro version of DragonRuby Game Toolkit to create iOS apps.
  # Information about the Pro version can be found at: http://dragonruby.org/toolkit/game#purchase
  
  # teamid needs to be set to your assigned Team Id which can be found at https://developer.apple.com/account/#/membership/
  teamid=
  # appid needs to be set to your application identifier which can be found at https://developer.apple.com/account/resources/identifiers/list
  appid=
  # appname is the name you want to show up underneath the app icon on the device. Keep it under 10 characters.
  appname=
  # devcert is the certificate to use for development/deploying to your local device. This is the NAME of the certificate as it's displayed in Keychain Access.
  devcert=
  # prodcert is the certificate to use for distribution to the app store. This is the NAME of the certificate as it's displayed in Keychain Access.
  prodcert=
  S
    end
  
    def ios_metadata
      contents = $gtk.read_file 'metadata/ios_metadata.txt'
  
      if !contents
        $gtk.write_file 'metadata/ios_metadata.txt', ios_metadata_template
        contents = $gtk.read_file 'metadata/ios_metadata.txt'
      end
  
      kvps = contents.each_line
                     .reject { |l| l.strip.length == 0 || (l.strip.start_with? "#") }
                     .map do |l|
                       key, value = l.split("=")
                       [key.strip.to_sym, value.strip]
                     end.flatten
      Hash[*kvps]
    end
  
    def game_metadata
      contents = $gtk.read_file 'metadata/game_metadata.txt'
  
      kvps = contents.each_line
                     .reject { |l| l.strip.length == 0 || (l.strip.start_with? "#") }
                     .map do |l|
                       key, value = l.split("=")
                       [key.strip.to_sym, value.strip]
                     end.flatten
      Hash[*kvps]
    end
  
    def raise_ios_metadata_required
      raise WizardException.new(
              "* mygame/metadata/ios_metadata.txt needs to be filled out.",
              "You need to update metadata/ios_metadata.txt with a valid teamid, appname, appid, devcert, and prodcert.",
              "Instructions for where the values should come from are within metadata/ios_metadata.txt."
            )
    end
  
    def determine_team_identifier
      @team_id = (ios_metadata.teamid || "")
      raise_ios_metadata_required if @team_id.strip.length == 0
      log_info "Team Identifer is: #{@team_id}"
      :success
    end
  
    def determine_app_name
      @app_name = (ios_metadata.appname || "")
      raise_ios_metadata_required if @app_name.strip.length == 0
      log_info "App name is: #{@app_name}."
      :success
    end
  
    def provisioning_profile_xml environment
      xml = $gtk.read_file (provisioning_profile_path environment)
      scrubbed = xml.each_line.map do |l|
        if l.strip.start_with? "<"
          if l.start_with? '</plist>'
            '</plist>'
          elsif l.include? "Apple Inc."
            nil
          elsif l.include? '<data>'
            nil
          else
            l
          end
        else
          nil
        end
      end.reject { |l| !l }.join
      $gtk.parse_xml scrubbed
    end
  
    def determine_app_id
      @app_id = ios_metadata.appid
      raise_ios_metadata_required if @app_id.strip.length == 0
      log_info "App Identifier is set to: #{@app_id}"
      :success
    end
  
    def determine_devcert
      @certificate_name = ios_metadata.devcert
      raise_ios_metadata_required if @certificate_name.strip.length == 0
      log_info "Dev Certificate is set to: #{@certificate_name}"
      :success
    end
  
    def determine_prodcert
      @certificate_name = ios_metadata.prodcert
      raise_ios_metadata_required if @certificate_name.strip.length == 0
      log_info "Production (Distribution) Certificate is set to: #{@certificate_name}"
      :success
    end
  
    def set_app_name name
      @app_name = name
      start
    end
  
    def set_dev_profile path
      if !$gtk.read_file path
        log_error "I couldn't find a development profile at #{path}."
        ask_for_dev_profile
      else
        @provisioning_profile_path = path
        start
      end
    end
  
    def clear_tmp_directory
      sh "rm -rf #{tmp_directory}"
      :success
    end
  
    def set_app_id id
      log_info = "App Id set to: #{id}"
      @app_id = id
      start
    end
  
    def check_for_device
      log_info "Looking for device."
  
      if !cli_app_exist?(idevice_id_path)
        raise WizardException.new(
           "* It doesn't look like you have the libimobiledevice iOS protocol library installed.",
           "** 1. Open Terminal.",
           { w: 700, h: 99, path: get_reserved_sprite("terminal.png") },
           "** 2. Run: `brew install libimobiledevice`.",
           { w: 500, h: 93, path: get_reserved_sprite("brew-install-libimobiledevice.png") },
        )
      end
  
      if !cli_app_exist?(ideviceinstaller_cli_app)
        raise WizardException.new(
           "* It doesn't look like you have the libimobiledevice iOS protocol library installed.",
           "** 1. Open Terminal.",
           { w: 700, h: 99, path: get_reserved_sprite("terminal.png") },
           "** 2. Run: `brew install ideviceinstaller`.",
           { w: 500, h: 91, path: get_reserved_sprite("brew-install-ideviceinstaller.png") },
        )
      end
  
      if connected_devices.length == 0
        raise WizardException.new("* I couldn't find any connected devices. Connect your iOS device to your Mac and try again.")
      end
  
      @device_id = connected_devices.first
      log_info "I will be using device with UUID #{@device_id}"
      :success
    end
  
    def check_for_certs
      log_info "Attempting to find certificates on your computer."
  
      if production_build?
        @certificate_name = ios_metadata[:prodcert]
      elsif dev_build?
        @certificate_name = ios_metadata[:devcert]
      else
        raise "I don't know how to ~check_for_certs~ for a build_type/env of #{@build_type}."
      end
  
      log_info "I will be using certificate: '#{@certificate_name}'."
  
      :success
    end
  
    def codesign_allocate_path
      "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate"
    end
  
    def codesign_path
      "/usr/bin/codesign"
    end
  
    def idevice_id_path
      "idevice_id"
    end
  
    def ideviceinstaller_cli_app
      "ideviceinstaller"
    end
  
    def security_cli_app
      "/usr/bin/security"
    end
  
    def xcodebuild_cli_app
      "xcodebuild"
    end
  
    def connected_devices
      sh("idevice_id -l").strip.each_line.map do |l|
        l.strip
      end.reject { |l| l.length == 0 }
    end
  
    def cli_app_exist? app
      `which #{app}`.strip.length != 0
    end
  
    def write_entitlements_plist
      if production_build?
        entitlement_plist_string = <<-XML
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  <plist version="1.0">
          <dict>
                  <key>application-identifier</key>
                  <string>:app_id</string>
                  <key>beta-reports-active</key>
                  <true/>
          </dict>
  </plist>
  XML
      else
        entitlement_plist_string = <<-XML
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  <plist version="1.0">
          <dict>
                  <key>application-identifier</key>
                  <string>:app_id</string>
                  <key>get-task-allow</key>
                  <true/>
          </dict>
  </plist>
  XML
      end
  
      log_info "Creating Entitlements.plist"
  
      $gtk.write_file_root "tmp/ios/Entitlements.plist", entitlement_plist_string.gsub(":app_id", "#{@team_id}.#{@app_id}").strip
      $gtk.write_file_root "tmp/ios/Entitlements.txt", entitlement_plist_string.gsub(":app_id", "#{@team_id}.#{@app_id}").strip
  
      sh "/usr/bin/plutil -convert binary1 \"#{tmp_directory}/Entitlements.plist\""
      sh "/usr/bin/plutil -convert xml1 \"#{tmp_directory}/Entitlements.plist\""
  
      @entitlement_plist_written = true
      :success
    end
  
    def code_sign_binary
      log_info "Signing app with #{@certificate_name}."
  
      sh "xattr -cr \"#{tmp_directory}/ipa_root/Payload/#{@app_name}.app\""
      sh "CODESIGN_ALLOCATE=\"/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate\" /usr/bin/codesign -f -s \"#{@certificate_name}\" --entitlements #{tmp_directory}/Entitlements.plist \"#{tmp_directory}/ipa_root/Payload/#{@app_name}.app\""
  
      sh "xattr -cr \"#{tmp_directory}/ipa_root/Payload/#{@app_name}.app/#{@app_name}\""
      sh "CODESIGN_ALLOCATE=\"/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate\" /usr/bin/codesign -f -s \"#{@certificate_name}\" --entitlements #{tmp_directory}/Entitlements.plist \"#{tmp_directory}/ipa_root/Payload/#{@app_name}.app/#{@app_name}\""
  
      @code_sign_completed = true
      :success
    end
  
    def __get_plist_orientation_value__
      orientation_string = "UIInterfaceOrientationLandscapeRight"
  
      if $gtk.orientation == :portrait
        orientation_string = "UIInterfaceOrientationPortrait"
      end
  
      orientation_string
    end
  
    def development_write_info_plist
      log_info "Adding Info.plist."
  
  
      info_plist_string = <<-XML
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  <plist version="1.0">
  <dict>
          <key>BuildMachineOSBuild</key>
          <string>20D91</string>
          <key>CFBundleDevelopmentRegion</key>
          <string>en</string>
          <key>CFBundleDisplayName</key>
          <string>:app_name</string>
          <key>CFBundleExecutable</key>
          <string>:app_name</string>
          <key>NSAppTransportSecurity</key>
          <dict>
            <key>NSAllowsArbitraryLoads</key>
            <true/>
          </dict>        <key>CFBundleIconFiles</key>
          <array>
                  <string>AppIcon60x60</string>
          </array>
          <key>CFBundleIcons</key>
          <dict>
                  <key>CFBundlePrimaryIcon</key>
                  <dict>
                          <key>CFBundleIconFiles</key>
                          <array>
                                  <string>AppIcon60x60</string>
                          </array>
                          <key>CFBundleIconName</key>
                          <string>AppIcon</string>
                  </dict>
          </dict>
          <key>CFBundleIcons~ipad</key>
          <dict>
                  <key>CFBundlePrimaryIcon</key>
                  <dict>
                          <key>CFBundleIconFiles</key>
                          <array>
                                  <string>AppIcon60x60</string>
                                  <string>AppIcon76x76</string>
                                  <string>AppIcon83.5x83.5</string>
                          </array>
                          <key>CFBundleIconName</key>
                          <string>AppIcon</string>
                  </dict>
          </dict>
          <key>CFBundleIdentifier</key>
          <string>:app_id</string>
          <key>CFBundleInfoDictionaryVersion</key>
          <string>:app_version</string>
          <key>CFBundleName</key>
          <string>:app_name</string>
          <key>CFBundlePackageType</key>
          <string>APPL</string>
          <key>CFBundleShortVersionString</key>
          <string>:app_version</string>
          <key>CFBundleSignature</key>
          <string>????</string>
          <key>CFBundleSupportedPlatforms</key>
          <array>
                  <string>iPhoneOS</string>
          </array>
          <key>CFBundleVersion</key>
          <string>:app_version</string>
          <key>DTCompiler</key>
          <string>com.apple.compilers.llvm.clang.1_0</string>
          <key>DTPlatformBuild</key>
          <string>18D46</string>
          <key>DTPlatformName</key>
          <string>iphoneos</string>
          <key>DTPlatformVersion</key>
          <string>11.0</string>
          <key>DTSDKBuild</key>
          <string>18D46</string>
          <key>DTSDKName</key>
          <string>iphoneos14.4</string>
          <key>DTXcode</key>
          <string>0124</string>
          <key>DTXcodeBuild</key>
          <string>12D4e</string>
          <key>MinimumOSVersion</key>
          <string>11.0</string>
          <key>UIAppFonts</key>
          <array/>
          <key>UIBackgroundModes</key>
          <array/>
          <key>UIDeviceFamily</key>
          <array>
                  <integer>1</integer>
                  <integer>2</integer>
          </array>
          <key>UILaunchStoryboardName</key>
          <string>SimpleSplash</string>
          <key>UIRequiredDeviceCapabilities</key>
          <array>
                  <string>arm64</string>
          </array>
          <key>UIRequiresFullScreen</key>
          <true/>
          <key>UIStatusBarStyle</key>
          <string>UIStatusBarStyleDefault</string>
          <key>UISupportedInterfaceOrientations</key>
          <array>
                  <string>#{__get_plist_orientation_value__}</string>
          </array>
  </dict>
  </plist>
  XML
  
      # <string>UIInterfaceOrientationPortrait</string>
      # <string>UIInterfaceOrientationLandscapeRight</string>
  
      info_plist_string.gsub!(":app_name", @app_name)
      info_plist_string.gsub!(":app_id", @app_id)
  
      $gtk.write_file_root "tmp/ios/#{@app_name}.app/Info.plist", info_plist_string.strip
      $gtk.write_file_root "tmp/ios/Info.txt", info_plist_string.strip
  
      @info_plist_written = true
      :success
    end
  
    def production_write_info_plist
      log_info "Adding Info.plist."
  
      info_plist_string = <<-XML
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  <plist version="1.0">
  <dict>
          <key>BuildMachineOSBuild</key>
          <string>20D91</string>
          <key>CFBundleDevelopmentRegion</key>
          <string>en</string>
          <key>CFBundleDisplayName</key>
          <string>:app_name</string>
          <key>CFBundleExecutable</key>
          <string>:app_name</string>
          <key>CFBundleIconFiles</key>
          <array>
                  <string>AppIcon60x60</string>
          </array>
          <key>CFBundleIcons</key>
          <dict>
                  <key>CFBundlePrimaryIcon</key>
                  <dict>
                          <key>CFBundleIconFiles</key>
                          <array>
                                  <string>AppIcon60x60</string>
                          </array>
                          <key>CFBundleIconName</key>
                          <string>AppIcon</string>
                  </dict>
          </dict>
          <key>CFBundleIcons~ipad</key>
          <dict>
                  <key>CFBundlePrimaryIcon</key>
                  <dict>
                          <key>CFBundleIconFiles</key>
                          <array>
                                  <string>AppIcon60x60</string>
                                  <string>AppIcon76x76</string>
                                  <string>AppIcon83.5x83.5</string>
                          </array>
                          <key>CFBundleIconName</key>
                          <string>AppIcon</string>
                  </dict>
          </dict>
          <key>CFBundleIdentifier</key>
          <string>:app_id</string>
          <key>CFBundleInfoDictionaryVersion</key>
          <string>:app_version</string>
          <key>CFBundleName</key>
          <string>:app_name</string>
          <key>CFBundlePackageType</key>
          <string>APPL</string>
          <key>CFBundleShortVersionString</key>
          <string>:app_version</string>
          <key>CFBundleSignature</key>
          <string>????</string>
          <key>CFBundleSupportedPlatforms</key>
          <array>
                  <string>iPhoneOS</string>
          </array>
          <key>CFBundleVersion</key>
          <string>:app_version</string>
          <key>DTCompiler</key>
          <string>com.apple.compilers.llvm.clang.1_0</string>
          <key>DTPlatformBuild</key>
          <string>18D46</string>
          <key>DTPlatformName</key>
          <string>iphoneos</string>
          <key>DTPlatformVersion</key>
          <string>14.4</string>
          <key>DTSDKBuild</key>
          <string>18D46</string>
          <key>DTSDKName</key>
          <string>iphoneos14.4</string>
          <key>DTXcode</key>
          <string>0124</string>
          <key>DTXcodeBuild</key>
          <string>12D4e</string>
          <key>MinimumOSVersion</key>
          <string>11.0</string>
          <key>UIAppFonts</key>
          <array/>
          <key>UIBackgroundModes</key>
          <array/>
          <key>UIDeviceFamily</key>
          <array>
                  <integer>1</integer>
                  <integer>2</integer>
          </array>
          <key>UILaunchStoryboardName</key>
          <string>SimpleSplash</string>
          <key>UIRequiredDeviceCapabilities</key>
          <array>
                  <string>arm64</string>
          </array>
          <key>UIRequiresFullScreen</key>
          <true/>
          <key>UIStatusBarStyle</key>
          <string>UIStatusBarStyleDefault</string>
          <key>UISupportedInterfaceOrientations</key>
          <array>
                  <string>#{__get_plist_orientation_value__}</string>
          </array>
  </dict>
  </plist>
  XML
  
      # <string>UIInterfaceOrientationPortrait</string>
      # <string>UIInterfaceOrientationLandscapeRight</string>
  
      info_plist_string.gsub!(":app_name", @app_name)
      info_plist_string.gsub!(":app_id", @app_id)
      info_plist_string.gsub!(":app_version", @app_version)
  
      $gtk.write_file_root "tmp/ios/#{@app_name}.app/Info.plist", info_plist_string.strip
      $gtk.write_file_root "tmp/ios/Info.txt", info_plist_string.strip
  
      @info_plist_written = true
      :success
    end
  
    def device_orientation_xml
      return "UIInterfaceOrientationLandscapeRight" if $gtk.logical_width > $gtk.logical_height
      return "UIInterfaceOrientationPortrait"
    end
  
    def tmp_directory
      "#{relative_path}/tmp/ios"
    end
  
    def app_path
      "#{tmp_directory}/#{@app_name}.app"
    end
  
    def root_folder
      "#{relative_path}/#{$gtk.cli_arguments[:dragonruby]}"
    end
  
    def embed_mobileprovision
      sh %Q[cp #{@provisioning_profile_path} "#{app_path}/embedded.mobileprovision"]
      sh %Q[/usr/bin/plutil -convert binary1 "#{app_path}/Info.plist"]
      :success
    end
  
    def clear_payload_directory
      sh %Q[rm "#{@app_name}".ipa]
      sh %Q[rm -rf "#{app_path}/app"]
      sh %Q[rm -rf "#{app_path}/sounds"]
      sh %Q[rm -rf "#{app_path}/sprites"]
      sh %Q[rm -rf "#{app_path}/data"]
      sh %Q[rm -rf "#{app_path}/fonts"]
      sh %Q[rm -rf "#{app_path}/metadata"]
      :success
    end
  
    def stage_ios_app
      log_info "Staging."
      sh "mkdir -p #{tmp_directory}"
      sh "cp -R #{relative_path}/dragonruby-ios.app/ \"#{tmp_directory}/#{@app_name}.app/\""
      sh "mv \"#{tmp_directory}/#{@app_name}.app/Runtime\" \"#{tmp_directory}/#{@app_name}.app/#{@app_name}\""
      sh %Q[cp -r "#{root_folder}/app/" "#{app_path}/app/"]
      sh %Q[cp -r "#{root_folder}/sounds/" "#{app_path}/sounds/"]
      sh %Q[cp -r "#{root_folder}/sprites/" "#{app_path}/sprites/"]
      sh %Q[cp -r "#{root_folder}/data/" "#{app_path}/data/"]
      sh %Q[cp -r "#{root_folder}/fonts/" "#{app_path}/fonts/"]
      sh %Q[cp -r "#{root_folder}/metadata/" "#{app_path}/metadata/"]
      :success
    end
  
    def stage_sim_app
      log_info "Staging."
      sh "codesign --remove-signature #{relative_path}/dragonruby-ios-simulator.app/Runtime"
      sh "mkdir -p #{tmp_directory}"
      sh "cp -R #{relative_path}/dragonruby-ios-simulator.app/ \"#{tmp_directory}/#{@app_name}.app/\""
      sh "mv \"#{tmp_directory}/#{@app_name}.app/Runtime\" \"#{tmp_directory}/#{@app_name}.app/#{@app_name}\""
      sh %Q[cp -r "#{root_folder}/app/" "#{app_path}/app/"]
      sh %Q[cp -r "#{root_folder}/sounds/" "#{app_path}/sounds/"]
      sh %Q[cp -r "#{root_folder}/sprites/" "#{app_path}/sprites/"]
      sh %Q[cp -r "#{root_folder}/data/" "#{app_path}/data/"]
      sh %Q[cp -r "#{root_folder}/fonts/" "#{app_path}/fonts/"]
      sh %Q[cp -r "#{root_folder}/metadata/" "#{app_path}/metadata/"]
      :success
    end
  
    def create_payload
      sh %Q[mkdir -p #{tmp_directory}/ipa_root/Payload]
      sh %Q[cp -r "#{app_path}" "#{tmp_directory}/ipa_root/Payload"]
      sh %Q[chmod -R 755 "#{tmp_directory}/ipa_root/Payload"]
      :success
    end
  
    def write_server_ip_address
      sh %Q[mkdir -p "#{app_path}/metadata/"]
      sh %Q[echo #{$gtk.ffi_misc.get_local_ip_address.strip}]
      sh %Q[echo #{$gtk.ffi_misc.get_local_ip_address.strip} > "#{app_path}/metadata/DRAGONRUBY_REMOTE_HOTLOAD"]
      :success
    end
  
    def create_dev_payload_directory
      embed_mobileprovision
      clear_payload_directory
      stage_ios_app
      # write dev machine's ip address for hotloading
      write_server_ip_address if hotload_build?
  
      # production build marker
      sh %Q[mkdir -p "#{app_path}/metadata/"]
      sh %Q[touch "#{app_path}/metadata/DRAGONRUBY_PRODUCTION_BUILD"]
      :success
    end
  
    def create_prod_payload_directory
      # production builds does not hotload ip address
      sh %Q[rm "#{root_folder}/app/server_ip_address.txt"]
  
      embed_mobileprovision
      stage_ios_app
  
      # production build marker
      sh %Q[mkdir -p "#{app_path}/metadata/"]
      sh %Q[touch "#{app_path}/metadata/DRAGONRUBY_PRODUCTION_BUILD"]
      :success
    end
  
    def create_sim_payload_directory
      embed_mobileprovision
      clear_payload_directory
      stage_sim_app
      write_server_ip_address
  
      # production build marker
      sh %Q[mkdir -p "#{app_path}/metadata/"]
      sh %Q[touch "#{app_path}/metadata/DRAGONRUBY_PRODUCTION_BUILD"]
      :success
    end
  
    def create_ipa
      do_zip
      sh "cp \"#{tmp_directory}/ipa_root/archive.zip\" \"#{tmp_directory}/#{@app_name}.ipa\""
      :success
    end
  
    def do_zip
      $gtk.write_file_root "tmp/ios/do_zip.sh", <<-SCRIPT
  pushd #{tmp_directory}/ipa_root/
  zip -q -r archive.zip Payload
  popd
  SCRIPT
  
      :success
      sh "sh #{tmp_directory}/do_zip.sh"
    end
  
    def sh cmd
      log_info cmd.strip
      result = `#{cmd} 2>&1`
      if result.strip.length > 0
        log_info result.strip.each_line.map(&:strip).join("\n")
      end
      result
    end
  
    def deploy_to_device
      sh "ideviceinstaller --uninstall #{@app_id}"
      sh "ideviceinstaller -i \"#{tmp_directory}/#{@app_name}.ipa\""
      log_info "Check your device!!"
      :success
    end
  
    def simctl_list_devices
      output = sh "xcrun simctl list devices"
  
      # get only installed devices
      output = output.split("-- Unavailable").first
  
      devices = {}
      current_version_number_string = nil
      output.each_line do |l|
        if l.start_with? "-- iOS"
          current_version_number_string = l.strip.gsub("-- iOS ", "").gsub(" --", "")
        else
          tokens = l.gsub("(Booted)", "")
                    .gsub("(Shutdown)", "")
                    .strip.split(" (")
  
          device_name = tokens.first.strip
          device_id = tokens.last.gsub(")", "").strip
          device_name_2 = if tokens.length <= 2
                            ""
                          else
                            tokens[1].gsub(")", "").strip
                          end
  
          if !device_id.include? "Devices"
            devices[device_id] = {
              name: device_name,
              name_2: device_name_2,
              version_string: current_version_number_string,
              version_number: current_version_number_string.split(".").map(&:to_i),
              id: device_id
            }
          end
        end
      end
  
      devices
    end
  
    def install_simulator_if_needed
      results = sh "xcrun simctl list devices"
      results = results.split("== Devices ==").last
      iphone_13_pro_max_line = results.split("\n").find { |line| line.include? "iPhone 13 Pro Max" }
      if iphone_13_pro_max_line && iphone_13_pro_max_line.include?("unavailable")
        iphone_13_pro_max_line = nil
      end
  
      if !iphone_13_pro_max_line
        puts "* INFO: Installing iPhone 13 Pro Max simulator..."
        install_command =  "xcrun simctl create \"iPhone 13 Pro Max\" com.apple.CoreSimulator.SimDeviceType.iPhone-13-Pro-Max"
        results = sh install_command
        if results.include? "Could not find an"
          raise WizardException.new(
            "* ERROR: Unable to install simulator a default simulator.",
            "** Please run the following command in your terminal:",
            "",
            "     xcodebuild -downloadPlatform iOS",
            ""
          )
        end
      end
  
      :success
    end
  
    def simctl_list_devices_max_version
      devices = simctl_list_devices
      max_version_number = devices.map { |k, v| v.version_number }.max
      max_version_number_string = max_version_number.join(".")
      devices.reject! { |k, v| v.version_string != max_version_number_string }
      devices
    end
  
    def simctl_iphone_device_id_max_version
      devices = simctl_list_devices_max_version
      k, v = devices.find { |k, v| v.name.include?("iPhone") && !v.name.include?("SE") }
      k
    end
  
    def simctl_iphone_device_id_by_name
      devices = simctl_list_devices
      k, v = devices.find { |k, v| v.name.downcase.include?(@opts[:sim_name].downcase) }
      k
    end
  
    def deploy_to_sim
      device_id = nil
      if @opts[:sim_name]
        device_id = simctl_iphone_device_id_by_name
        if !device_id
          $console.set_command "$wizards.ios.start env: :#{@opts[:env]}, sim_name: \"#{@opts[:sim_name]}\""
          raise WizardException.new(
            "* Unable to find simulator named '#{@opts[:sim_name]}'.",
            "** The name must (at least partially) match the name of an existing simulator.",
            "** Open your iOS simulator and check File > Open Simulator to see the options."
          )
        end
      else
        device_id = simctl_iphone_device_id_max_version
      end
  
      sh "xcrun simctl boot #{device_id}"
      sh "open -a Simulator"
      sh "xcrun simctl uninstall #{device_id} #{@app_id}"
      sh "xcrun simctl install #{device_id} \"#{tmp_directory}/#{@app_name}.app\""
      sh "xcrun simctl launch #{device_id} #{@app_id}"
      puts "Check your simulator!!\nYou can use cmd+left/right arrow to rotate the device."
      :success
    end
  
    def print_publish_help
      has_transporter = (sh "ls /Applications/Transporter.app").include? "Contents"
      if !has_transporter
        $gtk.openurl "https://apps.apple.com/us/app/transporter/id1450874784?mt=12"
        $console.set_command "$wizards.ios.start env: :#{@opts[:env]}, version: \"#{@opts[:version]}\""
        raise WizardException.new(
          "* To upload your app, Download Transporter from the App Store https://apps.apple.com/us/app/transporter/id1450874784?mt=12."
        )
      else
        sh "mkdir ./tmp/ios/intermediary_artifacts"
        sh "mv \"#{tmp_directory}/#{@app_name}.app\" #{tmp_directory}/intermediary_artifacts/"
        sh "mv \"#{tmp_directory}/do_zip.sh\" #{tmp_directory}/intermediary_artifacts"
        sh "mv \"#{tmp_directory}/Entitlements.plist\" #{tmp_directory}/intermediary_artifacts"
        sh "mv \"#{tmp_directory}/ipa_root\" #{tmp_directory}/intermediary_artifacts/"
        sh "open /Applications/Transporter.app"
        sh "open ./tmp/ios/"
      end
  
      :success
    end
  
    def compile_icons
      cmd = <<-S
  "/Applications/Xcode.app/Contents/Developer/usr/bin/actool" --output-format human-readable-text \\
                                                              --notices --warnings --platform iphoneos \\
                                                              --minimum-deployment-target 10.3 \\
                                                              --target-device iphone \\
                                                              --target-device ipad  --app-icon 'AppIcon' \\
                                                              --output-partial-info-plist '#{app_path}/AssetCatalog-Info.plist' \\
                                                              --compress-pngs --compile "#{app_path}" \\
                                                              "#{app_path}/Assets.xcassets"
  S
      sh cmd
      :success
    end
  
    def stage_native_libs
      sh "cp -r \"#{root_folder}/native/\" \"#{app_path}/native/\""
      sh "CODESIGN_ALLOCATE=\"/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate\" /usr/bin/codesign -f -s \"#{@certificate_name}\" --entitlements #{tmp_directory}/Entitlements.plist \"#{tmp_directory}/#{@app_name}.app/native/ios-device/ext.dylib\""
    end
  
    def set_version version
      @app_version = version
      start env: @opts[:env], version: version
    end
  
    def app_name
      @app_name
    end
  
    def app_version
      log_info "Attempting to retrieve App Version from metadata/ios_metadata.txt."
      ios_version_number = (ios_metadata.version || "").strip
      if ios_version_number.length == 0
        log_info "Not found. Attempting to retrieve App Version from metadata/game_metadata.txt."
        ios_version_number = (game_metadata.version || "").strip
      end
      ios_version_number
    end
  
    def determine_app_version
      @app_version = app_version
      return :success if @app_version
    end
  
    def certificate_name
      @certificate_name
    end
  
    def display_name
      "iOS Wizard"
    end
  
    def reset_simulators
      sh "killall \"Simulator\" 2> /dev/null"
      sh "xcrun simctl delete unavailable"
      sh "xcrun simctl shutdown all"
      sh "xcrun simctl erase all"
    end
  
    def get_steps_to_execute
      if sim_build?
        steps_sim_build
      elsif dev_build?
        steps_dev_build
      elsif production_build?
        steps_prod_build
      else
        []
      end
    end
  end

#+end_src

** itch_wizard.rb
#+begin_src ruby
  # ./dragon/itch_wizard.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # itch_wizard.rb has been released under MIT (*only this file*).
  
  class ItchWizard < Wizard
    def help
      puts <<~S
           * INFO: Help for #{self.class.name}
           To run this wizard, type the following into the DragonRuby Console:
  
             $wizards.itch.start
  
           S
    end
  
    def itch_steps
      [
        :check_metadata
      ]
    end
  
    def write_blank_metadata
        $gtk.write_file metadata_file_path, <<-S.strip
  #devid=myname
  #devtitle=My Name
  #gameid=mygame
  #gametitle=My Game
  #version=0.1
  #icon=metadata/icon.png
  S
    end
  
    def check_metadata
      metadata_text = $gtk.read_file metadata_file_path
      if !metadata_text
        write_blank_metadata
      end
  
      if metadata_text.strip.each_line.to_a.length < 6
        write_blank_metadata
      end
  
      log "* INFO: Contents of #{metadata_file_path}:"
      log "#+begin_src txt"
      metadata_text.each_line { |l| log "  #{l}" }
      log "#+end_src"
      metadata = get_metadata
  
      if metadata[:devid].start_with?("#") || !@devid
        log "* PROMPT: Please provide your username for Itch."
        $console.set_command "$wizards.itch.set_devid \"#{metadata[:devid]}\""
        return :need_devid
      end
  
      if metadata[:devtitle].start_with?("#") || !@devtitle
        log "* PROMPT: Please provide developer's/company's name that you want displayed."
        $console.set_command "$wizards.itch.set_devtitle \"#{metadata[:devtitle]}\""
        return :need_devtitle
      end
  
      if metadata[:gameid].start_with?("#") || !@gameid
        log "* PROMPT: Please provide the id for you game. This is the id you specified when you set up a new game page on Itch."
        $console.set_command "$wizards.itch.set_gameid \"#{metadata[:gameid]}\""
        return :need_gameid
      end
  
      if metadata[:gametitle].start_with?("#") || !@gametitle
        log "* PROMPT: Please provide the display name for your game. (This can include spaces)"
        $console.set_command "$wizards.itch.set_gametitle \"#{metadata[:gametitle]}\""
        return :need_gametitle
      end
  
      if metadata[:version].start_with?("#") || !@version
        log "* PROMPT: Please provide the version for your game."
        $console.set_command "$wizards.itch.set_version \"#{metadata[:version]}\""
        return :need_version
      end
  
      if metadata[:icon].start_with?("#") || !@icon
        log "* PROMPT: Please provide icon path for your game."
        $console.set_command "$wizards.itch.set_icon \"#{metadata[:icon]}\""
        return :need_icon
      end
  
      return :success
    end
  
    def set_devid value
      @devid = value
      start
    end
  
    def set_devtitle value
      @devtitle = value
      start
    end
  
    def set_gameid value
      @gameid = value
      start
    end
  
    def set_gametitle value
      @gametitle = value
      start
    end
  
    def set_version value
      @version = value
      start
    end
  
    def set_icon value
      @icon = value
      write_metadata
      deploy
      reset
      $console.set_command "$wizards.itch.start"
    end
  
    def write_metadata
      text = ""
      if @devid
        text += "devid=#{@devid}\n"
      else
        text += "#devid=myname\n"
      end
  
      if @devtitle
        text += "devtitle=#{@devtitle}\n"
      else
        text += "#devtitle=My Name\n"
      end
  
      if @gameid
        text += "gameid=#{@gameid}\n"
      else
        text += "#gameid=gameid\n"
      end
  
      if @gametitle
        text += "gametitle=#{@gametitle}\n"
      else
        text += "#gametitle=Game Name\n"
      end
  
      if @version
        text += "version=#{@version}\n"
      else
        text += "#version=0.1\n"
      end
  
      if @icon
        text += "icon=#{@icon}\n"
      else
        text += "#icon=metadata/icon.png\n"
      end
  
      $gtk.write_file metadata_file_path, text
    end
  
    def relative_path
      (File.dirname $gtk.binary_path)
    end
  
    def package_command
      "#{File.join $gtk.get_base_dir, 'dragonruby-publish'}"
    end
  
    def deploy
      log_info "* Running dragonruby-publish: #{package_command}"
      $gtk.openurl "http://itch.io/dashboard" if $gtk.platform == "Mac OS X"
      if $gtk.platform? :mac
        $gtk.exec "rm -rf ./builds"
      end
      results = $gtk.exec "#{package_command} --only-package"
      puts File.expand_path("./builds")
  
      log "#+begin_src"
      log results
      log "#+end_src"
  
      if $gtk.platform? :mac
        $gtk.exec "open ./builds/"
      elsif $gtk.platform? :windows
        $gtk.exec "powershell \"ii .\""
      end
  
      $gtk.openurl "https://itch.io/dashboard"
  
      puts "* INFO: Builds for your game are located within the =./builds= directory."
  
      :success
    end
  
    def start
      execute_steps itch_steps
      nil
    end
  
    def reset
      @devid = nil
      @devtitle = nil
      @gameid = nil
      @gametitle = nil
      @version = nil
      @icon = nil
      init_wizard_status
    end
  
    def restart
      reset
      start
    end
  
    def initialize
      reset
    end
  
    def init_wizard_status
      @wizard_status = {}
  
      itch_steps.each do |m|
        @wizard_status[m] = { result: :not_started }
      end
  
      previous_step = nil
      next_step = nil
  
      itch_steps.each_cons(2) do |current_step, next_step|
        @wizard_status[current_step][:next_step] = next_step
      end
  
      itch_steps.reverse.each_cons(2) do |current_step, previous_step|
        @wizard_status[current_step][:previous_step] = previous_step
      end
    end
  
    def display_name
      "Itch Wizard"
    end
  end

#+end_src

** layout.rb
#+begin_src ruby
  # ./dragon/layout.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # layout.rb has been released under MIT (*only this file*).
  
  module GTK
    class Layout
      attr :w, :h, :ratio_w, :ratio_h, :orientation,
           :gutter_left, :gutter_right, :gutter_top, :gutter_bottom,
           :cell_size, :gutter
  
      def initialize w, h, ratio_w, ratio_h, orientation
        @w = w
        @h = h
        @ratio_w = ratio_w
        @ratio_h = ratio_h
        @orientation = orientation
        initialize_gutters
      end
  
      def initialize_gutters
        @gutter_left   = 18
        @gutter_right  = 18
        @gutter_top    = 47
        @gutter_bottom = 52
        @cell_size     = 48
        @gutter        = 4
        @row_count     = 12
        @col_count     = 24
  
        if @orientation == :portrait
          @gutter_left   = 50
          @gutter_right  = 50
          @gutter_top    = 15
          @gutter_bottom = 15
          @cell_size     = 48
          @gutter        = 4
          @row_count     = 24
          @col_count     = 12
        end
      end
  
      def rect *all_opts
        opts = {}
  
        if all_opts.length == 1
          opts = all_opts.first
        else
          opts = {}
          all_opts.each do |o|
            opts.merge! o
          end
        end
  
        opts_col        = opts[:col] || 0
        opts_row        = opts[:row] || 0
        opts_row        = row_max_index - opts[:row_from_bottom] if opts[:row_from_bottom]
        opts_col        = col_max_index - opts[:col_from_right] if opts[:col_from_right]
        opts_w          = opts[:w]   || 1
        opts_h          = opts[:h]   || 1
        opts_max_height = opts[:max_height] || opts_h
        opts_max_width  = opts[:max_width] || opts_w
        opts_dx         = opts[:dx] || 0
        opts_dy         = opts[:dy] || 0
  
        opts_h = opts[:max_height] if opts_h > opts_max_height
        opts_w = opts[:max_width]  if opts_w > opts_max_width
  
        rect_x = @gutter_left + @gutter * opts_col + @cell_size * opts_col
        rect_y = @h - @gutter_top - (@gutter * opts_row) - (@cell_size * opts_row) - (@cell_size * opts_h) - (@gutter * opts_h - 1)
        rect_w = @gutter * (opts_w - 1) + (@cell_size * opts_w)
        rect_h = @gutter * (opts_h - 1) + (@cell_size * opts_h)
        rect_x += opts_dx
        rect_y += opts_dy
  
        if opts[:include_row_gutter]
          rect_x -= @gutter
          rect_w += @gutter * 2
        end
  
        if opts[:include_col_gutter]
          rect_y -= @gutter
          rect_h += @gutter * 2
        end
  
        rect_w = 0 if rect_w < 0
        rect_h = 0 if rect_h < 0
  
        center_x = rect_x + rect_w / 2
        center_y = rect_y + rect_h / 2
  
        result = {
          x: rect_x,
          y: rect_y,
          w: rect_w,
          h: rect_h,
          center_x: center_x,
          center_y: center_y,
          center: { x: center_x, y: center_y }
        }
  
        result.merge! opts[:merge] if opts[:merge]
        result
      end
  
      def font_relative_size_enum size_enum
        base_line_logical = 22
        base_line_actual = font_size_med
        target_logical = size_enum
        target_logical = 1 if target_logical <= 0
        (base_line_actual / base_line_logical) * target_logical
      end
  
      def font_px_to_pt px
        (px / 1.33333).floor
      end
  
      def font_pt_to_px pt
        pt * 1.333333
      end
  
      def font_size_cell
        (cell_height / 1.33333)
      end
  
      def font_size_xl
        font_size_cell
      end
  
      def font_size_lg
        font_size_cell * 0.8
      end
  
      def font_size_med
        font_size_cell * 0.7
      end
  
      def font_size_sm
        font_size_cell * 0.6
      end
  
      def font_size_xs
        font_size_cell * 0.5
      end
  
      def font_size
        font_size_cell * 0.7
      end
  
      def logical_rect
        @logical_rect ||= { x: 0,
                            y: 0,
                            w: @w,
                            h: @h }
      end
  
      def safe_rect
        @safe_rect ||= { x: 0,
                         y: 0,
                         w: @w,
                         h: @h }
      end
  
      def control_rect
        @control_rect ||= { x: @gutter_left,
                            y: @gutter_bottom,
                            w: @w - @gutter_left - @gutter_right,
                            h: @h - @gutter_top - @gutter_buttom }
      end
  
      def row_count
        @row_count
      end
  
      def row_max_index
        row_count - 1
      end
  
      def col_count
        @col_count
      end
  
      def col_max_index
        col_count - 1
      end
  
      def gutter_height
        @gutter
      end
  
      def gutter_width
        @gutter
      end
  
      def outer_gutter
        @gutter_left
      end
  
      def cell_height
        @cell_size
      end
  
      def cell_width
        @cell_size
      end
  
      def rect_defaults
        {
          row:      nil,
          col:      nil,
          h:        1,
          w:        1,
          dx:       0,
          dx_ratio: 1,
          dy:       0,
          dy_ratio: 1,
          dh_ratio: 1,
          dw_ratio: 1,
          merge:    nil,
          rect:     :control_rect
        }
      end
  
      def row n
        (rect row: n, col: 0, w: 0, h: 0).x
      end
  
      def row_from_bottom n
        (rect row: row_count - n, col: 0, w: 0, h: 0).x
      end
  
      def col n
        (rect row: 0, col: n, w: 0, h: 0).y
      end
  
      def col_from_right n
        (rect row: 0, col: col_max_index - n, w: 0, h: 0).y
      end
  
      def w n
        (rect row: 0, col: 0, w: n, h: 1).w
      end
  
      def h n
        (rect row: 0, col: 0, w: 1, h: n).h
      end
  
      def rect_group opts
        group = opts.group
        r     = opts.row || 0
        r     = row_max_index - opts.row_from_bottom if opts.row_from_bottom
        c     = opts.col || 0
        c     = col_max_index - opts.col_from_right  if opts.col_from_right
        drow  = opts.drow || 0
        dcol  = opts.dcol || 0
        w     = opts.w    || 0
        h     = opts.h    || 0
        merge = opts[:merge]
  
        running_row = r
        running_col = c
  
        running_col = calc_col_offset(opts.col_offset) if opts.col_offset
        running_row = calc_row_offset(opts.row_offset) if opts.row_offset
  
        group.map do |i|
          group_layout_opts = i.layout || {}
          group_layout_opts = group_layout_opts.merge row: running_row,
                                                      col: running_col,
                                                      merge: merge,
                                                      w: w, h: h
          result = (rect group_layout_opts).merge i
  
          if (i.is_a? Hash) && (i.primitive_marker == :label)
            if    i.alignment_enum == 1
              result.x += result.w.half
            elsif i.alignment_enum == 2
              result.x += result.w
            end
          end
  
          running_row += drow
          running_col += dcol
          result
        end
      end
  
      def calc_row_offset opts = {}
        count = opts[:count] || opts[:length] || 0
        h     = opts.h || 1
        (row_count - (count * h)) / 2.0
      end
  
      def calc_col_offset opts = {}
        count = opts[:count] || opts[:length] || 0
        w     = opts.w || 1
        (col_count - (count * w)) / 2.0
      end
  
      def point opts = {}
        opts.w = 1
        opts.h = 1
        opts.row ||= 0
        opts.col ||= 0
        r = rect opts
        r.x  += r.w * opts.col_anchor if opts.col_anchor
        r.y  += r.h * opts.row_anchor if opts.row_anchor
        r
      end
  
      def rect_center reference, target
        delta_x = (reference.w - target.w).fdiv 2
        delta_y = (reference.h - target.h).fdiv 2
        { x: target.x - delta_x, y: target.y - delta_y, w: reference.w, h: reference.h }
      end
  
      def debug_primitives opts = {}
        row_count_rework = 12
        col_count_rework = 24
  
        if @orientation == :portrait
          row_count_rework = 24
          col_count_rework = 12
        end
  
        if !@debug_primitives
          single_cell = rect row: row_count_rework - 1, col: 0, w: 1, h: 1
          double_cell = rect row: row_count_rework - 1, col: 0, w: 2, h: 2
          single_row = rect row: 0, col: 0, w: col_count_rework, h: 1
          single_col = rect row: 0, col: 0, w: 1, h: row_count_rework
          safe_area = rect row: 0, col: 0, w: col_count_rework, h: row_count_rework, include_row_gutter: true, include_col_gutter: true
          bg_rect = rect row: 0, col: 1, w: 10, h: 1
  
          center_vertical = { x: $gtk.args.grid.w.idiv(2), y: safe_area.y, w: gutter, h: safe_area.h, path: :pixel, r: 128, g: 128, b: 128, anchor_x: 0.5 }
          center_horizontal = { x: safe_area.x, y: $gtk.args.grid.h.idiv(2), w: safe_area.w, h: gutter, path: :pixel, r: 128, g: 128, b: 128, anchor_y: 0.5 }
  
          values = [
            "scaling: [#{$gtk.args.grid.native_scale_enum.fdiv(100).to_sf}]",
            "safe area: [#{safe_area.x},#{safe_area.y},#{safe_area.w},#{safe_area.h}]",
            "cell: [#{single_cell.w},#{single_cell.h}]",
            "cell 2X: [#{double_cell.w},#{double_cell.h}]"
          ]
  
          single_cell_label = { x: safe_area.center.x,
                                y: safe_area.y + safe_area.h - 12,
                                text: values.join(" "),
                                anchor_x: 0.5,
                                anchor_y: 1.0,
                                r: 255, g: 255, b: 255, a: 255,
                                size_px: 12 }
  
          single_cell_bg = { x: bg_rect.x, y: safe_area.y + safe_area.h - 12, h: 12, w: bg_rect.w, path: :pixel, r: 0, g: 0, b: 0, a: 255 }
  
          single_cell_border = { **safe_area, primitive_marker: :border }
  
          @debug_primitives = col_count_rework.map_with_index do |col|
            row_count_rework.map_with_index do |row|
              cell   = rect row: row, col: col
              center = Geometry.rect_center_point cell
              [
                cell.merge(opts).border!(row: row, col: col, docs: "border for cell at row #{row}, col #{col}"),
                cell.merge(opts)
                  .label!(x: cell.center.x,
                          y: cell.center.y,
                          text: "#{row},#{col}",
                          size_px: 12,
                          anchor_x: 0.5,
                          anchor_y: 0.5 + 0.5,
                          row: row,
                          col: col,
                          docs: "label for cell at row #{row}, col #{col}"),
                cell.merge(opts)
                  .label!(x: cell.center.x,
                          y: cell.center.y,
                          text: "#{cell.x},#{cell.y}",
                          size_px: 12,
                          anchor_x: 0.5,
                          anchor_y: 0.5 - 0.5,
                          row: row,
                          col: col,
                          docs: "label for cell at row #{row}, col #{col}")
  
              ]
            end
          end.flatten + [center_horizontal, center_vertical, single_cell_border, single_cell_bg, single_cell_label]
        end
  
        @debug_primitives
      end
  
      def serialize
        {
          w: @w,
          h: @h,
          ratio_w: @ratio_w,
          ratio_h: @ratio_h,
          orientation: @orientation,
          gutter_left: @gutter_left,
          gutter_right: @gutter_right,
          gutter_top: @gutter_top,
          gutter_bottom: @gutter_bottom,
          cell_size: @cell_size,
          gutter: @gutter
        }
      end
  
      def inspect
        serialize.to_s
      end
  
      def to_s
        serialize.to_s
      end
  
      def reset
        @debug_primitives = nil
        initialize_gutters
      end
    end
  end

#+end_src

** log.rb
#+begin_src ruby
  # ./dragon/log.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # log.rb has been released under MIT (*only this file*).
  
  XTERM_COLOR = {
    black:          "\u001b[30m",
    red:            "\u001b[31m",
    green:          "\u001b[32m",
    yellow:         "\u001b[33m",
    blue:           "\u001b[34m",
    magenta:        "\u001b[35m",
    cyan:           "\u001b[36m",
    white:          "\u001b[37m",
    bright_black:   "\u001b[30;1m",
    bright_red:     "\u001b[31;1m",
    bright_green:   "\u001b[32;1m",
    bright_yellow:  "\u001b[33;1m",
    bright_blue:    "\u001b[34;1m",
    bright_magenta: "\u001b[35;1m",
    bright_cyan:    "\u001b[36;1m",
    bright_white:   "\u001b[37;1m",
    reset:          "\u001b[0m",
  }
  
  module GTK
    class Log
      def self.write_to_log_and_puts *args
        return if $gtk.production
        $gtk.append_file_root 'logs/log.txt', args.join("\n") + "\n"
        args.each { |obj| $gtk.log obj, self }
      end
  
      def self.write_to_log_and_print *args
        return if $gtk.production
        $gtk.append_file_root 'logs/log.txt', args.join("\n")
        Object.print(*args)
      end
  
      def self.puts_important *args, message_code: nil
        return if $gtk.production
        $gtk.append_file_root 'logs/log.txt', args.join("\n")
        if message_code
          $gtk.notify! "An important notification occurred. Open Console to see details. #{message_code}"
        else
          $gtk.notify! "An important notification occurred. Open Console to see details."
        end
        args.each { |obj| $gtk.log obj }
      end
  
      def self.puts *args
        message_id, message = args
        message ||= message_id
        write_to_log_and_puts message
      end
  
      def self.multiline? *args
        return true if args.length > 1
        return !args[0].to_s.multiline?
      end
  
      def self.join_lines args
        return "" if args.length == 0
        return args if args.is_a? String
        return args[0] if args.length == 1
        return args.to_s.join("\n")
      end
  
      def self.headline name
        @asterisk_count ||= 1
        @asterisk_count = @asterisk_count.greater(1)
        result_from_yield = join_lines yield
        result_from_yield = result_from_yield.each_line.map { |l| "  #{l}" }.join
        r ="#{"*" * @asterisk_count} #{name}\n#{result_from_yield}"
        @asterisk_count -= 1
        @asterisk_count = @asterisk_count.greater(1)
        r
      end
  
      def self.dynamic_block
        "#+BEGIN:
  #{join_lines yield}
  #+END:
  
  "
      end
  
      def self.puts_error *args
        args ||= []
        title = args[0]
        additional = args[1..-1] || []
        additional = "" if additional.length == 0
        if !title.multiline? && join_lines(additional).multiline?
          message = headline "ERROR: #{title}" do
            dynamic_block do
              additional
            end
          end
        elsif title.multiline?
          message = headline "ERROR: " do
            dynamic_block do
              args
            end
          end
        else
          message = "* ERROR: #{title} #{additional}".strip
        end
  
        self.puts message
      end
  
      def self.puts_info *args
        args ||= []
        title = args[0]
        additional = args[1..-1] || []
        additional = "" if additional.length == 0
        if !title.multiline? && join_lines(additional).multiline?
          message = headline "INFO: #{title}" do
            dynamic_block do
              additional
            end
          end
        elsif title.multiline?
          message = headline "INFO: " do
            dynamic_block do
              args
            end
          end
        else
          message = "* INFO: #{title} #{additional}".strip
        end
  
        self.puts message
      end
  
      def self.reset
        @once = {}
        nil
      end
  
      def self.puts_once *ids, message
        id = "#{ids}"
        @once ||= {}
        return if @once[id]
        @once[id] = id
        if !$gtk.cli_arguments[:replay] && !$gtk.cli_arguments[:record]
          $gtk.notify!("Open the DragonRuby Console by pressing [`] [~] [²] [^] [º] or [§]. [Message ID: #{id}].")
        end
        write_to_log_and_puts ""
        write_to_log_and_puts "#{message.strip}"
        write_to_log_and_puts ""
        write_to_log_and_puts "[Message ID: #{id}]"
        write_to_log_and_puts ""
      end
  
      def self.puts_once_important *ids, message
        id = "#{ids}"
        @once ||= {}
        return if @once[id]
        @once[id] = id
        puts_important "#{message}", message_code: id
      end
  
      def self.puts_once_info *ids, message
        id = "#{ids}"
        @once ||= {}
        return if @once[id]
        @once[id] = id
        log_info message
      end
  
      def self.print *args
        write_to_log_and_print(*args)
      end
    end
  end
  
  class Object
    def log_print *args
      GTK::Log.print(*args)
    end
  
    def log_important *args
      GTK::Log.puts_important(*args)
    end
  
    def log *args
      GTK::Log.puts(*args)
    end
  
    # FIXME: clean up private api call to global
    #        gtk instance (duplicated in runtime)
    def log_spam str, subsystem = nil
      $gtk.__log__ subsystem, 0, str
    end
  
    def log_debug str, subsystem = nil
      $gtk.__log__ subsystem, 1, str
    end
  
    def log_info str, subsystem = nil
      $gtk.__log__ subsystem, 2, str
    end
  
    def log_warn str, subsystem = nil
      $gtk.__log__ subsystem, 3, str
    end
  
    def log_error str, subsystem = nil
      $gtk.__log__ subsystem, 4, str
    end
  
    def log_unfiltered str, subsystem = nil
      $gtk.__log__ subsystem, 0x7FFFFFFE, str
    end
  
    def log_with_color xterm_escape_code, *args
      log_print xterm_escape_code
      log(*args)
    ensure
      log_reset_color
    end
  
    def log_reset_color
      log_print XTERM_COLOR[:reset]
    end
  
    def log_black *args
      log_with_color XTERM_COLOR[:black], *args
    end
  
    def log_red *args
      log_with_color XTERM_COLOR[:red], *args
    end
  
    def log_green *args
      log_with_color XTERM_COLOR[:green], *args
    end
  
    def log_yellow *args
      log_with_color XTERM_COLOR[:yellow], *args
    end
  
    def log_blue *args
      log_with_color XTERM_COLOR[:blue], *args
    end
  
    def log_magenta *args
      log_with_color XTERM_COLOR[:magenta], *args
    end
  
    def log_cyan *args
      log_with_color XTERM_COLOR[:cyan], *args
    end
  
    def log_white *args
      log_with_color XTERM_COLOR[:white], *args
    end
  
    def log_bright_black *args
      log_with_color XTERM_COLOR[:bright_black], *args
    end
  
    def log_bright_red *args
      log_with_color XTERM_COLOR[:bright_red], *args
    end
  
    def log_bright_green *args
      log_with_color XTERM_COLOR[:bright_green], *args
    end
  
    def log_bright_yellow *args
      log_with_color XTERM_COLOR[:bright_yellow], *args
    end
  
    def log_bright_blue *args
      log_with_color XTERM_COLOR[:bright_blue], *args
    end
  
    def log_bright_magenta *args
      log_with_color XTERM_COLOR[:bright_magenta], *args
    end
  
    def log_bright_cyan *args
      log_with_color XTERM_COLOR[:bright_cyan], *args
    end
  
    def log_bright_white *args
      log_with_color XTERM_COLOR[:bright_white], *args
    end
  
    def log_error *args
      GTK::Log.puts_error(*args)
    end
  
    def log_info *args
      GTK::Log.puts_info(*args)
    end
  
    def log_once *ids, message
      GTK::Log.puts_once(*ids, message)
    end
  
    def log_once_important *ids, message
      GTK::Log.puts_once_important(*ids, message)
    end
  
    def log_once_info *ids, message
      GTK::Log.puts_once_info(*ids, message)
    end
  end

#+end_src

** metadata.rb
#+begin_src ruby
  # ./dragon/metadata.rb
  # coding: utf-8
  # Copyright 2021 DragonRuby LLC
  # MIT License
  # metadata.rb has been released under MIT (*only this file*).
  
  # Contributors outside of DragonRuby who also hold Copyright: Michał Dudziński
  
  module Metadata
    def metadata_file_path
      "metadata/game_metadata.txt"
    end
  
    def get_metadata
      metadata = $gtk.read_file metadata_file_path
  
      if !metadata
        write_blank_metadata
        metadata = $gtk.read_file metadata_file_path
      end
  
      dev_id, dev_title, game_id, game_title, version, icon = *metadata.each_line.to_a
  
      {
        dev_id: dev_id.strip,
        dev_title: dev_title.strip,
        game_id: game_id.strip,
        game_title: game_title.strip,
        version: version.strip,
        icon: icon.strip
      }
    end
  
    def write_blank_metadata
        $gtk.write_file metadata_file_path, <<-S.strip
  #devid=myname
  #devtitle=My Name
  #gameid=mygame
  #gametitle=My Game
  #version=0.1
  #icon=metadata/icon.png
  S
    end
  end

#+end_src

** numeric.rb
#+begin_src ruby
  # ./dragon/numeric.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # numeric.rb has been released under MIT (*only this file*).
  
  class Numeric
    include ValueType
    include NumericDeprecated
  
    def to_layout_row opts = {}
      $layout.rect(row: self,
                   col: opts.col || 0,
                   w:   opts.w || 0,
                   h:   opts.h || 0).y
    end
  
    def to_layout_col opts = {}
      $layout.rect(row: 0,
                   col: self,
                   w:   opts.w || 0,
                   h:   opts.h || 0).x
    end
  
    def to_layout_w
      $layout.rect(row: 0, col: 0, w: self, h: 1).w
    end
  
    def to_layout_h
      $layout.rect(row: 0, col: 0, w: 1, h: self).h
    end
  
    def to_layout_row_from_bottom opts = {}
      ($layout.row_max_index - self).to_layout_row opts
    end
  
    def to_layout_col_from_right opts = {}
      ($layout.col_max_index - self).to_layout_col opts
    end
  
    # Converts a numeric value representing seconds into frames.
    def seconds
      self * 60
    end
  
    # Divides the number by `2.0` and returns a `float`.
    def half
      self / 2.0
    end
  
    def third
      self / 3.0
    end
  
    def quarter
      self / 4.0
    end
  
    def to_byte
      clamp(0, 255).to_i
    end
  
    def clamp *opts
      min = (opts.at 0)
      max = (opts.at 1)
      return min if min && self < min
      return max if max && self > max
      return self
    end
  
    def clamp_wrap min, max
      max, min = min, max if min > max
      range = max - min + 1
  
      min + (self - min) % range
    end
  
    def elapsed_time tick_count_override = nil
      (tick_count_override || Kernel.tick_count) - self
    end
  
    def elapsed_time_percent duration
      elapsed_time.percentage_of duration
    end
  
    def new?
      elapsed_time == 0
    end
  
    # Returns `true` if the numeric value has passed a duration/offset number.
    # `Kernel.tick_count` is used to determine if a number represents an elapsed
    # moment in time.
    def elapsed? offset = 0, tick_count_override = Kernel.tick_count
      (self + offset) < tick_count_override
    end
  
    def Numeric.frame_index start_at: 0, count:, hold_for:, repeat: false,  repeat_index: 0, tick_count_override: Kernel.tick_count
      return nil if tick_count_override < start_at
      animation_length = hold_for * count
  
      if !repeat && (start_at + animation_length) <= (tick_count_override)
        return nil
      else
        et = start_at.elapsed_time tick_count_override
        afc = count
  
        if et >= animation_length
          afc = count - repeat_index
          et += repeat_index * hold_for
          i = et.idiv(hold_for) % afc
          return i + repeat_index
        end
  
        return et.idiv(hold_for) % afc
      end
    end
  
    def frame_index *opts
      frame_count_or_hash, hold_for, repeat, tick_count_override = opts
      if frame_count_or_hash.is_a? Hash
        frame_count         = frame_count_or_hash[:count]
        hold_for            = frame_count_or_hash[:hold_for]
        repeat              = frame_count_or_hash[:repeat]
        tick_count_override = frame_count_or_hash[:tick_count_override]
        repeat_index        = frame_count_or_hash[:repeat_index]
      else
        frame_count = frame_count_or_hash
      end
  
      repeat_index ||= 0
      tick_count_override ||= Kernel.tick_count
  
      Numeric.frame_index start_at: self,
                          count: frame_count,
                          hold_for: hold_for,
                          repeat: repeat,
                          tick_count_override: tick_count_override,
                          repeat_index: repeat_index
    end
  
    def zero?
      self == 0
    end
  
    def zero
      0
    end
  
    def one
      1
    end
  
    def two
      2
    end
  
    def five
      5
    end
  
    def ten
      10
    end
  
    def shift_right i
      self + i
    end
  
    def shift_left i
      shift_right(i * -1)
    rescue Exception => e
      raise_immediately e, :shift_left, i
    end
  
    def shift_up i
      self + i
    rescue Exception => e
      raise_immediately e, :shift_up, i
    end
  
    def shift_down i
      shift_up(i * -1)
    rescue Exception => e
      raise_immediately e, :shift_down, i
    end
  
    # This provides a way for a numeric value to be randomized based on a combination
    # of two options: `:sign` and `:ratio`.
    def randomize *definitions
      result = self
  
      if definitions.include?(:sign)
        result = rand_sign
      end
  
      if definitions.include?(:ratio)
        result = rand * result
      elsif definitions.include?(:int)
        result = (rand result)
      end
  
      result
    end
  
    def rand_sign
      return self * -1 if rand > 0.5
      self
    end
  
    def rand_ratio
      self * rand
    end
  
    def remainder_of_divide n
      mod n
    end
  
    # Easing function progress/percentage for a specific point in time.
    def ease_extended tick_count_override, duration, default_before, default_after, *definitions
      GTK::Easing.ease_extended self,
                                tick_count_override,
                                self + duration,
                                default_before,
                                default_after,
                                *definitions
    end
  
    # Easing function progress/percentage for a specific point in time.
    def global_ease duration, *definitions
      ease_extended Kernel.global_tick_count,
                    duration,
                    GTK::Easing.initial_value(*definitions),
                    GTK::Easing.final_value(*definitions),
                    *definitions
    end
  
    # Easing function progress/percentage for a specific point in time.
    def ease duration, *definitions
      ease_extended Kernel.tick_count,
                    duration,
                    GTK::Easing.initial_value(*definitions),
                    GTK::Easing.final_value(*definitions),
                    *definitions
    end
  
    # Easing function progress/percentage for a specific point in time.
    def ease_spline_extended tick_count_override, duration, spline
      GTK::Easing.ease_spline_extended self,
                                       tick_count_override,
                                       self + duration,
                                       spline
    end
  
    # Easing function progress/percentage for a specific point in time.
    def global_ease_spline duration, spline
      ease_spline_extended Kernel.global_tick_count,
                           duration,
                           spline
    end
  
    # Easing function progress/percentage for a specific point in time.
    def ease_spline duration, spline
      ease_spline_extended Kernel.tick_count,
                           duration,
                           spline
    end
  
    # Converts a number representing an angle in degrees to radians.
    def to_radians
      self * Math::PI.fdiv(180)
    end
  
    # Converts a number representing an angle in radians to degrees.
    def to_degrees
      self / Math::PI.fdiv(180)
    end
  
    # Given `self`, a rectangle primitive is returned.
    #
    # @example
    #   5.to_square 100, 300 # returns [100, 300, 5, 5]
    def to_square x, y, anchor_x = 0.5, anchor_y = nil
      GTK::Geometry.to_square(self, x, y, anchor_x, anchor_y)
    end
  
    # Returns a normal vector for a number that represents an angle in degrees.
    def vector max_value = 1
      log_once :consider_to_vector!, <<-S
  * WARNGING: ~Numeric#vector~ is deprecated. Use ~Numeric#to_vector~.
  ~Numeric#to_vector~ is more preformant and returns a ~Hash~ containing the keys ~x~ and ~y~ as opposed
  to an ~Array~ of ~[x, y]~. Please note that you will lose the ability to destucture the values of a ~Hash~.
  
  S
      [vector_x(max_value), vector_y(max_value)]
    end
  
    def to_vector_r max_value = 1
      { x: vector_x_r(max_value), y: vector_y_r(max_value) }
    end
  
    def vector_x_r max_value = 1
      max_value * Math.cos(self)
    end
  
    def vector_y_r max_value = 1
      max_value * Math.sin(self)
    end
  
    def to_vector max_value = 1
      { x: vector_x(max_value), y: vector_y(max_value) }
    end
  
    def vector_y max_value = 1
      max_value * Math.sin(self.to_radians)
    end
  
    def vector_x max_value = 1
      max_value * Math.cos(self.to_radians)
    end
  
    alias_method :vector_x_d, :vector_x
    alias_method :vector_y_d, :vector_y
    alias_method :to_vector_d, :to_vector
  
    def x_vector max_value = 1
      vector_x max_value
    end
  
    def y_vector max_value = 1
      vector_y max_value
    end
  
    def mod n
      self % n
    end
  
    def mod_zero? *ns
      ns.any? { |n| mod(n) == 0 }
    end
  
    def zmod? n
      (self % n) == 0
    end
  
    def multiply n
      self * n
    end
  
    def fmult n
      self * n.to_f
    end
  
    def imult n
      (self * n).to_i
    end
  
    def mult n
      self * n
    end
  
    def fdiv n
      self / n.to_f
    end
  
    # Divides `self` by a number `n` as a float, and converts it `to_i`.
    def idiv n
      (self / n.to_f).floor
    end
  
    # Returns a numeric value that is a quantity `magnitude` closer to
    #`self`. If the distance between `self` and `target` is less than
    #the `magnitude` then `target` is returned.
    def towards target, magnitude
      return self if self == target
      delta = (self - target).abs
      return target if delta < magnitude
      return self - magnitude if self > target
      return self + magnitude
    end
  
    def lerp to, step
      self + step * (to - self)
    end
  
    def remap r1_begin, r1_end, r2_begin, r2_end
      r2_begin + (r2_end - r2_begin) * ((self - r1_begin) / (r1_end - r1_begin))
    end
  
    # Given `self` and a number representing `y` of a grid. This
    # function will return a one dimensional array containing the value
    # yielded by an implicit block.
    #
    # @example
    #   3.map_with_ys 2 do |x, y|
    #     x * y
    #   end
    #   #     x y   x y  x y  x y  x y  x y
    #   #     0*0,  0*1  1*0  1*1  2*0  2*1
    #   # => [  0,    0,   0,   1,   0,   2]
    def map_with_ys ys, &block
      results = []
      x_i = 0
      xs = self
  
      while x_i < xs
        y_i = 0
        while y_i < ys
          results << yield(x_i, y_i)
          y_i += 1
        end
        x_i += 1
      end
      results
    rescue Exception => e
      raise_immediately e, :map_with_ys, [self, ys]
    end
  
    def combinations other_int
      self.numbers.product(other_int.numbers)
    end
  
    def percentage_of n
      (self / n.to_f).cap_min_max(0, 1)
    end
  
    def cap i
      return i if self > i
      self
    end
  
    def cap_min_max min, max
      return min if self < min
      return max if self > max
      self
    end
  
    def lesser other
      return other if other < self
      self
    end
  
    def greater other
      return other if other > self
      self
    end
  
    def subtract i
      self - i
    end
  
    def minus i
      self - i
    end
  
    def add i
      self + i
    end
  
    def plus i
      self + i
    end
  
    def numbers
      (0..self).to_a
    end
  
    def each(&blk)
      return to_enum(:each) if !blk
  
      i = 0
      _self = self.to_i
      while i < _self
        blk[i]
        i += 1
      end
  
      self
    end
  
    def each_with_index(&blk)
      return to_enum(:each_with_index) if !blk
  
      i = 0
      _self = self.to_i
      while i < _self
        blk[i, i]
        i += 1
      end
  
      self
    end
  
    def map(&blk)
      return to_enum(:map) if !blk
  
      i = 0
      acc = []
      _self = self.to_i
      while i < _self
        acc << blk[i]
        i += 1
      end
  
      acc
    end
  
    def map_with_index(&blk)
      return to_enum(:map_with_index) if !blk
  
      i = 0
      acc = []
      _self = self.to_i
      while i < _self
        acc << blk[i, i]
        i += 1
      end
  
      acc
    end
  
    def times_with_index(&blk)
      return to_enum(:times_with_index) if !blk
  
      i = 0
      _self = self.to_i
      while i < _self
        blk[i, i]
        i += 1
      end
  
      self
    end
  
    def __raise_arithmetic_exception__ other, m, e
      raise <<-S
  * ERROR:
  Attempted to invoke :#{m} on #{self} with the right hand argument of:
  
  #{other}
  
  The object above is not a Numeric.
  
  #{e}
  S
    end
  
    def serialize
      self
    end
  
    def self.from_top n
      return 720 - n unless $gtk
      $gtk.args.grid.top - n
    end
  
    def from_top
      Numeric.from_top self
    end
  
    def self.from_right n
      return 1280 - n unless $gtk
      $gtk.args.grid.right - n
    end
  
    def from_right
      Numeric.from_right self
    end
  
    def self.clamp n, min, max
      n.clamp min, max
    end
  
    def mid? l, r
      (between? l, r) || (between? r, l)
    end
  
    def self.from_left n
      return n unless $gtk
      $gtk.args.grid.left + n
    end
  
    def from_left
      Numeric.from_left self
    end
  
    def self.from_bottom n
      return n unless $gtk
      $gtk.args.grid.bottom + n
    end
  
    def from_bottom
      Numeric.from_bottom self
    end
  end
  
  class Fixnum
    include ValueType
  
    # Returns `true` if the numeric value is evenly divisible by 2.
    def even?
      return (self % 2) == 0
    end
  
    # Returns `true` if the numeric value is *NOT* evenly divisible by 2.
    def odd?
      return !even?
    end
  
    # Returns `-1` if the number is less than `0`. `+1` if the number
    # is greater than `0`. Returns `0` if the number is equal to `0`.
    def sign
      return -1 if self < 0
      return  1 if self > 0
      return  0
    end
  
    # Returns `true` if number is greater than `0`.
    def pos?
      sign > 0
    end
  
    # Returns `true` if number is less than `0`.
    def neg?
      sign < 0
    end
  
    def cos
      Math.cos self.to_radians
    end
  
    def cos_r
      Math.cos self
    end
  
    def cos_d
      Math.cos self.to_radians
    end
  
    def sin
      Math.sin self.to_radians
    end
  
    def sin_r
      Math.sin self
    end
  
    def sin_d
      Math.sin self.to_radians
    end
  
    def tan
      Math.tan self.to_radians
    end
  
    def tan_d
      Math.tan self.to_radians
    end
  
    def tan_r
      Math.tan self
    end
  
    def to_sf
      "%.2f" % self
    end
  
    def ifloor int
      (self.idiv int.to_i) * int.to_i
    end
  end
  
  class Float
    include ValueType
  
    def serialize
      self
    end
  
    def sign
      return -1 if self < 0
      return  1 if self > 0
      return  0
    end
  
    def replace_infinity scalar
      return self if !scalar
      return self unless self.infinite?
      return -scalar if self < 0
      return  scalar if self > 0
    end
  
    def to_sf
      "%.2f" % self
    end
  
    def ifloor int
      (self.idiv int.to_i) * int.to_i
    end
  
    def sin
      Math.sin self.to_radians
    end
  
    def cos
      Math.cos self.to_radians
    end
  
    def sin_r
      Math.sin self
    end
  
    def sin_d
      Math.sin self.to_radians
    end
  
    def cos_r
      Math.cos self
    end
  
    def cos_d
      Math.cos self.to_radians
    end
  
    def tan
      Math.tan self.to_radians
    end
  
    def tan_d
      Math.tan self.to_radians
    end
  
    def tan_r
      Math.tan self
    end
  end
  
  class Integer
    def round *args
      self
    end
  
    def nan?
      false
    end
  
    def center other
      (self - other).abs.fdiv(2)
    end
  end

#+end_src

** recording.rb
#+begin_src ruby
  # ./dragon/recording.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # recording.rb has been released under MIT (*only this file*).
  
  module GTK
    # FIXME: Gross
    class Replay
      def self.start file_name = nil, speed: 1
        $recording.start_replay file_name, speed: speed
      end
  
      def self.stop
        $recording.stop_replay
      end
    end
  
    class Recording
      attr :should_reset_after_replay_completed
  
      def initialize runtime
        @runtime = runtime
        @global_input_order = 1
        @should_reset_after_replay_completed = true
      end
  
      def tick
        if @replay_next_tick && !is_replaying?
          @replay_next_tick = nil
          start_replay @replay_next_tick_file_name, speed: @replay_next_tick_simulation_speed
          @replay_next_tick_simulation_speed = nil
        end
  
        if is_replaying? && @on_replay_tick
          @on_replay_tick.call $gtk.args
        end
  
        if is_recording? && @on_recording_tick
          @on_recording_tick.call $gtk.args
        end
      end
  
      def on_replay_tick &block
        @on_replay_tick = block
      end
  
      def on_recording_tick &block
        @on_recording_tick = block
      end
  
      def start_recording seed_number = nil
        if !seed_number
          log <<-S
  * ERROR:
  To start recording, you must provide an integer value to
  seed random number generation.
  S
          $console.set_command "$recording.start SEED_NUMBER"
          return
        end
  
        if @is_recording
          log <<-S
  * ERROR:
  You are already recording, first cancel (or stop) the current recording.
  S
          $console.set_command "$recording.cancel"
          return
        end
  
        if @is_replaying
          log <<-S
  * ERROR:
  You are currently replaying a recording, first stop the replay.
  S
          return
        end
  
        log_info <<-S
  Recording has begun with RNG seed value set to #{seed_number}.
  To stop recording use stop_recording(filename).
  The recording will stop without saving a file if a filename is nil.
  S
        $console.set_command_extended histories: ["$recording.start #{seed_number}"],
                                      command: "$recording.stop 'replay.txt'"
        @keys_to_ignore_during_recording = $console.console_toggle_keys.map { |k| k.without_ending_bang }
        @is_recording = true
        @runtime.__reset__
        @seed_number = seed_number
        @runtime.set_rng seed_number
  
        @global_input_order = 1
        @input_history = []
        @runtime.notify! "Recording started. When completed, open the console to save it using $recording.stop FILE_NAME (or cancel).", 300
      end
  
      def start seed_number = nil
        start_recording seed_number
      end
  
      def is_replaying?
        !!@is_replaying
      end
  
      def is_recording?
        !!@is_recording
      end
  
      def stop file_name = nil
        stop_recording file_name
      end
  
      def cancel
        stop_recording_core
        @runtime.notify! "Recording cancelled."
      end
  
      def stop_recording file_name = nil
        if !file_name
          log <<-S
  * ERROR:
  To please specify a file name when calling:
  $recording.stop FILE_NAME
  
  If you do NOT want to save the recording, call:
  $recording.cancel
  S
          $console.set_command "$recording.stop 'replay.txt'"
          return
        end
  
        if !@is_recording
          log_info "You are not currently recording. Use start_recording(seed_number) to start recording."
          $console.set_command "$recording.start"
          return
        end
  
        if file_name
          stopped_at = Kernel.tick_count
          # if the last input was ignored, then we want to set stopped at to the point in time before the last input was ignored.
          if @last_recorded_input_was_ignored
            stopped_at -= stopped_at - @last_recorded_input_was_ignored_at
          end
          text = "replay_version 2.0\n"
          text << "stopped_at #{stopped_at}\n"
          text << "seed #{@seed_number}\n"
          text << "recorded_at #{Time.now.to_s}\n"
          @input_history.each do |items|
            text << "#{items}\n"
          end
          @runtime.write_file file_name, text
          @runtime.write_file 'last_replay.txt', text
          log_info "The recording has been saved successfully at #{file_name}. You can use start_replay(\"#{file_name}\") to replay the recording."
        end
  
        $console.set_command "$replay.start '#{file_name}', speed: 1"
        stop_recording_core
        @runtime.notify! "Recording saved to #{file_name}. To replay it: ~$replay.start \"#{file_name}\", speed: 1~."
        log_info "You can run the replay later on startup using: ./dragonruby mygame --replay #{@replay_file_name}"
        @recording_stopped_at = Kernel.global_tick_count
        nil
      end
  
      def recording_recently_completed?
        return false if !@recording_stopped_at
        (Kernel.global_tick_count - @recording_stopped_at) <= 5
      end
  
      def on_replay_completed_successfully &block
        @replay_completed_successfully_block = block
      end
  
      def stop_recording_core
        @is_recording = false
        @input_history = nil
        @last_history = nil
        @runtime.__reset__
      end
  
      def replay_completed_successfully?
        @replay_completed_successfully
      end
  
      def __parse_replay_value__ value
        return value if !value
        return value.gsub(':', '').to_sym if value.start_with? ':'
        return value == 'true' if value == 'true' || value == 'false'
        return value.to_f
      end
  
      def start_replay file_name = nil, speed: 1
        return if replay_recently_stopped?
        @replay_completed_successfully = false
        if !file_name
          log <<-S
  * ERROR:
  Please provide a file name to $recording.start.
  S
          $console.set_command_silent "$replay.start 'replay.txt', speed: 1"
          return
        end
  
        text = @runtime.read_file file_name
        return false unless text
  
        if text.each_line.first.strip != "replay_version 2.0"
          raise "The replay file #{file_name} is not compatible with this version of DragonRuby Game Toolkit. Please recreate the replay (sorry)."
        end
  
        @replay_started_at = Kernel.global_tick_count
        @replay_file_name = file_name
  
        $replay_data = {
          input_history: { },
          stopped_at_current_tick: 0
        }
  
        # the replay file is a text file with the following format:
        # replay_version 2.0 (the version of the replay file)
        # stopped_at 123456789 (tick count when the recording was stopped)
        # seed 123456789 (rng seed that was used to record the replay)
        # recorded_at 2019-01-01 12:00:00 -0500 (date and time when the recording was created)
        # inputs recorded as an array (delimited by new lines)
        # all record inputs have 6 entires except for mouse wheel which can have 6 or 7 entries (new parameters were added)
        # example:
        #   for entries with 6 parameters:
        #   [function_called, parameter_1, parameter_2 (if applicable), parameter count (1 or 2), input order, tick count]
        #   [:mouse_button_up, 1, 0, 1, 1, 3]
        #
        #   for entries with 7 parameters:
        #   [function_called, parameter_1, parameter_2 (if applicable), parameter_3 (if applicable), parameter count (always 3), input order, tick count]
        #   [:mouse_wheel, 1, 0, 1, 1, 3]
        text.each_line do |l|
          if l.strip.length == 0
            next
          elsif l.start_with? 'replay_version'
            next
          elsif l.start_with? 'seed'
            $replay_data[:seed] = l.split(' ').last.to_i
          elsif l.start_with? 'stopped_at'
            $replay_data[:stopped_at] = l.split(' ').last.to_i
          elsif l.start_with? 'recorded_at'
            $replay_data[:recorded_at] = l.split(' ')[1..-1].join(' ')
          elsif l.start_with? '['
            # this is the logic to parse the array of inputs
            items = l.strip.gsub('[', '').gsub(']', '').split(',')
  
            # item 0 is the function name
            name        = __parse_replay_value__ items[0]
            value_1     = nil
            value_2     = nil
            value_3     = nil
            value_count = 0
            id          = 0
            tick_count  = 0
  
            # if the name is mouse_wheel, handle the 6 or 7 parameter case (6 parameters is the old format)
            if name == :mouse_wheel
              # always set the number of parameters for mouse wheel to 3
              value_count = 3
  
              # value_3 is nil if there are only 6 parameters
              if items.length == 6
                # when destructoring items, we don't need the name (first item) or the value_count (4th item)
                _, value_1, value_2, _, id, tick_count = items
                value_3 = nil
              elsif items.length == 7
                # when destructoring items, we don't need the name (first item) or the value_count (4th item)
                _, value_1, value_2, value_3, _, id, tick_count = items
              else
                raise "Unable to parse replay entry #{l.strip}. Expected 6 or 7 values for mouse_wheel."
              end
            elsif items.length == 6
              # general case for 6 parameters
              _, value_1, value_2, value_count, id, tick_count = items
              value_3 = nil
            elsif items.length == 7
              # general case for 7 parameters
              _, value_1, value_2, value_3, value_count, id, tick_count = items
            else
              raise "Unable able to parse replay entry #{l.strip}. Expected 6 or 7 values."
            end
  
            # deserialize the string value into the correct type
            value_1 = __parse_replay_value__ value_1
            value_2 = __parse_replay_value__ value_2
            value_3 = __parse_replay_value__ value_3
  
            # create a dictionary entry for the input
            $replay_data[:input_history][tick_count.to_i] ||= []
            $replay_data[:input_history][tick_count.to_i] << {
              id: id.to_i,
              name: name,
              value_1: value_1,
              value_2: value_2,
              value_3: value_3,
              value_count: value_count.to_i
            }
          else
            raise "Replay data seems corrupt. I don't know how to parse #{l}."
          end
        end
  
        $replay_data[:input_history].keys.each do |key|
          $replay_data[:input_history][key] = $replay_data[:input_history][key].sort_by {|input| input[:id]}
        end
  
        @runtime.__reset__
        @runtime.set_rng $replay_data[:seed]
        @is_replaying = true
        if speed
          speed = speed.clamp(1, 60)
          @runtime.simulation_speed = speed
        end
        log_info "Replay started =#{@replay_file_name}= speed: #{@runtime.simulation_speed}. (#{Kernel.global_tick_count})"
        @runtime.notify! "Replay started =#{@replay_file_name}= speed: #{@runtime.simulation_speed}."
      end
  
      def replay_next_tick file_name, speed: 1
        @replay_next_tick = true
        @replay_next_tick_file_name = file_name
        if speed
          speed = speed.clamp(1, 60)
          @replay_next_tick_simulation_speed = speed
        end
      end
  
      def replay_completed_at
        @replay_completed_at
      end
  
      def replay_stopped_at
        @replay_stopped_at
      end
  
      def replay_recently_started?
        return false if !@replay_started_at
        (Kernel.global_tick_count - @replay_started_at) <= 5
      end
  
      def replay_recently_stopped?
        return false if !@replay_stopped_at
        (Kernel.global_tick_count - @replay_stopped_at) <= 5
      end
  
      def replay_recently_completed?
        return false if !@replay_completed_at
        (Kernel.global_tick_count - @replay_completed_at) <= 5
      end
  
      def clear_replay_stopped_at!
        @replay_stopped_at = nil
      end
  
      def stop_replay notification_message = "Replay has been stopped."
        @runtime.simulation_speed = 1
        if !is_replaying?
          log <<-S
  * ERROR:
  No replay is currently running. Call ~$replay.start FILE_NAME, speed: 1~ to start a replay.
  S
  
          $console.set_command "$replay.start 'replay.txt', speed: 1"
          return
        end
        log_info "#{notification_message} (#{Kernel.global_tick_count})"
        $replay_data = nil
        @global_input_order = 1
        @replay_stopped_at = Kernel.global_tick_count
        $console.set_command_silent "$replay.start '#{@replay_file_name}', speed: 1"
        @is_replaying = false
        @runtime.__reset__ if @should_reset_after_replay_completed
        @runtime.notify! notification_message
      end
  
      def record_input? name, raw_key, modifier_keys
        return false if $gtk.console.visible?
        return false if @is_replaying
        return false unless @is_recording
        # do not record console activation
        if name == :key_up_raw || name == :key_down_raw
          names = KeyboardKeys.sdl_to_key raw_key, modifier_keys
          return false if (names & @keys_to_ignore_during_recording).length > 0
          return false if @input_history.length == 0 && names.include?(:enter)
        end
        return true
      end
  
      # these values are used later to determine if the replay length should be shortened
      # (for example if the last bits of the replay were in the console/wouldn't be recorded)
      def capture_record_input_timestamps name, raw_key, modifier_keys
        if !record_input? name, raw_key, modifier_keys
          @last_recorded_input_was_ignored_at ||= Kernel.tick_count
          @last_recorded_input_was_ignored ||= true
        else
          @last_recorded_input_was_ignored_at = nil
          @last_recorded_input_was_ignored = nil
        end
      end
  
      # 1 or 2 params
      def record_input_history name, value_1, value_2, value_count, clear_cache = false
        capture_record_input_timestamps name, value_1, value_2
        return if !record_input? name, value_1, value_2
        @input_history << [name, value_1, value_2, value_count, @global_input_order, Kernel.tick_count]
        @global_input_order += 1
      end
  
      def record_input_history_3_params name, value_1, value_2, value_3, clear_cache = false
        capture_record_input_timestamps name, value_1, value_2
        return if !record_input? name, value_1, value_2
        @input_history << [name, value_1, value_2, value_3, 3, @global_input_order, Kernel.tick_count]
        @global_input_order += 1
      end
  
      def tick_replay
        if @on_replay_tick
          @on_replay_tick.call @runtime.args
        end
        stage_replay_values
      end
  
      def stage_replay_values
        return unless @is_replaying
        return unless $replay_data
  
        $replay_data[:stopped_at_current_tick] += 1
  
        if ($replay_data[:stopped_at] - $replay_data[:stopped_at_current_tick]) <= 1
          @replay_completed_successfully = true
          if @replay_completed_successfully_block
            @replay_completed_successfully_block.call @runtime.args
          end
          @replay_completed_at = Kernel.global_tick_count
          stop_replay "Replay completed [#{@replay_file_name}]. To rerun, bring up the Console and press enter."
          @runtime.simulation_speed = 1
          return
        end
  
        inputs_this_tick = $replay_data[:input_history][$replay_data[:stopped_at_current_tick]]
        if Kernel.global_tick_count.zmod?(60 * @runtime.simulation_speed)
          calculated_tick_count = ($replay_data[:stopped_at] + @replay_started_at) - Kernel.global_tick_count
          log_info "Replay ends in #{calculated_tick_count.idiv(60 * @runtime.simulation_speed)} second(s). (#{Kernel.global_tick_count})"
        end
  
        return unless inputs_this_tick
        inputs_this_tick.each do |v|
          args = []
          args << v[:value_1] if v[:value_count] >= 1
          args << v[:value_2] if v[:value_count] >= 2
          args << v[:value_3] if v[:value_count] >= 3
          args << :replay
          $gtk.send v[:name], *args
        end
      end
    end
  end

#+end_src

** remote_hotload_client.rb
#+begin_src ruby
  # ./dragon/remote_hotload_client.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # hotload_client.rb has been released under MIT (*only this file*).
  
  module GTK
    class RemoteHotloadClient
      attr :args
  
      def gtk
        args.gtk
      end
  
      def state
        local_state
      end
  
      def initialize server_ip_address, port
        local_state.server_ip_address = server_ip_address || ""
        local_state.server_port = port
        puts "* INFO: Remote Hotload Client server_available? #{server_available?}"
      end
  
      def tick
        return unless server_available?
  
        if should_tick? && !local_state.notified
          if server_available?
            log_spam "* REMOTE HOTLOAD INFO: Hotload server found at #{get_server_ip_address}:#{get_server_port}."
          end
          local_state.notified = true
        end
  
        tick_write_file
        tick_process_file_retrieval
        tick_process_queue
        tick_changes
        tick_http_boot
      end
  
      def should_tick?
        (game_state.tick_count.mod_zero? 60) && game_state.tick_count > 5.seconds
      end
  
      def game_state
        args.state
      end
  
      def local_state
        @local_state ||= OpenEntity.new
        @local_state.hotload_client ||= @local_state.new_entity(:hotload_client,
                                                                notes: "This entity is used by DragonRuby Game Toolkit to provide you hotloading on remote machines.",
                                                                changes: { },
                                                                changes_queue: [],
                                                                write_file_queue: [],
                                                                reloaded_files_times: [])
        @local_state.hotload_client
      end
  
      def get_server_ip_address
        local_state.server_ip_address
      end
  
      def get_server_port
        local_state.server_port
      end
  
      def get_server_url path
        return "http://#{get_server_ip_address}:#{get_server_port}/#{path}"
      end
  
      def server_available?
        return false if $gtk.platform == 'Emscripten'
        get_server_ip_address.length != 0
      end
  
      def tick_changes
        return unless should_tick?
  
        local_state.greatest_tick ||= 0
        local_state.last_greatest_tick ||= 0
  
        tick_http_changes
      end
  
      def tick_http_boot
        return if local_state.booted_at
        local_state.http_boot_debounce ||= 0
        local_state.http_boot_debounce  -= 1
        local_state.http_boot_debounce   = local_state.http_boot_debounce.clamp(0, 120)
        return if local_state.http_boot_debounce > 0
  
        if !local_state.http_boot
          # first retrieve changes.txt which has the following format
          # file with latest change,
          # latest file                              update_time  key
          # tmp/src_backup/src_backup_app_main.rb, 1597926596,  app/main.rb
          log_spam "* REMOTE HOTLOAD INFO: Attempting http_get of #{get_server_url('dragon/boot/')}"
          local_state.http_boot    = args.gtk.http_get(get_server_url('dragon/boot/'))
        elsif local_state.http_boot && local_state.http_boot[:http_response_code] == 200
          local_state.last_greatest_tick = local_state.http_boot[:response_data].strip.to_i
          local_state.greatest_tick = local_state.http_boot[:response_data].strip.to_i
          local_state.booted_at = local_state.greatest_tick
          log_spam '* REMOTE HOTLOAD INFO: HTTP GET for local_state. boot.txt succeeded.'
          log_spam "* REMOTE HOTLOAD INFO: Looking for changes after: #{local_state.greatest_tick}."
        elsif local_state.http_boot && local_state.http_boot[:http_response_code] == -1 && local_state.http_boot[:complete]
          log_spam '* REMOTE HOTLOAD INFO: HTTP GET for boot.txt failed. Retrying.'
          local_state.http_boot = nil
          local_state.http_boot_debounce = 120
        end
      end
  
      def tick_http_changes
        return unless local_state.booted_at
  
        if !local_state.http_changes
          log_spam "* REMOTE HOTLOAD INFO: Attempting http_get of #{get_server_url('dragon/changes/')}"
          local_state.http_changes = args.gtk.http_get(get_server_url('dragon/changes/'))
        end
  
        if local_state.http_changes && local_state.http_changes[:http_response_code] == 200 && local_state.booted_at
          local_state.last_greatest_tick = local_state.greatest_tick
          # if the retrieval of changes.txt was successful
          local_state.http_changes[:response_data].each_line do |l|
            if l.strip.length != 0
              # within reload state for that specific changes hash
              # set the last time the file was updated
              file_name, updated_at, key = l.strip.split(',')
              file_name.strip!
              updated_at.strip!
              key.strip!
              updated_at = updated_at.to_i
              file_name = file_name.gsub("tmp/src_backup/", "")
  
              # keep an internal clock that denotes that current time on the
              # dev machine
              if updated_at > local_state.greatest_tick
                local_state.greatest_tick = updated_at
  
                # create a new entry in change tracking for the file
                # for every file where the file was last updated, find all the ones where the time is not the same
                # and queue those to be retrieved and required
                # if the last time the dev machine time was retrieved is less than the file time changed
                # then queue the file for reload
                current_updated_at = (local_state.changes[key] || { updated_at: 0 })[:updated_at]
                if updated_at > current_updated_at
                  log_spam "* REMOTE HOTLOAD INFO: Queueing file #{file_name} for update."
                  local_state.changes[key] = { key: key,
                                               latest_file: file_name,
                                               updated_at: updated_at }
                  local_state.changes_queue << local_state.changes[key]
                end
              end
            end
          end
  
          # set the greatest tick/current time of the machine
          local_state.http_changes = nil
        elsif local_state.http_changes && local_state.http_changes[:http_response_code] == -1 && local_state.http_change[:complete] && local_state.booted_at
          local_state.http_changes = nil
        end
      end
  
      def tick_process_queue
        return if local_state.http_file_changes # don't pop a file off the queue if there is an http request in flight
        return if local_state.processing_file_changes # don't pop a file if there is a file currently being processed
        return unless local_state.changes_queue.length > 0 # return if the queue is empty
  
        # if it isn't empty, pop the first file off the queue (FIFO)
        local_state.processing_file_changes = local_state.changes_queue.shift
  
        # create an http request for the file
        url = get_server_url("/dragon/#{local_state.processing_file_changes[:latest_file]}")
        log_spam "* REMOTE HOTLOAD INFO: Getting new version of #{local_state.processing_file_changes[:latest_file]} (#{url})."
        local_state.http_file_changes = args.gtk.http_get url
      end
  
      def tick_process_file_retrieval
        return if !local_state.http_file_changes
  
        # if the http request has finished successfully
        if local_state.http_file_changes[:http_response_code] == 200 && local_state.http_file_changes[:complete]
          file_key = local_state.processing_file_changes[:key]
          # notify that a file will be reloaded
          log "* REMOTE HOTLOAD INFO: Loading #{file_key}: #{local_state.processing_file_changes[:latest_file]}"
          log "#{local_state.http_file_changes[:response_data]}"
  
          # write the latest file with what came back from the response data
          local_state.write_file_queue << { path: file_key, text: local_state.http_file_changes[:response_data] }
  
          # nil out the currently processing file so a new item can be processed from the queue
          # local_state.reloaded_files_times << local_state.processing_file_changes[:key]
          local_state.http_file_changes = nil
          local_state.processing_file_changes = nil
        end
      end
  
      def tick_write_file
        local_state.write_file_queue.each do |h|
          log "* REMOTE HOTLOAD INFO: writing file #{h[:path]}"
          $gtk.write_file h[:path], h[:text]
        end
  
        local_state.write_file_queue.clear
      end
    end
  end

#+end_src

** runtime/async_require.rb
#+begin_src ruby
  # ./dragon/runtime/async_require.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # async_require.rb has been released under MIT (*only this file*).
  
  module GTK
    class Runtime
      module AsyncRequire
        def async_require_init
          @reload_list = []
  
          # schema for reload_list_history
          # { PATH: { current: { path: PATH,
          #                      global_at: Fixnum,
          #                      event: (:reload_queued|:processing|reload_completed) },
          #           history: [{ path: PATH,
          #                             global_at: Fixnum,
          #                             event: (:reload_queued|:processing|reload_completed) }]}}
          @reload_list_history = {}
  
          @reload_debounce = 0
        end
  
        def most_recent_reload_history path
          return nil unless @reload_list_history[path]
          return nil unless @reload_list_history[path][:history]
          return @reload_list_history[path][:history].last
        end
  
        def mark_ruby_file_for_reload path
          @reload_list_history[path] ||= { current: {}, history: [] }
          info = @reload_list_history[path]
          recent = (most_recent_reload_history path)
  
          return if recent && (((recent[:global_at] || 0) + 60) > Kernel.global_tick_count)
          return if info && info[:current] && info[:current][:event] && (((info[:global_at] || 0) + 60) > Kernel.global_tick_count)
  
          @reload_list_history[path][:current]   = { path: path, global_at: Kernel.global_tick_count, event: :reload_queued  }
          @reload_list_history[path][:history] ||= []
          @reload_list_history[path][:history]  << { path: path, global_at: Kernel.global_tick_count, event: :reload_queued  }
  
          log "** INFO: =#{path}= queued to load via ~require~. (#{Kernel.global_tick_count}, #{Kernel.tick_count})", subsystem="Engine"
  
          if @load_status == :ready
            @reload_list << path
            @reload_list.uniq!
            __require_sync__ path
          else
            @reload_list << path
            @reload_list.uniq!
          end
        rescue Exception => e
          raise e, "* EXCEPTION: ~Runtime#mark_ruby_file_for_reload~ failed for =#{path}=.\n#{e}"
        end
  
        def get_ruby_reload_list
          return [] if @reload_list.length == 0
          @reload_list.each do |r|
            @reload_list_history[r]           ||= {}
            @reload_list_history[r][:current]   = { path: r, global_at: Kernel.global_tick_count, event: :processing }
            @reload_list_history[r][:history] ||= []
            @reload_list_history[r][:history]  << { path: r, global_at: Kernel.global_tick_count, event: :processing }
          end
          @exception_occured = false
          @is_reloading = true
          @reload_list
        end
  
        def reload_complete
          return unless @is_reloading
          @is_reloading = false
  
          if !@exception_occured
            unpause!
            @console.hide if @console.show_reason == :exception || @console.show_reason == :exception_on_load
          end
  
          @reload_list_history.keys.each do |k|
            if (@reload_list_history[k][:current][:event] == :processing) || (@reload_list_history[k][:current][:event] == :reload_queued)
              log "* INFO: =#{k}= reloaded. (#{Kernel.global_tick_count}, #{Kernel.tick_count})", subsystem="Engine"
              @reload_list_history[k][:current]  = { path: k, global_at: Kernel.global_tick_count, event: :reload_completed }
              @reload_list_history[k][:history] << { path: k, global_at: Kernel.global_tick_count, event: :reload_completed }
            end
          end
  
          @last_reload_complete_global_at = Kernel.global_tick_count
          $layout.reset if $layout
          $gtk.reset_framerate_calculation
  
          main_rb_loaded!
        end
  
        def on_file_reloaded file
        end
  
        def main_rb_reload_completed?
          return (@reload_list_history['app/main.rb'] &&
                  @reload_list_history['app/main.rb'][:history] &&
                  @reload_list_history['app/main.rb'][:history].find { |h| h[:event] == :reload_completed }) ||
                 (@reload_list_history['app/main.rbc'] &&
                  @reload_list_history['app/main.rbc'][:history] &&
                  @reload_list_history['app/main.rbc'][:history].find { |h| h[:event] == :reload_completed })
        end
  
        def main_rb_loaded!
          @new_methods ||= important_instance_methods
          new_methods = important_instance_methods - @new_methods
  
          if new_methods.length > 0
            log <<-S
  * INFO: New methods discovered.
  #{new_methods.map { |m| "** #{m.inspect}" }.join("\n")}
  S
            @new_methods = important_instance_methods
          end
  
          process_load_status
        end
  
        def important_instance_methods
          Object.instance_methods + dollar_sign_game_methods
        end
  
        def dollar_sign_game_methods
          return [] if !$game
          return $game.class.instance_methods
        end
  
        def process_load_status
          return if @load_status == :ready
          return if pending_reload?
  
          if main_rb_reload_completed?
            @load_status = :ready
            log "* INFO: ~GTK::Runtime#load_status~ set to ~:ready~.", subsystem="Engine"
            Kernel.tick_count = -1
            Kernel.global_tick_count = -1
            $gtk.write_file_root (File.join backup_directory, "boot.txt"), Time.now.to_i.to_s
            $top_level.boot @args if $top_level.respond_to? :boot
            @args.state.tick_count = -1
            Kernel.global_tick_count = -1
            Kernel.tick_count = -1
            reset_all_mtimes
          end
        end
  
        def load_status
          @load_status
        end
  
        def pending_reload?
          @reload_list_history.any? do |key, value|
            value[:current][:event] == :reload_queued ||
            value[:current][:event] == :processing
          end
        end
  
        def reload_ruby_file file
          ext = File.extname(file)
          return false unless ext == ".rb" || ext == ".rbc"
          return true if @suppress_hotload
          backup_create file
          syntax = (@ffi_file.read file) || ''
          return true if syntax.strip.length == 0
  
          okay = true
          if ext == ".rb"
            syntax_check_result = @ffi_mrb.parse syntax
            okay = (syntax_check_result == "Syntax OK")
          end
  
          if okay
            if file.include? 'mailbox.rb'
              mailbox_contents = ((read_file file) || '').strip
              if mailbox_contents.length != 0
                new_file_name = "mailbox-processed/mailbox-#{Kernel.global_tick_count}.rb"
                new_path = file.gsub('mailbox.rb', new_file_name)
                write_file file, ''
                write_file new_path, mailbox_contents
                reload_if_needed new_path, true
                return true
              end
            else
              mark_ruby_file_for_reload file
            end
            log_debug "Reloaded #{file}. (#{Kernel.global_tick_count})", subsystem="Engine"
            notify_subdued!
            return true
          else
            # handle a special case where a syntax error exists in main.rb on startup
            if @load_status == :dragonruby_started || @load_status == :main_rb_first_time_load
              mark_ruby_file_for_reload file
              @main_rb_load_exception = { file: file, error: syntax_check_result }
            else
              raise <<~S
              ** Failed to load/reload #{file}.
              #{syntax_check_result}
  
              S
            end
          end
        rescue Exception => e
          pretty_print_exception_and_export! e
          pause!
          self.show_console :exception
          return false
        end
  
        def load_main_rb
          return if @load_status != :dragonruby_started
          if @ffi_file.path_exists('app/main.rb') || @ffi_file.path_exists('app/main.rbc')
            require 'app/main.rb'
          end
        end
      end # GTK::Runtime::AsyncRequire
    end # GTK::Runtime
  end # GTK

#+end_src

** runtime/auto_test.rb
#+begin_src ruby
  # ./dragon/runtime/auto_test.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # auto_test.rb has been released under MIT (*only this file*).
  
  module GTK
    class Runtime
      module AutoTest
        def auto_test_run
          return if !can_auto_test?
          puts "* INFO: ~auto_test_run~ invoked (#{Kernel.global_tick_count})."
          puts @auto_test_files
          auto_test_run_tests
        end
  
        def can_auto_test?
          return false if @production
          return false if @load_status != :ready
          return false if !@auto_test_initialized
          return true
        end
  
        def tick_auto_test
          return if (Kernel.global_tick_count % 60) != 0
          auto_test_initialize
          return if !can_auto_test?
          tick_auto_test_discover_tests
          tick_auto_test_run_changed
          tick_auto_test_reset_all_mtimes
          auto_test_initialize
        end
  
        def auto_test_initialize
          return if @auto_test_initialized
          return if Kernel.global_tick_count < 60
          @auto_test_files = {}
          @required_files.find_all { |f| f.end_with? "tests.rb" }
                         .each do |f|
                           log "* INFO: Test =#{f}= found and added to hotload file list."
                           reload_if_needed f, true
                           @auto_test_files[f] = {
                             current: @ffi_file.mtime(f),
                             last: @ffi_file.mtime(f)
                           }
                         end
          @auto_test_initialized = true
        end
  
        def tick_auto_test_run_changed
          @auto_test_files.each do |k, v|
            v.current = @ffi_file.mtime k
          end
  
          if @changes_detected
            auto_test_run_tests
            @changes_detected = false
          else
            files_updated = @auto_test_files.any? { |k, v| v[:current] != v[:last] }
            @changes_detected = true if files_updated
          end
        end
  
        def auto_test_run_tests
          return if !can_auto_test?
          $tests.start
          $tests.clear_summary
        end
  
        def tick_auto_test_reset_all_mtimes
          @auto_test_files.each do |k, v|
            v.current = @ffi_file.mtime k
            v.last = @ffi_file.mtime k
          end
        end
  
        def tick_auto_test_discover_tests
          test_files = list_files "tests"
          test_files.each do |f|
            test_path = "tests/#{f}"
            if !@required_files.include? test_path
              if f.end_with? "tests.rb"
                log "* INFO: Test =#{test_path}= found and added to hotload file list."
                reload_if_needed test_path, true
                @required_files << test_path
                @auto_test_files[test_path] = { current: @ffi_file.mtime(test_path), last: @ffi_file.mtime(test_path) }
              end
            end
          end
        end
      end # end autotest
    end # end runtime
  end # end gtk

#+end_src

** runtime/autocomplete.rb
#+begin_src ruby
  # ./dragon/runtime/autocomplete.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # autocomplete.rb has been released under MIT (*only this file*).
  
  module GTK
    class Runtime
      module Autocomplete
        def autocomplete_parse opts
          if opts[:file] && !opts[:text]
            opts[:text] = read_file opts[:file]
          end
  
          text  = opts[:text]
          index = opts[:index]
          sum   = 0
          lines = text.each_line.to_a.map do |l|
            sum += l.length
            { line: l, length: l.length, sum: sum }
          end
          cursor_line   = lines.find { |l| l[:sum] >= index }
          previous_line = lines.find { |l| l[:sum] < index }
          previous_line ||= { sum: 0 }
          if cursor_line
            sub_index       = index - previous_line[:sum]
            word            = (cursor_line[:line][0..sub_index - 1]).strip
            token           = (word.split " ")[-1]
            dots            = (token.split ".").flat_map { |s| s.split "[" }.flat_map { |s| s.split "]" }.flat_map { |s| s.split "(" }.flat_map { |s| s.split ")" }
            dot             = dots[-1]
          end
  
          {
            text:          opts[:text],
            file:          opts[:file],
            index:         opts[:index],
            cursor_line:   cursor_line,
            previous_line: previous_line,
            word:          word,
            token:         token,
            dots:          dots,
            dot:           dot
          }
        end
  
        def autocomplete_filter_methods keys, *ignores
          ignores ||= []
          ignores   = [ignores].flatten
          keys   = keys.map { |k| k.to_s }
          keys   = keys.reject { |k| k.include? '"' }
                       .reject { |k| k.start_with? "'" }
                       .reject { |k| k.include? "," }
                       .reject { |k| k.start_with? "#" }
  
          @autocomplete_always_ignore ||= ["def", "end"] +
                                          [ :entity_keys_by_ref,
                                            :entity_name,
                                            :as_hash,
                                            :clear!,
                                            :created_at_elapsed,
                                            :entity_id,
                                            "entity_id=",
                                            "tick_count=",
                                            :global_created_at_elapsed,
                                            :load_entity_data!,
                                            :meta,
                                            :meta!,
                                            :new?,
                                            :old?,
                                            :__original_eq_eq__, :set!,
                                            :update_entity_keys_by_ref,
                                            :with_meta]
  
          others = @autocomplete_always_ignore +
                   ignores + keys.find_all { |k| k.to_s.to_i.to_s == k.to_s }
  
          final = (keys - (others.map { |m| m.to_s })).uniq
          final
        end
  
        def suggest_autocompletion opts
          parse_result = autocomplete_parse opts
          return [] unless parse_result[:cursor_line]
          text  = parse_result[:text]
          word  = parse_result[:word]
          token = parse_result[:token]
          dots  = parse_result[:dots]
          dot   = parse_result[:dot]
  
          return [] if word.strip.start_with? "#"
  
          if word[-1] == "." && token
            @autocomplete_lookup ||= {
              'args'     => lambda { $gtk.args.autocomplete_methods },
              'inputs'   => lambda { $gtk.args.inputs.autocomplete_methods },
              'geometry' => lambda { $gtk.args.geometry.autocomplete_methods },
              'assert'   => lambda { GTK::Assert.instance_methods(false) },
              'outputs'  => lambda { $gtk.args.outputs.autocomplete_methods },
              'layout'   => lambda { $gtk.args.layouts.autocomplete_methods },
              'keyboard' => lambda { $gtk.args.keyboard.autocomplete_methods },
              'controller_one' => lambda { $gtk.args.controller_one.autocomplete_methods },
              'controller_two' => lambda { $gtk.args.controller_one.autocomplete_methods },
              'controller_three' => lambda { $gtk.args.controller_one.autocomplete_methods },
              'controller_four' => lambda { $gtk.args.controller_one.autocomplete_methods },
              'key_down' => lambda do
                if dots.include? "keyboard"
                  $gtk.args.keyboard.key_down.autocomplete_methods
                else
                  $gtk.args.controller_one.key_down.autocomplete_methods
                end
              end,
              'key_up'   => lambda do
                if dots.include? "keyboard"
                  $gtk.args.keyboard.key_up.autocomplete_methods
                else
                  $gtk.args.controller_one.key_up.autocomplete_methods
                end
              end,
              'state'    => lambda { $gtk.args.state.autocomplete_methods },
              'fn'       => lambda { $gtk.args.fn.autocomplete_methods },
              '$gtk'     => lambda { $gtk.autocomplete_methods },
              'gtk'      => lambda { $gtk.autocomplete_methods },
              'mouse'    => lambda { $gtk.args.inputs.mouse.autocomplete_methods },
              'click'    => lambda { [:x, :y, :point] }
            }
  
            lookup = @autocomplete_lookup
  
            lookup_result = lookup[dot]
  
            return autocomplete_filter_methods lookup_result.call if lookup_result
  
            if dot[0].upcase == dot[0] && (Object.const_defined? dot.to_sym)
              return (Object.const_get dot.to_sym).autocomplete_methods
            end
  
            start_collecting = false
            dots_after_state = dots.find_all do |s|
              if s == "state"
                start_collecting = true
                false
              else
                start_collecting
              end
            end
  
            target = $gtk.args.state
            dots_after_state.each do |k|
              target = target.as_hash[k.to_sym] if target.respond_to? :as_hash
            end
  
            if target.respond_to? :as_hash
              return autocomplete_filter_methods target.as_hash.keys
            else
              return autocomplete_filter_methods target.autocomplete_methods
            end
          end
  
  
          text = text.each_line.reject { |l| l.strip.start_with? "#" }.join "\n"
          text = text.each_line.map { |l| l.split("#").first }.join "\n"
          text.gsub!("[", " ")
          text.gsub!("]", " ")
          text.gsub!("(", " ")
          text.gsub!(")", " ")
          text.gsub!(":", "")
          text.gsub!(".", " ")
          text.gsub!("=", " ")
          return (autocomplete_filter_methods (text.split " "),
                                              :gtk, :false, :true, :args, :suppress_mailbox, :end)
        end
      end # end Autocomplete
    end # end Runtime
  end # end GTK

#+end_src

** runtime/benchmark.rb
#+begin_src ruby
  # ./dragon/runtime/benchmark.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # benchmark.rb has been released under MIT (*only this file*).
  
  module GTK
    class Runtime
      module Benchmark
        def benchmark_single iterations, name, proc
          idx = 0
          r = nil
          time_start = Time.now
          while idx < iterations
            r = proc.call
            idx += 1
          end
          result = (Time.now - time_start).round 3
  
          { name: name,
            time: result,
            time_ms: (result * 1000).to_i }
        end
  
        def benchmark opts = {}
          iterations = opts.iterations
          procs = opts.find_all { |k, v| v.respond_to? :call }
  
          times = procs.map do |(name, proc)|
            benchmark_single iterations, name, proc
          end.sort_by { |r| r.time }
  
          first_place = times.first
          second_place = times.second || first_place
  
          times = times.map do |candidate|
            average_time = first_place.time
  
            difference_percentage = 0
            if average_time == 0
              difference_percentage = 0
            elsif average_time == candidate.time
              difference_percentage = 0
            else
              difference_percentage = ((((candidate.time * 1000) / (first_place.time * 1000))) * 100).round
            end
  
            difference_time = ((first_place.time - candidate.time) * 1000).round
            candidate.merge(difference_percentage: difference_percentage,
                            difference_time: difference_time)
          end
  
          summary = <<-S
  
  * BENCHMARK RESULT: #{first_place.name} is fastest
  ** Caller: #{(caller || []).first}
  ** Iterations: #{iterations}
  S
          too_small_to_measure = false
          if (first_place.time + second_place.time) == 0
            too_small_to_measure = true
            difference_percentage = 0
          summary = <<-S
  
  * BENCHMARK RESULT: inconclusive
  ** Caller: #{(caller || []).first}
  ** Iterations: #{iterations}
  S
            summary += <<-S
  ** Average time for experiments were too small. Increase the number of iterations.
  S
          else
            difference_percentage = ((((second_place.time * 1000) / (first_place.time * 1000))) * 100).round
          end
  
          difference_time = first_place.time.-(second_place.time).*(1000).abs.round
  
          r = {
            iterations: iterations,
            first_place: first_place,
            second_place: second_place,
            difference_time: difference_time,
            difference_percentage: difference_percentage,
            times: times,
            too_small_to_measure: too_small_to_measure
          }
  
          log_message = []
          only_one_result = first_place.name == second_place.name
  
          if only_one_result
          summary = <<-S
  
  * BENCHMARK RESULT: #{r.first_place.name} completed in #{r.first_place.time_ms}ms.
  S
          else
            summary += <<-S
  ** Fastest:    #{r.first_place.name}
  ** Second:     #{r.second_place.name}
  ** Margin %:   #{r.second_place.name} was #{r.difference_percentage}% slower than #{r.first_place.name}
  ** Margin ms:  #{r.second_place.name} took #{r.difference_time.abs}ms longer than #{r.first_place.name} (#{r.first_place.time_ms}ms vs #{r.second_place.time_ms}ms)
  ** Times:
  #{r.times.map { |t| "*** #{t.name}: #{t.time_ms}ms (#{t.difference_percentage}% #{t.difference_time.abs}ms)." }.join("\n")}
  S
          end
  
          log summary
          r
        end
      end
    end
  end

#+end_src

** runtime/download_stb_rb.rb
#+begin_src ruby
  # ./dragon/runtime/download_stb_rb.rb
  # coding: utf-8
  # Copyright 2023 DragonRuby LLC
  # MIT License
  # download_stb_rb.rb has been released under MIT (*only this file*).
  
  module GTK
    class Runtime
      module DownloadStbRb
        def download_stb_rb_print_usage
          puts <<~S
          * INFO: download_stb_rb usage.
          From the DragonRuby console enter:
  
          #+begin_src ruby
            $gtk.download_stb_rb GITHUB_URL_TO_FILE_ENDING_IN_RB
          #+end_src
  
          OR
  
          #+begin_src ruby
            $gtk.download_stb_rb USER_NAME, REPO_NAME, FILE_NAME_ENDING_IN_RB
          #+end_src
  
          If the code you are trying to download isn't a github repository, then
          consider using
  
          #+begin_src ruby
            $gtk.download_stb_rb_raw DOWNLOAD_URL_TO_TEXT_CONTENT, SAVE_PATH
          #+end_src
          S
        end
  
        def download_stb_rb_raw download_url, save_path, metadata = {}
          entry = metadata.merge download_url: download_url, save_path: save_path
          entry_to_return = entry.copy
          @download_stb_rb_requests[download_url] = entry
          @download_stb_rb_requests[download_url].request = $gtk.http_get(download_url)
          entry_to_return
        end
  
        def download_stb_rb url_or_user_name = nil, repo_name = nil, file_name = nil
          @download_stb_rb_requests ||= {}
          if url_or_user_name && repo_name && file_name
            resolved_user_name = url_or_user_name
            resolved_repo_name = repo_name
            resolved_file_name = file_name
            raw_content_url = "https://raw.githubusercontent.com/#{resolved_user_name}/#{resolved_repo_name}/main/#{resolved_file_name}"
          elsif url_or_user_name && !repo_name && !file_name
            if !url_or_user_name.include? "github.com"
              download_stb_rb_print_usage
              raise "* ERROR: Only github.com url's are currently supported."
            end
  
            if !url_or_user_name.end_with? ".rb"
              download_stb_rb_print_usage
              raise "* ERROR: The url must point to a single file (url must end in .rb)."
            end
  
            raw_content_url = url_or_user_name.gsub("github.com", "raw.githubusercontent.com")
                                             .gsub("/blob/", "/")
  
            resolved_user_name = url_or_user_name.split("github.com/").last.split("/").first.strip
            resolved_file_name = url_or_user_name.split("/").last.strip
            resolved_repo_name = url_or_user_name.split(resolved_user_name).last.split("/").reject(&:empty?).first.strip
          else
            download_stb_rb_print_usage
  
            return
          end
  
          return if @download_stb_rb_requests.has_key? raw_content_url
  
          save_path = File.join(resolved_user_name, resolved_repo_name, resolved_file_name)
  
          puts "* INFO: invoking download_stb_rb"
          puts "** user_name:       #{resolved_user_name}"
          puts "** repo_name:       #{resolved_repo_name}"
          puts "** file_name:       #{resolved_file_name}"
          puts "** raw_content_url: #{raw_content_url}"
  
          metadata = {
            user_name:       resolved_user_name,
            repo_name:       resolved_repo_name,
            file_name:       resolved_file_name
          }
  
          download_stb_rb_raw raw_content_url, save_path, metadata
        end
  
        def tick_download_stb_rb
          return if !Kernel.tick_count.zmod? 60
  
          @download_stb_rb_requests ||= {}
  
          @download_stb_rb_requests.each do |url, entry|
            if entry.request.http_response_code == 200 && entry.request.complete
              $gtk.write_file entry.save_path, entry.request.response_data
              puts <<~S
  
                   * INFO: File written to #{entry.save_path}
                   Verify the contents of the file and then add the following to the top of main.rb:
                   #+begin_src ruby
                     require "#{entry.save_path}"
                   #+end_src
                   S
              $gtk.show_console
            elsif entry.request.http_response_code != 200 && entry.request.complete
              puts <<~S
  
                   * ERROR: Failed to download #{url}.
                   Response code: #{entry.request.http_response_code}
                   S
              $gtk.show_console
            end
          end
  
          @download_stb_rb_requests.reject! { |url, entry| entry.request.complete }
        rescue Exception => e
          @download_stb_rb_requests.clear
          raise e
        end
      end # end DownloadStbRb module
    end # end Runtime class
  end # end GTK module

#+end_src

** runtime/draw.rb
#+begin_src ruby
  # ./dragon/runtime/draw.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # draw.rb has been released under MIT (*only this file*).
  
  module GTK
    class Runtime
      module Draw
        def draw_solid s
          return unless s
          if s.respond_to? :draw_override
            s.draw_override @ffi_draw
          else
            s = s.as_hash if s.is_a? OpenEntity
            w = s.w
            h = s.h
            anchor_x = 0
            anchor_y = 0
            anchor_x = s.anchor_x if s.respond_to? :anchor_x
            anchor_y = s.anchor_y if s.respond_to? :anchor_y
            if !w && !h
              @ffi_draw.draw_triangle s.x, s.y, s.x2, s.y2, s.x3, s.y3,
                                      s.r, s.g, s.b, s.a,
                                      nil, nil, nil, nil, nil, nil, nil,
                                      (s.blendmode_enum || 1)
            else
              @ffi_draw.draw_solid_3 s.x, s.y, w, h,
                                     s.r, s.g, s.b, s.a,
                                     (s.blendmode_enum || 1), anchor_x, anchor_y
            end
          end
        rescue Exception => e
          raise_conversion_for_rendering_failed s, e, :solid
        end
  
        def draw_sprite s
          return unless s
          if s.respond_to? :draw_override
            s.draw_override @ffi_draw
          else
            s = s.as_hash if s.is_a? OpenEntity
            w = s.w
            h = s.h
            if !w && !h
              @ffi_draw.draw_triangle s.x, s.y, s.x2, s.y2, s.x3, s.y3,
                                      s.r || 255,
                                      s.g || 255,
                                      s.b || 255,
                                      s.a || 255,
                                      s.path || 'pixel',
                                      s.source_x,
                                      s.source_y,
                                      s.source_x2,
                                      s.source_y2,
                                      s.source_x3,
                                      s.source_y3,
                                      (s.blendmode_enum || 1)
            else
              if s.is_a? Hash
                @ffi_draw.draw_sprite_hash s
              else
                anchor_x = nil
                anchor_x = s.anchor_x if s.respond_to? :anchor_x
  
                anchor_y = nil
                anchor_y = s.anchor_y if s.respond_to? :anchor_y
  
                @ffi_draw.draw_sprite_5 s.x, s.y, w, h,
                                        (s.path || 'pixel').to_s,
                                        s.angle,
                                        s.a, s.r, s.g, s.b,
                                        s.tile_x, s.tile_y, s.tile_w, s.tile_h,
                                        !!s.flip_horizontally, !!s.flip_vertically,
                                        s.angle_anchor_x, s.angle_anchor_y,
                                        s.source_x, s.source_y, s.source_w, s.source_h,
                                        (s.blendmode_enum || 1), anchor_x, anchor_y
              end
            end
          end
        rescue Exception => e
          raise_conversion_for_rendering_failed s, e, :sprite
        end
  
        def draw_screenshot s
          return unless s
          if s.respond_to? :draw_override
            s.draw_override @ffi_draw
          else
            s = s.as_hash if s.is_a? OpenEntity
            @ffi_draw.draw_screenshot (s.path || '').to_s,
                                      s.x, s.y, s.w, s.h,
                                      s.angle,
                                      s.a, s.r, s.g, s.b,
                                      s.tile_x, s.tile_y, s.tile_w, s.tile_h,
                                      !!s.flip_horizontally, !!s.flip_vertically,
                                      s.angle_anchor_x, s.angle_anchor_y,
                                      s.source_x, s.source_y, s.source_w, s.source_h
          end
        rescue Exception => e
          raise_conversion_for_rendering_failed s, e, :screenshot
        end
  
        def draw_label l
          return unless l
          if l.respond_to? :draw_override
            l.draw_override @ffi_draw
          else
            l = l.as_hash if l.is_a? OpenEntity
  
            size_px = if l.respond_to? :size_px
                        l.size_px
                      else
                        nil
                      end
  
            anchor_x = if l.respond_to? :anchor_x
                         l.anchor_x
                       else
                         nil
                       end
  
            anchor_y = if l.respond_to? :anchor_y
                         l.anchor_y
                       else
                         nil
                       end
  
            @ffi_draw.draw_label_5 l.x, l.y,
                                   (l.text || '').to_s,
                                   l.size_enum, l.alignment_enum,
                                   l.r, l.g, l.b, l.a,
                                   l.font,
                                   (l.vertical_alignment_enum || 2),
                                   (l.blendmode_enum || 1), size_px,
                                   anchor_x, anchor_y
          end
        rescue Exception => e
          raise_conversion_for_rendering_failed l, e, :label
        end
  
        def draw_line l
          return unless l
          if l.respond_to? :draw_override
            l.draw_override @ffi_draw
          else
            l = l.as_hash if l.is_a? OpenEntity
            if l.x2
              @ffi_draw.draw_line_2 l.x, l.y, l.x2, l.y2,
                                    l.r, l.g, l.b, l.a,
                                    (l.blendmode_enum || 1)
            else
              w = l.w || 0
              w = 1 if w == 0
              h = l.h || 0
              h = 1 if h == 0
              @ffi_draw.draw_line_2 l.x, l.y,
                                    l.x + w - 1,
                                    l.y + h - 1,
                                    l.r, l.g, l.b, l.a,
                                    (l.blendmode_enum || 1)
            end
          end
        rescue Exception => e
          raise_conversion_for_rendering_failed l, e, :line
        end
  
        def draw_border s
          return unless s
          if s.respond_to? :draw_override
            s.draw_override @ffi_draw
          else
            s = s.as_hash if s.is_a? OpenEntity
            anchor_x = 0
            anchor_y = 0
            anchor_x = s.anchor_x if s.respond_to? :anchor_x
            anchor_y = s.anchor_y if s.respond_to? :anchor_y
            @ffi_draw.draw_border_3 s.x, s.y, s.w, s.h,
                                    s.r, s.g, s.b, s.a,
                                    (s.blendmode_enum || 1), anchor_x, anchor_y
          end
        rescue Exception => e
          raise_conversion_for_rendering_failed s, e, :border
        end
  
        def draw_screenshots
          @args.outputs.screenshots.each { |s| draw_screenshot s }
        end
  
        def pixel_arrays
          @args.pixel_arrays.each { |k,v|
            if v.pixels.length == (v.width * v.height)  # !!! FIXME: warning? exception? Different API?
              @ffi_draw.upload_pixel_array k.to_s, v.width.to_i, v.height.to_i, v.pixels
            end
          }
        rescue Exception => e
          pause!
          pretty_print_exception_and_export! e
        end
  
        def draw_primitive p
          return unless p
  
          if p.primitive_marker == :solid
            return draw_solid p
          elsif p.primitive_marker == :sprite
            return draw_sprite p
          elsif p.primitive_marker == :label
            return draw_label p
          elsif p.primitive_marker == :line
            return draw_line p
          elsif p.primitive_marker == :border
            return draw_border p
          else
            raise <<-S
  * ERROR:
  #{p}
  
  I don't know how to use the above #{p.class} with SDL's FFI. Please
  add a method on the object called ~primitive_marker~ that
  returns :solid, :sprite, :label, :line, or :border. If the object
  is a Hash, please add { primitive_marker: :PRIMITIVE_SYMBOL } to the Hash.
  
  S
          end
        rescue Exception => e
          pause!
          pretty_print_exception_and_export! e
        end
      end
    end
  end

#+end_src

** runtime/framerate.rb
#+begin_src ruby
  # ./dragon/runtime/framerate.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # framerate.rb has been released under MIT (*only this file*).
  
  module GTK
    class Runtime
      module Framerate
        def framerate_init
          @tick_time = Time.new.to_i
        end
  
        def delta_framerate
          (current_framerate || 0) - (@previous_framerate || 0)
        end
  
        def disable_framerate_warning!
          @framerate_disable_warning = true
          log "Framerate warning disabled. To re-enable, call ~$gtk.enable_framerate_warning!~"
        end
  
        def enable_framerate_warning!
          @framerate_disable_warning = false
          log "Framerate warning re-enabled. To disable, call ~$gtk.disable_framerate_warning!~"
        end
  
        def reset_framerate_calculation
          @tick_speed_sum = 0
          @tick_speed_count = 0
          @framerate_warning_message_shown_at = -1
        end
  
        def framerate_should_show_warning?
          return false if @framerate_disable_warning
          return false if Kernel.global_tick_count < 0
          return false if (Kernel.global_tick_count - (@last_reset_global_at || 0)) < 1800
          return false if (Kernel.global_tick_count - (@last_reload_complete_global_at || 0)) < 1800
          has_debounce_elapsed = if @framerate_warning_message_shown_at == -1
                                   true
                                 else
                                   (Kernel.global_tick_count - @framerate_warning_message_shown_at) > 1800
                                 end
          !(@console.visible? || @recording.is_replaying?) && has_debounce_elapsed
        end
  
        def check_framerate
          if @framerate_diagnostics_requested
            log "================================"
            @framerate_diagnostics_requested = false
            log framerate_get_diagnostics if args.inputs.keyboard.has_focus
          end
  
          if !@paused
            if @tick_time
              @tick_speed_count += 1
              @tick_speed_sum += Time.now.to_i - @tick_time
              if @tick_speed_count > 120
                if framerate_below_threshold?
                  @framerate_warning_message_shown_at ||= -1
                  if framerate_should_show_warning?
                    GTK::Log.puts_important("* WARNING: Framerate below 30fps for over 120 frames.", message_code: [:framerate_warning])
                    log(framerate_warning_message)
                    @framerate_warning_message_shown_at = Kernel.global_tick_count
                    @framerate_captured_diagnostics = {
                      solids_length: @args.outputs.solids.length,
                      static_solids_length: @args.outputs.static_solids.length,
                      sprites_length: @args.outputs.sprites.length,
                      static_sprites_length: @args.outputs.static_sprites.length,
                      primitives_length: @args.outputs.primitives.length,
                      static_primitives_length: @args.outputs.static_primitives.length,
                      labels_length: @args.outputs.labels.length,
                      static_labels_length: @args.outputs.static_labels.length,
                      lines_length: @args.outputs.lines.length,
                      static_lines_length: @args.outputs.static_lines.length,
                      borders_length: @args.outputs.borders.length,
                      static_borders_length: @args.outputs.static_borders.length,
                      debug_length: @args.outputs.debug.length,
                      static_debug_length: @args.outputs.static_debug.length,
                    }
                  end
                end
              end
            end
  
            @tick_time = Time.new.to_i
          else
            reset_framerate_calculation
          end
        rescue
          reset_framerate_calculation
        end
  
        def framerate_diagnostics
          # request framerate diagnostics to be printed at the end of tick
          @framerate_diagnostics_requested = true
        end
  
        def framerate_below_threshold?
          return current_framerate < 30 && Kernel.tick_count > 60
        end
  
        def current_framerate
          return 60 if !@tick_speed_sum || !@tick_speed_sum
          r = 100.fdiv(@tick_speed_sum.fdiv(@tick_speed_count) * 100)
          if (r.nan? || r.infinite? || r > 58)
            r = 60
          else
            r = r.round
          end
          r || 60
        rescue
          60
        end
      end # module Framerate
    end # end class Runtime
  end # end module GTK

#+end_src

** runtime/framerate_diagnostics.rb
#+begin_src ruby
  # ./dragon/runtime/framerate_diagnostics.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # framerate_diagnostics.rb has been released under MIT (*only this file*).
  
  module GTK
    class Runtime
      module FramerateDiagnostics
        def get_framerate_diagnostics
          framerate_get_diagnostics
        end
  
        def framerate_get_diagnostics
          @framerate_captured_diagnostics ||= {}
  
          <<-S
  * INFO: Framerate Diagnostics
  You can display these diagnostics using:
  
  #+begin_src
    def tick args
      # ....
  
      # IMPORTANT: Put this at the END of the ~tick~ method.
      args.outputs.debug << args.gtk.framerate_diagnostics_primitives
    end
  #+end_src
  
  ** Draw Calls: ~<<~ Invocation Perf Counter
  Here is how many times ~args.outputs.PRIMITIVE_ARRAY <<~ was called:
  
    #{$perf_counter_outputs_push_count} times invoked.
  
  If the number above is high, consider batching primitives so you can lower the invocation of ~<<~. For example.
  
  Instead of:
  
  #+begin_src
    args.state.enemies.map do |e|
      e.alpha = 128
      args.outputs.sprites << e # <-- ~args.outputs.sprites <<~ is invoked a lot
    end
  #+end_src
  
  Do this:
  
  #+begin_src
    args.outputs.sprites << args.state
                                .enemies
                                .map do |e| # <-- ~args.outputs.sprites <<~ is only invoked once.
      e.alpha = 128
      e
    end
  #+end_src
  
  ** Array Primitives
  ~Primitives~ represented as an ~Array~ (~Tuple~) are great for prototyping, but are not as performant as using a ~Hash~.
  
  Here is the number of ~Array~ primitives that were encountered:
  
    #{$perf_counter_primitive_is_array} Array Primitives.
  
  If the number above is high, consider converting them to hashes. For example.
  
  Instead of:
  
  #+begin_src
    args.outputs.sprites << [0, 0, 100, 100, 'sprites/enemy.png']
  #+end_src
  
  Do this:
  
  #+begin_src
    args.outputs.sprites << { x: 0,
                              y: 0,
                              w: 100,
                              h: 100,
                              path: 'sprites/enemy.png' }
  #+end_src
  
  We will notify of places where that use Array Primitives if you add the following
  to your ~tick~ method.
  
  #+begin_src
    def tick args
      # add the following line to the top of your tick method
      $gtk.warn_array_primitives!
    end
  #+end_src
  
  ** Primitive Counts
  Here are the draw counts ordered by lowest to highest z order:
  
  PRIMITIVE          COUNT
  solids:            #{@framerate_captured_diagnostics.solids_length}
  static_solids:     #{@framerate_captured_diagnostics.static_solids_length}
  sprites:           #{@framerate_captured_diagnostics.sprites_length}
  static_sprites:    #{@framerate_captured_diagnostics.static_sprites_length}
  primitives:        #{@framerate_captured_diagnostics.primitives_length}
  static_primitives: #{@framerate_captured_diagnostics.static_primitives_length}
  labels:            #{@framerate_captured_diagnostics.labels_length}
  static_labels:     #{@framerate_captured_diagnostics.static_labels_length}
  lines:             #{@framerate_captured_diagnostics.lines_length}
  static_lines:      #{@framerate_captured_diagnostics.static_lines_length}
  borders:           #{@framerate_captured_diagnostics.borders_length}
  static_borders:    #{@framerate_captured_diagnostics.static_borders_length}
  debug:             #{@framerate_captured_diagnostics.debug_length}
  static_debug:      #{@framerate_captured_diagnostics.static_debug_length}
  
  ** Additional Help
  Come to the DragonRuby Discord channel if you need help troubleshooting performance issues. http://discord.dragonruby.org.
  
  Source code for these diagnostics can be found at: [[https://github.com/dragonruby/dragonruby-game-toolkit-contrib/]]
  S
        end
  
        def framerate_warning_message
          <<-S
  * WARNING: The average FPS was #{current_framerate}.
  - $gtk.get_framerate_diagnostics  : Get framerate diagnostics.
  - $gtk.disable_framerate_warning! : Disable this warning.
    S
        end
  
        def current_framerate_primitives
          framerate_diagnostics_primitives
        end
  
        def framerate_diagnostics_primitives
          [
            { x: 0, y: 93.from_top, w: 500, h: 93, a: 128 }.solid!,
            {
              x: 5,
              y: 5.from_top,
              text: "More Info via DragonRuby Console: $gtk.framerate_diagnostics",
              r: 255,
              g: 255,
              b: 255,
              size_enum: -2
            }.label!,
            {
              x: 5,
              y: 20.from_top,
              text: "FPS: %.2f" % args.gtk.current_framerate,
              r: 255,
              g: 255,
              b: 255,
              size_enum: -2
            }.label!,
            {
              x: 5,
              y: 35.from_top,
              text: "Draw Calls: #{$perf_counter_outputs_push_count}",
              r: 255,
              g: 255,
              b: 255,
              size_enum: -2
            }.label!,
            {
              x: 5,
              y: 50.from_top,
              text: "Array Primitives: #{$perf_counter_primitive_is_array}",
              r: 255,
              g: 255,
              b: 255,
              size_enum: -2
            }.label!,
            {
              x: 5,
              y: 65.from_top,
              text: "Mouse: #{@args.inputs.mouse.point}",
              r: 255,
              g: 255,
              b: 255,
              size_enum: -2
            }.label!,
          ]
        end
  
      end
    end
  end

#+end_src

** runtime/hotload.rb
#+begin_src ruby
  # ./dragon/runtime/hotload.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # hotload.rb has been released under MIT (*only this file*).
  
  module GTK
    class Runtime
      # @visibility private
      module Hotload
        def hotload_init
          @hotload_if_needed = 0
          @mailbox_if_needed = 0
  
          # schema for file_mtimes
          # { FILE_PATH: { current: (Time as Fixnum),
          #                last:    (Time as Fixnum) },
          #   FILE_PATH: { current: (Time as Fixnum),
          #                last:    (Time as Fixnum) } }
          @file_mtimes = { }
  
          @suppress_mailbox = true
          files_to_reload.each { |f| init_mtimes f }
          init_mtimes 'app/mailbox.rb'
        end
  
        def hotload_on_write_file file_name
          return unless file_name.include? 'mailbox.rb'
          @mailbox_if_needed = :force
        end
  
        def files_to_reload
          if @rcb_release_mode
            core_files_to_reload + @required_files
          else
            [
              'dragon/docs.rb',
              'dragon/help.rb',
              'dragon/kernel_docs.rb',
              'dragon/kernel.rb',
              'dragon/easing.rb',
              'dragon/top_level.rb',
              'dragon/log.rb',
              'dragon/geometry.rb',
              'dragon/attr_gtk.rb',
              'dragon/attr_sprite.rb',
              'dragon/object.rb',
              'dragon/object_matrix.rb',
              'dragon/class.rb',
              'dragon/string.rb',
              'dragon/entity.rb',
              'dragon/strict_entity.rb',
              'dragon/open_entity.rb',
              'dragon/serialize.rb',
              'dragon/primitive.rb',
              'dragon/nil_class_false_class.rb',
              'dragon/symbol.rb',
              'dragon/numeric_deprecated.rb',
              'dragon/numeric.rb',
              'dragon/hash_deprecated.rb',
              'dragon/hash.rb',
              'dragon/outputs_deprecated.rb',
              'dragon/array_docs.rb',
              'dragon/array.rb',
              'dragon/outputs.rb',
              'dragon/inputs.rb',
              'dragon/mouse_docs.rb',
              'dragon/recording.rb',
              'dragon/grid.rb',
              'dragon/layout.rb',
              'dragon/args_deprecated.rb',
              'dragon/fn.rb',
              'dragon/args.rb',
              'dragon/args_docs.rb',
              'dragon/console_prompt.rb',
              'dragon/console_menu.rb',
              'dragon/console_evaluator.rb',
              'dragon/console.rb',
              'dragon/assert.rb',
              'dragon/tests.rb',
              'dragon/controller_config.rb',
              'dragon/runtime/draw.rb',
              'dragon/runtime/deprecated.rb',
              'dragon/runtime/framerate.rb',
              'dragon/runtime/framerate_diagnostics.rb',
              'dragon/runtime/c_bridge.rb',
              'dragon/runtime/hotload.rb',
              'dragon/runtime/backup.rb',
              'dragon/runtime/async_require.rb',
              'dragon/runtime/autocomplete.rb',
              'dragon/runtime/texture_atlas.rb',
              'dragon/runtime/download_stb_rb.rb',
              'dragon/runtime/auto_test.rb',
              'dragon/api.rb',
              'dragon/runtime.rb',
              'dragon/runtime_docs.rb',
              'dragon/trace.rb',
              'dragon/readme_docs.rb',
              'dragon/hotload_client.rb',
              'dragon/wizards.rb',
              'dragon/ios_wizard.rb',
              'dragon/itch_wizard.rb',
              'dragon/runtime/benchmark.rb',
              'dragon/tweetcart.rb',
            ] + core_files_to_reload + @required_files
          end
        end
  
        def core_files_to_reload
          [
            'repl.rb',
            'app/main.rb',
            'app/repl.rb',
            'app/tests.rb',
            'app/test.rb',
            'app/stdin.rb'
          ]
        end
  
        def init_mtimes file
          @file_mtimes[file] ||= { current: @ffi_file.mtime(file),
                                   last: @ffi_file.mtime(file) }
        end
  
        def hotload_source_files
          @hotload_if_needed += 1
          return unless @hotload_if_needed == 60
          @hotload_if_needed = 0
          files_to_reload.each { |f| reload_if_needed f }
        end
  
        def mailbox_timeout
          if @suppress_mailbox
            60
          else
            3
          end
        end
  
        def check_mailbox
          if @mailbox_if_needed == :force # lol
            reload_if_needed 'app/mailbox.rb', true
            @mailbox_if_needed = 1
            return
          end
          @mailbox_if_needed += 1
          return unless @mailbox_if_needed.mod_zero? mailbox_timeout
          @mailbox_if_needed = 1
          reload_if_needed 'app/mailbox.rb'
        end
  
        def tick_hotload
          return if Kernel.tick_count <= 0 && !paused?
          hotload_source_files
          check_mailbox
        end
  
        def on_load_succeeded file
          self.files_reloaded << file
          self.reloaded_files << file
          Trace.untrace_classes!
        end
  
        def reset_all_mtimes
          @file_mtimes.each do |file, _|
            @file_mtimes[file].current = @ffi_file.mtime(file)
            @file_mtimes[file].last    = @file_mtimes[file].current
          end
  
          files_to_reload.each do |file, _|
            @file_mtimes[file] ||= {}
            @file_mtimes[file].current = @ffi_file.mtime(file)
            @file_mtimes[file].last    = @file_mtimes[file].current
          end
        end
  
        def reload_if_needed file, force = false
          @file_mtimes[file] ||= { current: @ffi_file.mtime(file), last: @ffi_file.mtime(file) }
          @file_mtimes[file].current = @ffi_file.mtime(file)
          return if !force && @file_mtimes[file].current == @file_mtimes[file].last
          on_load_succeeded file if reload_ruby_file file
          @file_mtimes[file].last = @file_mtimes[file].current
        end
      end
    end
  end

#+end_src

** runtime/messages.rb
#+begin_src ruby
  # ./dragon/runtime/messages.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # notify.rb has been released under MIT (*only this file*).
  
  module GTK
    class Runtime
      module Messages
        def messages_stop_music_is_deprecated
          <<-S
  * WARNING: ~Runtime#stop_music~ is deprecated and will be removed in future versions.
  
  Sounds that loop are no longer supported via args.outputs.sounds:
  
  1. Migrate over to ~args.audio~ (for more info see type ~args.docs_audio~ in the Console).
  2. Delete the usage of ~stop_music~.
  
  For details
  S
        end
  
        def messages_looping_sounds_behavior_change
        <<-S
  * WARNING: ~Outputs#sounds~ no longer supports looping (one-time sounds are still supported).
  
  Use ~Args#audio~ instead for looping sounds.
  
  Here's how to migrate looping sounds. Here's an example of bg music being started on tick zero:
  
  #+begin_src
    def tick args
      if args.state.tick_count == 0
        # bg music will not loop after completion
        # use args.audio to create a looping (see below)
        args.outputs.sounds << "sounds/bg-music.ogg"
      end
    end
  #+end_src
  
  The example above becomes:
  
  #+begin_src
    def tick args
      if args.state.tick_count == 0
        args.audio[:bg_music] = { input: "sounds/bg-music.ogg", looping: true }
      end
    end
  #+end_src
  
  Additional options that can be passed to ~Args#audio~:
  
  #+begin_src
    def tick args
      if args.state.tick_count == 0
        args.audio[:bg_music] = {
          input:  "sounds/bg-music.ogg",
          looping: true,
          gain:    1.0,
          pitch:   1.0,
          paused:  false,
          # additional keys/values to help with context (metadata) can be added safely
        }
      end
    end
  #+end_src
  
  You can use ~Args#audio~ for one time sounds too.
  
  The following is still valid/supported:
  
  #+begin_src
    def tick args
      # play a non-looping sound every second
      if (args.state.tick_count % 60) == 0
        args.outputs.sounds << "sounds/coin.wav"
      end
    end
  #+end_src
  
  But can be written to use ~args.audio~ as:
  
  #+begin_src
    def tick args
      if (args.state.tick_count % 60) == 0
        args.audio[:coin] = { input: "sounds/coin.wav" }
      end
    end
  #+end_src
  S
        end # end looping_sounds_behavior_change_message
      end # end messages module
    end # end runtime class
  end # end gtk

#+end_src

** runtime/notify.rb
#+begin_src ruby
  # ./dragon/runtime/notify.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # notify.rb has been released under MIT (*only this file*).
  
  module GTK
    module Notify
      def notify message, duration = 300
        notify! message, duration
      end
  
      def notify! message, duration = 300
        return if self.production
        message ||= ""
        message = "#{message}"
        return if @notification_message == message
        @global_notification_at = Kernel.global_tick_count
        @notification_duration = duration
        @notification_message = message
        @console.add_text "* NOTIFY: #{message}" if message.strip.length > 0
      end
  
      def notify_subdued!
        notify! "", 60
      end
  
      def notify_extended! opts = {}
        message   = opts.message  || ""
        duration  = opts.duration || 300
        env       = opts.env      || :dev
        overwrite = opts.overwrite
        return if env != :prod && self.production
        return if !overwrite && @notification_message == message
        @global_notification_at = Kernel.global_tick_count
        @notification_duration = duration
        @notification_message = message
        @console.add_text "* NOTIFY: #{message}" if message.strip.length > 0
      end
  
      def tick_notification
        @notification_message = nil if @console.visible?
        if @notification_message && @global_notification_at.elapsed_time(Kernel.global_tick_count) < @notification_duration
          diff = @notification_duration - @global_notification_at.elapsed_time(Kernel.global_tick_count)
          alpha = @global_notification_at.global_ease(15, :identity) * 255
          if diff < 15
            alpha = @global_notification_at.+(@notification_duration - 15).global_ease(15, :flip) * 255
          end
          if @notification_message.length != 0
            @args.outputs.reserved << { x: @args.grid.left, y: args.grid.bottom, w: @logical_width, h: 40, r: 0, g: 0, b: 0, a: alpha }.solid!
            @args.outputs.reserved << { x: @args.grid.left + 60, y: @args.grid.bottom + 30, text: @notification_message, r: 255, g: 255, b: 255, a: alpha }
          end
          @args.outputs.reserved << { x: @args.grid.left + 10, y: @args.grid.bottom, w: 40, h: 40, path: 'console-logo.png', a: alpha }
        else
          @notification_message = nil
        end
      end
    end
  end

#+end_src

** runtime/process_argsv.rb
#+begin_src ruby
  # ./dragon/runtime/process_argsv.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # process_argsv.rb has been released under MIT (*only this file*).
  
  module GTK
    class Runtime
      module ProcessARGSV
        def process_argsv
          return if @argsv_processed
  
          @simulation_speed = (cli_arguments[:speed] || "1").to_i
          @simulation_speed = @simulation_speed.abs
          @simulation_speed = 1 if @simulation_speed == 0
  
          if cli_arguments.keys.include? :record
            @argsv_processed = true
            seed = cli_arguments[:seed] || 100
            log_info "--record switch found. Recording will be started with a seed value of #{seed} (--seed)."
            start_recording seed.to_i
          elsif cli_arguments.keys.include? :replay
            if Kernel.global_tick_count >=0
              @argsv_processed = true
              replay = cli_arguments[:replay] || "last_replay.txt"
              log_info "--replay switch found. Replay will be started using file [#{replay}] (--replay FILENAME) with replay speed [#{@simulation_speed}] (--speed SPEED)."
              start_replay replay, speed: @simulation_speed
            end
          elsif cli_arguments.keys.include? :eval
            @argsv_processed = true
            path = cli_arguments[:eval]
            log_info "--eval switch found. Executing code inside of #{path} before first tick executes.", subsystem="Engine"
            begin
              raise "File does not exist: #{path}" unless read_file path
              @eval_path = path
            rescue Exception => e
              log e
            end
  
            if cli_arguments.keys.include? "no-tick".to_sym
              log_info "--no-tick switch found. Exiting.", subsystem="Engine"
              @no_tick = true
            end
          elsif cli_arguments.keys.include? :test
            @argsv_processed = true
            path = cli_arguments[:test]
            log_info "--test switch found. Executing code inside of =#{path}=."
            begin
              raise "File does not exist: #{path}" unless read_file path
              @test_path = path
            rescue Exception => e
              log e
            end
  
            @no_tick = true
          else
            @argsv_processed = true
          end
        end
  
        def tick_argv
          tick_argv_eval_path
          tick_argv_test_path
        end
  
        # used for unit testing http and isn't meant
        # to be used for game dev
        def schedule_callback tick_count, &callback
          raise "Callback has already been scheduled for tick #{tick_count}. If you meant to do this, execute $gtk.scheduled_callbacks.clear first." if @scheduled_callbacks[tick_count]
          @scheduled_callbacks[tick_count] = callback
        end
  
        def quit_after_startup_eval?
          return false unless @no_tick
          # @scheduled_callbacks is used by unit testing http
          # it keeps the app from exiting until all scheduled
          # callbacks have been processed (eg we need to keep the
          # game running for unit tests around http which are async)
          last_scheduled_proc = @scheduled_callbacks.keys.sort[-1]
          return true unless last_scheduled_proc
          return Kernel.tick_count > ((last_scheduled_proc || 0) + 1)
        end
  
        def tick_argv_eval_path
          return if !@eval_path
  
          if !reload_list_history[@eval_path]
            require @eval_path
            return
          end
  
          file_history = reload_list_history[@eval_path][:history]
          eval_path_loaded = file_history.find { |entry| entry[:event] == :reload_completed }
  
          return if !eval_path_loaded
  
          request_quit if quit_after_startup_eval?
  
          @eval_path = nil
        end
  
        def tick_argv_test_path
          return if !@test_path
  
          if !reload_list_history[@test_path]
            require @test_path
            return
          end
  
          file_history = reload_list_history[@test_path][:history]
          test_path_loaded = file_history.find { |entry| entry[:event] == :reload_completed }
  
          return if !test_path_loaded
  
          $tests.start
          request_quit
        end
      end
    end
  end

#+end_src

** runtime/save_state_load_state.rb
#+begin_src ruby
  # ./dragon/runtime/save_state_load_state.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # save_state_load_state.rb has been released under MIT (*only this file*).
  
  module GTK
    class Runtime
      module SaveStateLoadState
        def save_state
          serialize_state "game_state_#{Time.now.to_i}.txt", @args.state
          serialize_state "game_state.txt", @args.state
        end
  
        def load_state
          @args.state = deserialize_state 'game_state.txt'
        end
  
        def serialize_state *opts
          maybe_file, maybe_state = opts
          if maybe_file.is_a?(String)
            file = maybe_file
            state = maybe_state
          else
            state = maybe_file
          end
  
          state.__delete_thrash_count__! if state.respond_to? :__delete_thrash_count__!
  
          result = state.to_s
  
          if file
            write_file file, result
            log_info "State with length of #{result.length} saved to file #{file}."
          end
          if result.length > 20_000
            $serialize_state_serialization_too_large = true
            log_important Help.serialization_too_large
          end
          result
        end
  
        def deserialize_state *args
          file_or_seralization, _ = args
          # Determine if we are trying to read state from a file or a bare string.
          # If it starts with { or [, it's most likely not a file.
          if file_or_seralization[0] == "{" || file_or_seralization[0] == "["
            definitely_serialization = file_or_seralization
          end
  
          # If it doesn't start with either of two serialization markers, then it's probably a file.
          # Check the disk for the file.
          if !definitely_serialization
            definitely_serialization = read_file file_or_seralization
          end
  
          # If the file isn't there, then maybe it's a serialzation without the { or [ delimeter?
          # But only if the string doesn't end in .txt or .dat or .rb
          if !definitely_serialization &&
             !file_or_seralization.strip.end_with?(".txt") &&
             !file_or_seralization.strip.end_with?(".dat") &&
             !file_or_seralization.strip.end_with?(".rb")
            definitely_serialization = file_or_seralization
          end
  
          return nil unless definitely_serialization
  
          begin
            load_data = Kernel.eval("#{definitely_serialization}")
            state = OpenEntity.parse_serialization_data load_data
            Kernel.tick_count = load_data[:tick_count] if load_data[:tick_count]
            state
          rescue Exception => e
            raise e, "Failed to eval: #{definitely_serialization}. #{e}.\nSerialization data may be corrupt."
          end
        end
  
        def parse_serialization_data value
          if value.is_a?(Hash) && value[:entity_id] && value[:entity_strict]
            o = Entity.new_entity_strict value[:entity_name], value
            o.load_entity_data! value
            return o
          elsif value.is_a?(Hash) && value[:entity_id]
            o = OpenEntity.new
            o.load_entity_data! value
            return o
          elsif value.is_a? Array
            return value.map { |entry| Entity.parse_serialization_data entry }
          else
            return value
          end
        end
      end # module SaveStateLoadState
    end # class Runtime
  end # module GTK
  
  module GTK
    class OpenEntity
      def load_entity_data! serialization_data
        self[:entity_id] = Entity.id!
  
        serialization_data.each do |k, v|
          self[k] = Entity.parse_serialization_data v
        end
  
        if serialization_data[:entity_keys_by_ref]
          serialization_data[:entity_keys_by_ref].each do |other_reference, main_reference|
            self[other_reference] = self[main_reference]
          end
        end
      rescue Exception => e
        raise <<-S
  * ERROR:
  Failed to load entity data from:
  
  #+begin_src
  #{serialization_data}
  #+end_src
  
  The save data looks to be corrupt.
  
  ** INNER EXCEPTION:
  #{e}
  S
      end
  
      def to_s
        update_entity_keys_by_ref
        @hash.to_s
      end
    end
  
    def update_entity_keys_by_ref
      @hash[:entity_keys_by_ref] = {}
  
      references = {}
  
      @hash.each do |k, v|
        if !v.is_a?(Symbol) && !v.is_a?(Integer) && !v.is_a?(Float) && !v.is_a?(String)
          references[v.object_id] ||= []
          references[v.object_id] << k
        end
      end
  
      references.each do |key, values|
        if key
          if values.length > 1
            root_value = values[0]
            values.drop(1).each do |v|
              @hash[:entity_keys_by_ref][v] = root_value if root_value
            end
          end
        end
      end
    end
  end
  
  module GTK
    class StrictEntity
      def load_entity_data! serialization_data
        self[:entity_id] = Entity.id!
  
        serialization_data.each do |k, v|
          self.class.class_eval { attr_accessor k } if !self.respond_to? :k
          self[k] = Entity.parse_serialization_data v
        end
  
        if serialization_data[:entity_keys_by_ref]
          serialization_data[:entity_keys_by_ref].each do |other_reference, main_reference|
            self[other_reference] = self[main_reference]
          end
        end
      rescue Exception => e
        raise <<-S
  * ERROR:
  Failed to load entity data from:
  
  #+begin_src
  #{serialization_data}
  #+end_src
  
  The save data looks to be corrupt.
  
  ** INNER EXCEPTION:
  #{e}
  S
      end
  
      def to_s
        update_entity_keys_by_ref
        to_hash.to_s
      end
  
      def update_entity_keys_by_ref
        @entity_keys_by_ref = {}
  
        references = {}
  
        instance_variables.each do |k|
          v = instance_variable_get k
          if !v.is_a?(Symbol) && !v.is_a?(Integer) && !v.is_a?(Float) && !v.is_a?(String)
            references[v.object_id] ||= []
            references[v.object_id] << (k.to_s.gsub "@", "").to_sym
          end
        end
  
        references.each do |key, values|
          if values.length > 1
            root_value = values[0]
            values.drop(1).each do |v|
              @entity_keys_by_ref[v] = root_value
            end
          end
        end
      end
    end
  end

#+end_src

** string.rb
#+begin_src ruby
  # ./dragon/string.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # string.rb has been released under MIT (*only this file*).
  
  class String
    include ValueType
  
    def self.wrapped_lines_recur word, rest, length, aggregate
      if word.nil?
        return aggregate
      elsif rest[0].nil?
        aggregate << word + "\n"
        return aggregate
      elsif (word + " " + rest[0]).length > length
        aggregate << word + "\n"
        return wrapped_lines_recur rest[0], rest[1..-1], length, aggregate
      elsif (word + " " + rest[0]).length <= length
        next_word = (word + " " + rest[0])
        return wrapped_lines_recur next_word, rest[1..-1], length, aggregate
      else
        log <<-S
  WARNING:
  #{word} is too long to fit in length of #{length}.
  
  S
        next_word = (word + " " + rest[0])
        return wrapped_lines_recur next_word, rest[1..-1], length, aggregate
      end
    end
  
    def char_byte
      return nil if self.length == 0
      c = self.each_char.first.bytes
      c = c.first if c.is_a? Enumerable
      c
    end
  
    def insert_character_at index, char
      t = each_char.to_a
      t = (t.insert index, char)
      t.join
    end
  
    def excluding_character_at index
      t = each_char.to_a
      t.delete_at index
      t.join
    end
  
    def excluding_last_character
      return "" if self.length <= 1
      return excluding_character_at(self.length - 1)
    end
  
    def end_with_bang?
      self[-1] == "!"
    end
  
    def without_ending_bang
      return self unless end_with_bang?
      self[0..-2]
    end
  
    def self.wrapped_lines string, length
      string.each_line.map do |l|
        l = l.rstrip
        if l.length < length
          l + "\n"
        else
          words = l.split ' '
          wrapped_lines_recur(words[0], words[1..-1], length, []).flatten
        end
      end.flatten
    end
  
    def wrapped_lines length
      String.wrapped_lines self, length
    end
  
    def wrap length
      wrapped_lines(length).join.rstrip
    end
  
    def multiline?
      include? "\n"
    end
  
    def indent_lines amount, char = " "
      self.each_line.each_with_index.map do |l, i|
        if i == 0
          l
        else
          char * amount + l
        end
      end.join
    end
  
    def quote
      "\"#{self}\""
    end
  
    def trim
      strip
    end
  
    def trim!
      strip!
    end
  
    def ltrim
      lstrip
    end
  
    def ltrim!
      lstrip!
    end
  
    def rtrim
      rstrip
    end
  
    def rtrim!
      rstrip!
    end
  
    def serialize
      self
    end
  
    # !!! FIXME: Strange bug where garbage bytes are still left over after a strip for a string.
    alias_method :__original_strip__, :strip unless String.instance_methods.include?(:__original_strip__)
    def strip
      "#{__original_strip__}"
    end
  
    def indent count, indent_char: "  ", pad_line_with_space: false
      count = 0 if count < 0
      spaces = indent_char * count
      spaces += " " if pad_line_with_space
      self.each_line.map do |l|
        "#{spaces}#{l}"
      end.join
    end
  end

#+end_src

** tests.rb
#+begin_src ruby
  # ./dragon/tests.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # tests.rb has been released under MIT (*only this file*).
  
  # Contributors outside of DragonRuby who also hold Copyright:
  # - Eli Raybon: https://github.com/eliraybon
  
  module GTK
    class Tests
      attr_accessor :failed, :passed, :inconclusive
  
      def initialize
        @failed = []
        @passed = []
        @inconclusive = []
      end
  
      def run_test m
        $serialize_state_serialization_too_large = false
        GTK::Entity.__reset_id__!
        args = Args.new $gtk, nil
        assert = Assert.new
        begin
          log_test_running m
          send(m, args, assert)
          if !assert.assertion_performed
            log_inconclusive m
          else
            log_passed m
          end
        rescue Exception => e
          if test_signature_invalid_exception? e, m
            log_test_signature_incorrect m
          else
            mark_test_failed m, e
          end
        end
      end
  
      def test_methods_focused
        Object.methods.find_all { |m| m.start_with?( "focus_test_") }
      end
  
      def test_methods
        Object.methods.find_all { |m| m.start_with? "test_" }
      end
  
      def start
        log "* TEST: gtk.test.start has been invoked."
        if test_methods_focused.length != 0
          @is_running = true
          test_methods_focused.each { |m| run_test m }
          print_summary
          @is_running = false
        elsif test_methods.length == 0
          log_no_tests_found
        else
          @is_running = true
          test_methods.each { |m| run_test m }
          print_summary
          @is_running = false
        end
      end
  
      def mark_test_failed m, e
        message = "Failed."
        self.failed << { m: m, e: e }
        log message
      end
  
      def running?
        @is_running
      end
  
      def log_inconclusive m
        self.inconclusive << {m: m}
        log "Inconclusive."
      end
  
      def log_passed m
        self.passed << {m: m}
        log "Passed."
      end
  
      def log_no_tests_found
        log <<-S
  No tests were found. To create a test. Define a method
  that begins with test_. For example:
  #+begin_src
  def test_game_over args, assert
  
  end
  #+end_src
  S
      end
  
      def log_test_running m
        log "** Running: #{m}"
      end
  
      def test_signature_invalid_exception? e, m
        error_message = "'#{m.to_s}': wrong number of arguments"
        e.to_s.start_with?(error_message)
      end
  
      def log_test_signature_incorrect m
        log "TEST METHOD INVALID:", <<-S
  I found a test method called :#{m}. But it needs to have
  the following method signature:
  #+begin_src
  def #{m} args, assert
  
  end
  #+end_src
  Please update the method signature to match the code above. If you
  did not intend this to be a test method. Rename the method so it does
  not start with "test_".
  S
      end
  
      def clear_summary
        @passed.clear
        @inconclusive.clear
        @failed.clear
      end
  
      def print_summary
        log "** Summary"
        log "*** Passed"
        log "#{self.passed.length} test(s) passed."
        self.passed.each { |h| log "**** :#{h[:m]}" }
        log "*** Inconclusive"
        if self.inconclusive.length > 0
          log_once :assertion_ok_note, <<-S
  NOTE FOR INCONCLUSIVE TESTS: No assertion was performed in the test.
  Add assert.ok! at the end of the test if you are using your own assertions.
  S
        end
        log "#{self.inconclusive.length} test(s) inconclusive."
        self.inconclusive.each { |h| log "**** :#{h[:m]}" }
        log "*** Failed"
        log "#{self.failed.length} test(s) failed."
        self.failed.each do |h|
          log "**** Test name: :#{h[:m]}"
          log "#{h[:e].to_s.gsub("* ERROR:", "").strip}\n#{h[:e].__backtrace_to_org__}"
        end
      end
    end
  end

#+end_src

** trace.rb
#+begin_src ruby
  # ./dragon/trace.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # trace.rb has been released under MIT (*only this file*).
  
  # Contributors outside of DragonRuby who also hold Copyright:
  # - Dan Healy: https://github.com/danhealy
  
  module GTK
    module Trace
      IGNORED_METHODS = [
        :define_singleton_method, :raise_immediately, :instance_of?,
        :raise_with_caller, :initialize_copy, :class_defined?,
        :instance_variable_get, :format, :purge_class, :instance_variable_defined?,
        :metadata_object_id, :instance_variable_set, :__printstr__,
        :instance_variables, :is_a?, :p, :kind_of?, :==, :log_once,
        :protected_methods, :log_once_info, :private_methods, :open,
        :!=, :initialize, :object_id, :Hash, :methods, :tick, :!,
        :respond_to?, :yield_self, :send, :instance_eval, :then,
        :__method__, :__send__, :log_print, :dig, :itself, :log_info,
        :remove_instance_variable, :raise, :public_methods, :instance_exec,
        :gets, :local_variables, :tap, :__id__, :class, :singleton_class,
        :block_given?, :_inspect, :puts, :global_variables, :getc, :iterator?,
        :hash, :to_enum, :printf, :frozen?, :print, :original_puts,
        :srand, :freeze, :rand, :extend, :eql?, :equal?, :sprintf, :clone,
        :dup, :to_s, :primitive_determined?, :inspect, :primitive?, :help,
        :__object_methods__, :proc, :__custom_object_methods__, :Float, :enum_for,
        :__supports_ivars__?, :nil?, :fast_rand, :or, :and,
        :__caller_without_noise__, :__gtk_ruby_string_contains_source_file_path__?,
        :__pretty_print_exception__, :__gtk_ruby_source_files__,
        :String, :log, :Array, :putsc, :Integer, :===, :here,
        :raise_error_with_kind_of_okay_message, :better_instance_information,
        :lambda, :fail, :method_missing, :__case_eqq, :caller,
        :raise_method_missing_better_error, :require, :singleton_methods,
        :!~, :loop, :numeric_or_default, :`, :state, :inputs, :outputs, "args=".to_sym,
        :grid, :gtk, :dragon, :args, :passes, :tick, :grep_source, :grep_source_file,
        :numeric_or_default, :f_or_default, :s_or_default, :i_or_default,
        :comment, :primitive_marker, :xrepl, :repl
      ]
  
      def self.traced_classes
        @traced_classes ||= []
        @traced_classes
      end
  
      def self.mark_class_as_traced! klass
        @traced_classes << klass
      end
  
      def self.untrace_classes!
        traced_classes.each do |klass|
          klass.class_eval do
            all_methods = klass.instance_methods false
            if klass.instance_methods.respond_to?(:__trace_call_depth__)
              undef_method :__trace_call_depth__
            end
  
            GTK::Trace.filter_methods_to_trace(all_methods).each do |m|
              original_method_name = m
              trace_method_name = GTK::Trace.trace_method_name_for m
              if klass.instance_methods.include? trace_method_name
                alias_method m, trace_method_name
              end
            end
          end
        end
        $last_method_traced = nil
        @traced_classes.clear
        $trace_enabled = false
        if !$gtk.production
          $gtk.write_file_root 'logs/trace.txt', "Add trace!(SOMEOBJECT) to the top of ~tick~ and this file will be populated with invocation information.\n"
        end
      end
  
      def self.trace_method_name_for m
        "__trace_original_#{m}__".to_sym
      end
  
      def self.original_method_name_for m
        return m unless m.to_s.start_with?("__trace_original_") && m.to_s.end_with?("__")
        m[16..-3]
      end
  
      def self.filter_methods_to_trace methods
        methods.reject { |m| m.start_with? "__trace_" }.reject { |m| IGNORED_METHODS.include? m }
      end
  
      def self.trace_times_string
        str = []
        $trace_performance.sort_by {|method_name, times| -times[:avg] }.each do |method_name, times|
          str << "#{method_name}: #{times[:sum].round(2)}/#{times[:count]} #{times[:min]}ms min, #{times[:avg].round(2)}ms avg, #{times[:max]}ms max"
        end
        str.join("\n")
      end
  
      def self.flush_trace pad_with_newline = false
        $trace_puts ||= []
        puts "(Trace info flushed!)"
        if $trace_puts.length > 0
          text = $trace_puts.join("").strip + "\n" + self.trace_times_string + "\n"
          if pad_with_newline
            $gtk.append_file_root 'logs/trace.txt', "\n" + text.strip
          else
            $gtk.append_file_root 'logs/trace.txt', text.strip
          end
        end
        $trace_puts.clear
      end
  
      def self.trace! instance = nil
        $trace_history ||= []
        $trace_enabled = true
        $trace_call_depth ||=0
        $trace_performance = Hash.new {|h,k|
          h[k] = {
            min:   100000,
            max:   0,
            avg:   0,
            sum:   0,
            count: 0
          }
        }
        flush_trace
        instance = $top_level unless instance
        return if Trace.traced_classes.include? instance.class
        all_methods = instance.class.instance_methods false
        instance.class.class_eval do
          attr_accessor :__trace_call_depth__ unless instance.class.instance_methods.include?(:__trace_call_depth__)
          GTK::Trace.filter_methods_to_trace(all_methods).each do |m|
            original_method_name = m
            trace_method_name = GTK::Trace.trace_method_name_for m
            alias_method trace_method_name, m
            $trace_puts << "Tracing #{m} on #{instance.class}.\n"
            define_method(m) do |*args|
              instance.__trace_call_depth__ ||= 0
              tab_width = " " * (instance.__trace_call_depth__ * 8)
              instance.__trace_call_depth__ += 1
              $trace_call_depth = instance.__trace_call_depth__
              parameters = "#{args}"[1..-2]
  
              $trace_puts << "\n  #{tab_width}#{m}(#{parameters})"
  
              execution_time = Time.new
  
              $last_method_traced = trace_method_name
              $trace_history << [m, parameters]
  
              result = send(trace_method_name, *args)
  
              class_m = "#{instance.class}##{m}"
              completion_time = ((Time.new - execution_time).to_f * 1000).round(2)
              $trace_performance[class_m][:min] = [$trace_performance[class_m][:min], completion_time].min
              $trace_performance[class_m][:max] = [$trace_performance[class_m][:max], completion_time].max
              $trace_performance[class_m][:count] += 1
              $trace_performance[class_m][:sum] += completion_time
              $trace_performance[class_m][:avg] = $trace_performance[class_m][:sum].fdiv($trace_performance[class_m][:count])
  
              instance.__trace_call_depth__ -= 1
              instance.__trace_call_depth__ = instance.__trace_call_depth__.greater 0
              $trace_puts << "\n #{tab_width} #{completion_time > 10 ? '!!! ' : ''}#{completion_time}ms success: #{m}"
              if instance.__trace_call_depth__ == 0
                $trace_puts << "\n"
                $trace_history.clear
              end
              result
            rescue Exception => e
              instance.__trace_call_depth__ -= 1
              instance.__trace_call_depth__ = instance.__trace_call_depth__.greater 0
              $trace_puts << "\n #{tab_width} failed: #{m}"
              if instance.__trace_call_depth__ == 0
                $trace_puts << "\n #{tab_width}         #{e}"
                $trace_puts << "\n"
              end
              $trace_call_depth = 0
              GTK::Trace.flush_trace true
              raise e
            end
          end
        end
        mark_class_as_traced! instance.class
      end
    end
  end

#+end_src

** tweetcart.rb
#+begin_src ruby
  # ./dragon/tweetcart.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # tweetcart.rb has been released under MIT (*only this file*).
  
  def $top_level.TICK &block
    $top_level.define_method(:tick) do |args|
      args.outputs[:scene].transient!
      args.outputs[:scene].w = 160
      args.outputs[:scene].h = 90
      args.outputs[:scene].background_color = [0, 0, 0, 0]
      $args.state.tweetcart_state ||= {
        pallet_number: 0,
        render_method: :scene
      }
      args.state.tweet_scene ||= { x: 0, y: 0, w: 1280, h: 720, path: :scene }
      $tweetcart_palette ||= create_tweetcart_palette
      block.call args
      if args.state.tweetcart_state.render_method == :scene
        args.outputs.sprites << args.state.tweet_scene
      elsif args.state.tweetcart_state.render_method == :pixels
        args.pixel_array(:pixels).width = 160
        args.pixel_array(:pixels).height = 90
        r, g, b = $tweetcart_palette[args.state.tweetcart_state.pallet_number]
        abgr_hex = (0xFF << 24) | (b << 16) | (g << 8) | r
        args.pixel_array(:pixels).pixels.fill(abgr_hex, 0, 160 * 90)
        args.outputs.primitives << { x: 0, y: 0, w: 1280, h: 720, path: :pixels }
      else
        raise "I don't know how to process $args.state.tweetcart_state with value #{$args.state.tweetcart_state}"
      end
    end
  
    def $top_level.pixels!
      return if $args.state.tweetcart_state.render_method == :pixels
      $args.state.tweetcart_state.render_method = :pixels
    end
  
    def $top_level.color pallet_number
      $args.state.tweetcart_state.pallet_number = pallet_number
    end
  
    def $top_level.no_clr! render_target_name = :scene
      $top_level.no_clear! render_target_name
    end
  
    def $top_level.no_clear! render_target_name = :scene
      $args.outputs[render_target_name].clear_before_render = false
    end
  
    def $top_level.bg! *rgb
      r,g,b = rgb
      r ||= 255
      g ||= r
      b ||= g
      $args.outputs.background_color = [r, g, b]
    end
  
    def $top_level.slds
      $args.outputs[:scene].sprites
    end
  
    def $top_level.slds! *os
      if (os.first.is_a? Numeric)
        sld!(*os)
      else
        os.each { |o| sld!(*o) }
      end
    end
  
    def $top_level.sld! *params
      x, y, w, h, r, g, b, a = nil
      if params.length == 2
        x, y = params
      elsif params.length == 3 && (params.last.is_a? Array)
        x = params[0]
        y = params[1]
        r, g, b, a = params[2]
        r ||= 255
        g ||= r
        b ||= g
        a ||= 255
      elsif params.length == 4
        x, y, w, h = params
      elsif params.length == 5 && (params.last.is_a? Array)
        x = params[0]
        y = params[1]
        w = params[2]
        h = params[3]
        r,g,b,a = params[4]
        r ||= 255
        g ||= r
        b ||= g
        a ||= 255
      elsif params.length >= 7
        x, y, w, h, r, g, b = params
      else
        raise "I don't know how to render #{params} with reasonable defaults."
      end
  
      w ||= 1
      h ||= 1
      r ||= 255
      g ||= 255
      b ||= 255
      a ||= 255
  
      slds << { x: x, y: y,
                w: w, h: h,
                r: r, g: g, b: b, a: a,
                path: :pixel }
    end
  
    def $top_level.sin_r radians
      Math.sin radians
    end
  
    def $top_level.cos_r radians
      Math.cos radians
    end
  
    def $top_level.sin degrees
      Math.sin degrees.to_radians
    end
  
    def $top_level.cos degrees
      Math.cos degrees.to_radians
    end
  
    def $top_level.sin_d degrees
      Math.sin degrees.to_radians
    end
  
    def $top_level.cos_d degrees
      Math.cos degrees.to_radians
    end
  
    def $top_level.tc
      $args.state.tick_count
    end
  
    def $top_level.scene! w = 1280, h = 720, scale = nil
      scale ||= begin
                  x_scale = $args.grid.w / w
                  y_scale = $args.grid.h / h
                  x_scale < y_scale ? x_scale : y_scale
                end
  
      $args.outputs[:scene].w = w
      $args.outputs[:scene].h = h
      $args.state.tweet_scene.w = w * scale
      $args.state.tweet_scene.h = h * scale
      $args.state.tweet_scene.x = ($args.grid.w - w * scale) / 2
      $args.state.tweet_scene.y = ($args.grid.h - h * scale) / 2
    end
  
    def create_tweetcart_palette
      [
        [   0,   0,   0 ],
        [  34,  32,  52 ],
        [  69,  40,  60 ],
        [ 102,  57,  49 ],
        [ 143,  86,  59 ],
        [ 223, 113,  38 ],
        [ 217, 160, 102 ],
        [ 238, 195, 154 ],
        [ 251, 242,  54 ],
        [ 153, 229,  80 ],
        [ 106, 190,  48 ],
        [  55, 148, 110 ],
        [  75, 105,  47 ],
        [  82,  75,  36 ],
        [  50,  60,  57 ],
        [  63,  63, 116 ],
        [  48,  96, 130 ],
        [  91, 110, 225 ],
        [  99, 155, 255 ],
        [  95, 205, 228 ],
        [ 203, 219, 252 ],
        [ 255, 255, 255 ],
        [ 155, 173, 183 ],
        [ 132, 126, 135 ],
        [ 105, 106, 106 ],
        [  89,  86,  82 ],
        [ 118,  66, 138 ],
        [ 172,  50,  50 ],
        [ 217,  87,  99 ],
        [ 215, 123, 186 ],
        [ 143, 151,  74 ],
        [ 138, 111,  48 ]
      ]
    end
  
    def $top_level.pal
      $tweetcart_palette
    end
  end
  
  =begin
  wht  = [255] * 3
  red  = [255, 0, 0]
  blu  = [0, 130, 255]
  purp = [150, 80, 255]
  
  TICK {
    bg! 0
  
    slds << [0, 0, 3, 3, 0, 255, 0, 255]
  
    sld!     10, 10
    sld!     20, 20, 3, 2
    sld!     30, 30, 2, 2, red
    sld!     35, 35, blu
  
    slds!    40, 40
  
    slds!   [50, 50],
            [60, 60, purp],
            [70, 70, 10, 10, wht],
            [80, 80, 4, 4, 255, 0, 255]
  }
  =end

#+end_src

** wizards.rb
#+begin_src ruby
  # ./dragon/wizards.rb
  # coding: utf-8
  # Copyright 2019 DragonRuby LLC
  # MIT License
  # wizards.rb has been released under MIT (*only this file*).
  
  class Wizard
    def metadata_file_path
      "metadata/game_metadata.txt"
    end
  
    def get_metadata
      metadata = $gtk.read_file metadata_file_path
  
      if !metadata
        write_blank_metadata
        metadata = $gtk.read_file metadata_file_path
      end
  
      kvps = metadata.each_line
                     .reject { |l| l.strip.length == 0 || (l.strip.start_with? "#") }
                     .map do |l|
                       key, value = l.split("=")
                       [key.strip.to_sym, value.strip]
                     end.flatten
  
      default_metadata = {
        devid: "myname",
        devtitle: "My Name",
        gameid: "mygame",
        gametitle: "My Game",
        version: "0.1",
        icon: "metadata/icon.png"
      }
  
      parsed_metadata = Hash[*kvps]
  
      default_metadata.merge parsed_metadata
    end
  
    def help
      puts "* INFO: No help available for Wizard of type ~#{self.class.name}~"
    end
  
    def process_wizard_exception e
      # queue the exception to be added after current standard out has been processed.
      queue_at = Kernel.global_tick_count + 3
      $console.clear_logs global_at: queue_at - 1
      $console.add_primitive ("=" * $console.console_text_width), global_at: queue_at
      e.console_primitives.each do |p|
        $console.add_primitive p, global_at: queue_at
      end
      $console.add_primitive ("=" * $console.console_text_width), global_at: queue_at
    end
  
    def last_executed_steps
      @last_executed_steps
    end
  
    def execute_steps steps
      log "================"
      log "* INFO: Starting #{display_name}."
      @start_at = Kernel.global_tick_count
  
      @last_executed_steps = steps
  
      steps.each do |m|
        before_step = "before_#{m}".to_sym
        after_step = "after_#{m}".to_sym
        send before_step if respond_to? before_step
        log_info "Running step ~:#{m}~."
        if @wizard_status[m][:result] != :success
          result = (send m)
          if !result || result.is_a?(Symbol) == false
            raise "Step ~:#{m}~ returned nil. Expected a symbol (:success if everything went well)."
          end
  
          return result if result != :success
        end
        send after_step if respond_to? after_step
        @wizard_status[m][:result] = result
        log_info "Running step ~:#{m}~ complete."
      end
  
      return :success
    rescue Exception => e
      if e.is_a? WizardException
        process_wizard_exception e
      else
        log_error e.to_s
        log e.__backtrace_to_org__
      end
      return :exception
    end
  
    def display_name
      self.class.name
    end
  end
  
  class WizardException < Exception
    attr_accessor :console_primitives
  
    def initialize *console_primitives
      @console_primitives = console_primitives
    end
  end
  
  module GTK
    class Wizards
      attr_accessor :ios, :itch
  
      def initialize
        @ios = IOSWizard.new
        @itch = ItchWizard.new
      end
    end
  end

#+end_src

